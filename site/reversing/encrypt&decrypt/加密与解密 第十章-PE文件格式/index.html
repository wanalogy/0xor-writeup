<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>加密与解密 第十章 PE文件格式 - 0Xor' CTF WriteUp</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u52a0\u5bc6\u4e0e\u89e3\u5bc6 \u7b2c\u5341\u7ae0 PE\u6587\u4ef6\u683c\u5f0f";
    var mkdocs_page_input_path = "reversing\\encrypt&decrypt\\\u52a0\u5bc6\u4e0e\u89e3\u5bc6 \u7b2c\u5341\u7ae0-PE\u6587\u4ef6\u683c\u5f0f.md";
    var mkdocs_page_url = "/reversing/encrypt&decrypt/\u52a0\u5bc6\u4e0e\u89e3\u5bc6 \u7b2c\u5341\u7ae0-PE\u6587\u4ef6\u683c\u5f0f/";
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js"></script>
  <script src="../../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> 0Xor' CTF WriteUp</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../..">Welcome to 0Xor' WriteUp</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Reversing</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Moblie/">Moblie</a>
                </li>
                <li class="">
                    
    <a class="" href="../../reversing%20misc/">reversing misc</a>
                </li>
                <li class=" current">
                    
    <span class="caption-text">Encrypt&decrypt</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%20%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">加密与解密 第一章 基础知识</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%20%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9D%99%E6%80%81%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/">加密与解密 第三章 静态调试技术</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/">加密与解密 第二章 动态调试技术</a>
                </li>
                <li class="toctree-l3 current">
                    
    <a class="current" href="./">加密与解密 第十章 PE文件格式</a>
    <ul class="subnav">
            
    <li class="toctree-l4"><a href="#pe">第十章  PE文件格式</a></li>
    
        <ul>
        
            <li><a class="toctree-l5" href="#101-pe">10.1  PE的基本概念</a></li>
        
            <li><a class="toctree-l5" href="#102-ms-dos">10.2  MS-DOS头部</a></li>
        
            <li><a class="toctree-l5" href="#103-pe">10.3  PE文件头</a></li>
        
            <li><a class="toctree-l5" href="#104">10.4  区块</a></li>
        
            <li><a class="toctree-l5" href="#105">10.5  输入表</a></li>
        
            <li><a class="toctree-l5" href="#106">10.6  绑定输入</a></li>
        
            <li><a class="toctree-l5" href="#107">10.7  输出表</a></li>
        
            <li><a class="toctree-l5" href="#108">10.8  基址重定位</a></li>
        
            <li><a class="toctree-l5" href="#109">10.9  资源</a></li>
        
            <li><a class="toctree-l5" href="#1010-tls">10.10  TLS初始化</a></li>
        
            <li><a class="toctree-l5" href="#1011_1">10.11  调试目录</a></li>
        
            <li><a class="toctree-l5" href="#1012_1">10.12  延迟装入数据</a></li>
        
            <li><a class="toctree-l5" href="#1013_1">10.13  程序异常数据</a></li>
        
            <li><a class="toctree-l5" href="#1014-net">10.14  .Net头部</a></li>
        
            <li><a class="toctree-l5" href="#1015-pe">10.15  编写PE分析工具</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%20%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">加密与解密 第四章 逆向分析技术</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../%E7%9B%AE%E5%BD%95/">目录</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Wargame</span>
    <ul class="subnav">
                <li class="">
                    
    <span class="caption-text">Crypto</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_PHP_decode/">[ctf.nuptzj.cn] PHP decode</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_base64_N_times/">[ctf.nuptzj.cn] base64 N times</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_base64_all/">[ctf.nuptzj.cn] base64 all</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_easy/">[ctf.nuptzj.cn] easy</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_keyboard/">[ctf.nuptzj.cn] keyboard</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_md5/">[ctf.nuptzj.cn] md5</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_mixed_base64/">[ctf.nuptzj.cn] mixed base64</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_vigenere/">[ctf.nuptzj.cn] vigenere</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/%5Bctf.nuptzj.cn%5D_xor/">[ctf.nuptzj.cn] xor</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/crypto/crypto_summary/">Crypto summary</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">Misc</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/misc/%5Bctf.nuptzj.cn%5D_gif/">[ctf.nuptzj.cn] gif</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/misc/%5Bctf.nuptzj.cn%5D_qiubilong/">[ctf.nuptzj.cn] qiubilong</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/misc/%5Bctf.nuptzj.cn%5D_tuzhong/">[ctf.nuptzj.cn] tuzhong</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">Reversing</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/reversing/%5Bbugku.com%5D_ali/">[bugku.com] ali</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/reversing/%5Bctf.nuptzj.cn%5D_ReadAsm2/">[ctf.nuptzj.cn] ReadAsm2</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/reversing/%5Bctf.nuptzj.cn%5D_maze/">[ctf.nuptzj.cn] maze</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/reversing/%5Bctf.nuptzj.cn%5D_py/">[ctf.nuptzj.cn] py</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/reversing/%5Bctf.nuptzj.cn%5D_wxyvm/">[ctf.nuptzj.cn] wxyvm</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/reversing/%5Bctf.nuptzj.cn%5D_wxyvm2/">[ctf.nuptzj.cn] wxyvm2</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/reversing/%5Bwhaleedu.com%5D_dice/">[whaleedu.com] dice</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/reversing/%5Bwhaleedu.com%5D_pyc1/">[whaleedu.com] pyc1</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">Web</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bbugku.com%5D_upload_test/">[bugku.com] upload test</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bbugku.com%5D_web2/">[bugku.com] web2</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_20_years/">[ctf.nuptzj.cn] 20 years</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_aaencode/">[ctf.nuptzj.cn] aaencode</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_bypass_again/">[ctf.nuptzj.cn] bypass again</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_cookie/">[ctf.nuptzj.cn] cookie</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_md5_collision/">[ctf.nuptzj.cn] md5 collision</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_multi-byte_character/">[ctf.nuptzj.cn] multi byte character</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_mysql/">[ctf.nuptzj.cn] mysql</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_pass%20check/">[ctf.nuptzj.cn] pass check</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_php_0x/">[ctf.nuptzj.cn] php 0x</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_php_LFI/">[ctf.nuptzj.cn] php LFI</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_php_decode/">[ctf.nuptzj.cn] php decode</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_qiandao/">[ctf.nuptzj.cn] qiandao</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_qiandao2/">[ctf.nuptzj.cn] qiandao2</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_sql_injection_1/">[ctf.nuptzj.cn] sql injection 1</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_sql_injection_2/">[ctf.nuptzj.cn] sql injection 2</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_sql_injection_4/">[ctf.nuptzj.cn] sql injection 4</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_upload_file/">[ctf.nuptzj.cn] upload file</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_url_redirect/">[ctf.nuptzj.cn] url redirect</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_var_override/">[ctf.nuptzj.cn] var override</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_web3/">[ctf.nuptzj.cn] web3</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_where_are_you_come_from/">[ctf.nuptzj.cn] where are you come from</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_x00/">[ctf.nuptzj.cn] x00</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_zonghe/">[ctf.nuptzj.cn] zonghe</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bctf.nuptzj.cn%5D_zonghe2/">[ctf.nuptzj.cn] zonghe2</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_add_something/">[shiyanbar.com] add something</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_be_serious/">[shiyanbar.com] be serious</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_forms/">[shiyanbar.com] forms</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_guaiwanmojiao/">[shiyanbar.com] guaiwanmojiao</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_houtaidenglu/">[shiyanbar.com] houtaidenglu</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_post_fast/">[shiyanbar.com] post fast</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_simple_sql_injection/">[shiyanbar.com] simple sql injection</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_simple_sql_injection_2/">[shiyanbar.com] simple sql injection 2</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/%5Bshiyanbar.com%5D_simple_sql_injection_3/">[shiyanbar.com] simple sql injection 3</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../wargame/web/web_summary/">Web summary</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Web</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../web/sqlmap_learning/">Sqlmap learning</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">0Xor' CTF WriteUp</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
        
          <li>Reversing &raquo;</li>
        
      
        
          <li>Encrypt&decrypt &raquo;</li>
        
      
    
    <li>加密与解密 第十章 PE文件格式</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>第五篇  系统篇</p>
<h3 id="pe">第十章  PE文件格式</h3>
<ul>
<li>
<p>主要文件：<code>winnt.h -&gt; image format</code></p>
</li>
<li>
<p>PE布局</p>
</li>
</ul>
<p><img alt="1533208584880" src="../../../_images/crypto/1533208584880.png" /></p>
<h4 id="101-pe">10.1  PE的基本概念</h4>
<ul>
<li>磁盘文件偏移和内存偏移的转换</li>
</ul>
<p><img alt="1533208748505" src="../../../_images/crypto/1533208748505.png" /></p>
<h5 id="1011">10.1.1  基地址</h5>
<ul>
<li>
<p>模块：加载到内存中的PE文件被称为模块</p>
</li>
<li>
<p>模块句柄（hModule）：映射文件的起始地址，这个初始内存地址也称作基地址（ImageBase）</p>
</li>
<li>
<p>访问DLL文件,得到指针：</p>
</li>
</ul>
<p><code>c
  HMODULE GetModuleHandle(LPCTSTR lpModuleName);</code></p>
<h5 id="1012">10.1.2  相对虚拟地址</h5>
<p>相对地址（RVA）：内存中，相对于ImageBase的偏移</p>
<pre><code>目标地址401000h - 装入地址 400000h = RVA 1000h
</code></pre>

<blockquote>
<p>虚拟地址(VA) = 基地址（Image Base） + 相对虚拟地址（RVA）</p>
</blockquote>
<h5 id="1013">10.1.3  文件偏移地址</h5>
<p>FileOffset/RawOffset:PE文件存储在磁盘上时，相对于文件头的偏移，起始值时0</p>
<h4 id="102-ms-dos">10.2  MS-DOS头部</h4>
<p><code>DOS头部 = DOS MZ 头 + DOS stub</code></p>
<pre><code class="c">typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
</code></pre>

<ul>
<li>e_magic：MZ</li>
<li>e_lfanew: PE头的真正偏移量</li>
</ul>
<h4 id="103-pe">10.3  PE文件头</h4>
<p><code>PNETHeader = ImageBase + dosHeaser-&gt;e_lfanew</code></p>
<pre><code class="c">typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
</code></pre>

<h5 id="1031-signature">10.3.1  Signature字段</h5>
<p>作用：用来验证该文件是否时PE文件</p>
<pre><code class="c">#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00
</code></pre>

<h5 id="1032-image_file_header">10.3.2  IMAGE_FILE_HEADER结构</h5>
<pre><code class="c">typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
</code></pre>

<p>字段：</p>
<ul>
<li>SizeOfOptionalHeader：OptionalHeader字段的大小  <strong>重要</strong></li>
<li>Characteristics： </li>
<li>普通exe文件：010fh</li>
<li>DLL文件：0210h</li>
</ul>
<h5 id="1033-image_optional_header">10.3.3  IMAGE_OPTIONAL_HEADER结构</h5>
<pre><code class="c">typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
</code></pre>

<p>字段：</p>
<ul>
<li>
<p>Magic</p>
</li>
<li>
<p>ROM映像：0107h</p>
</li>
<li>普通可执行的映像：010Bh</li>
<li>
<p>PE32+：020Bh</p>
</li>
<li>
<p>SizeOfCode</p>
</li>
<li>
<p>多数文件只有一个code块，所以这个字段和.text的大小匹配</p>
</li>
<li>
<p>SizeOfUninitializedData</p>
</li>
</ul>
<p>未初始化数据通常位于.bss段</p>
<ul>
<li><strong>AddressOfEntryPoint</strong></li>
</ul>
<p>程序执行入口的RVA</p>
<ul>
<li><strong>BaseofCode</strong></li>
</ul>
<p>代码段的RVA，通常为1000h</p>
<p><strong>PS</strong>: 查看了本书的几个示例：</p>
<ul>
<li>pe.exe和pediy.exe的入口地址和代码基址是相同的</li>
<li>
<p>tls.exe和delaydll.exe的入口地址和代码基址是不同的</p>
</li>
<li>
<p>[ ]   进一步研究原因</p>
</li>
<li>
<p>BaseOfData：数据段的起始RVA</p>
</li>
<li>
<p><strong>ImageBase：映像基址</strong></p>
</li>
<li>
<p><strong>SectionAlignment</strong>：装入内存时的区块对齐大小，默认是目标CPU的页尺寸，win98/me上，最小一页是1000h</p>
</li>
<li>
<p><strong>FileAlignment</strong>：磁盘上PE文件的对齐大小，对x86，通常是200h或者1000h</p>
</li>
<li>
<p>SizeOfImage：装入内存后的总尺寸</p>
</li>
<li>
<p>SizeOfHeaders：MS-DOS头、PE头、区块表的组合尺寸</p>
</li>
<li>
<p>NumberOfRvaAndSizes: 数据目录的项数：16</p>
</li>
<li>
<p>DataDirectory[16]: 数据目录表，单个项目的结构如下：</p>
</li>
</ul>
<p>```c
  typedef struct _IMAGE_DATA_DIRECTORY {
      DWORD   VirtualAddress;
      DWORD   Size;
  } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</p>
<p>```</p>
<p>项目如下：</p>
<p><img alt="1533212535609" src="../../../_images/crypto/1533212535609.png" /></p>
<h4 id="104">10.4  区块</h4>
<h5 id="1041">10.4.1  区块表</h5>
<ul>
<li>结构：</li>
</ul>
<p><code>c
  typedef struct _IMAGE_SECTION_HEADER {
      BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
      union {
              DWORD   PhysicalAddress;
              DWORD   VirtualSize;
      } Misc;
      DWORD   VirtualAddress;
      DWORD   SizeOfRawData;
      DWORD   PointerToRawData;
      DWORD   PointerToRelocations;
      DWORD   PointerToLinenumbers;
      WORD    NumberOfRelocations;
      WORD    NumberOfLinenumbers;
      DWORD   Characteristics;
  } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</code></p>
<p>示例：</p>
<p><img alt="1533213879253" src="../../../_images/crypto/1533213879253.png" /></p>
<ul>
<li>
<p>name：块名</p>
</li>
<li>
<p>VirtualSize（VSize）：实际的、被使用的区块大小，是区块在没被对齐处理之前的大小</p>
</li>
<li>
<p>VitrualAddress（Voffset）：装载到内存中的RVA，按照内存对齐，默认为1000h</p>
</li>
<li>
<p>SizeOfRawData（Rsize）：在磁盘中的大小，经过了对齐，FileAlignment默认大小为200h</p>
</li>
<li>
<p>PointerToRawData（Roffset）：磁盘文件中的偏移。如果程序自装载，这个字段比VitrualAddress更重要</p>
</li>
<li>
<p>Characteristics：</p>
</li>
</ul>
<p><img alt="1533214593063" src="../../../_images/crypto/1533214593063.png" /></p>
<p>这里指定了区块的可读、可写、可执行属性</p>
<h5 id="1042">10.4.2  各种区块的描述</h5>
<p><img alt="1533214817555" src="../../../_images/crypto/1533214817555.png" /></p>
<p><img alt="1533214867426" src="../../../_images/crypto/1533214867426.png" /></p>
<ul>
<li>
<p>本章未涉及到的区块从略</p>
</li>
<li>
<p>自定义区块，在vc++中：</p>
</li>
</ul>
<p><code>c
  #prama data_seg("My_Data")</code></p>
<p>定义后，vc++处理的所有数据都会放到上述的区块中，而不是默认的.data区块中</p>
<ul>
<li>
<p>区块的形成：链接器从全部obj中提取相似一致属性的块合并成一个块</p>
</li>
<li>
<p>链接器合并区块：使用<code>/merge</code>开关 </p>
</li>
</ul>
<p><code>/MERGE:.rdata=.text ;将rdata段和text段合并</code></p>
<h5 id="1043">10.4.3  区块的对齐值</h5>
<ul>
<li>
<p>对齐值种类</p>
</li>
<li>
<p>内存对齐</p>
<p>默认对齐值：1000h（4KB）</p>
</li>
<li>
<p>磁盘文件对齐</p>
<p>典型对齐值：200h</p>
</li>
</ul>
<h5 id="1044">10.4.4  文件偏移与虚拟地址转换</h5>
<p><img alt="1533215453974" src="../../../_images/crypto/1533215453974.png" /></p>
<ul>
<li>关系：</li>
</ul>
<p><code>File Offset = RVA - k
  File Offset = VA - Imagebase - k</code></p>
<ul>
<li>各区段偏移量</li>
</ul>
<p><img alt="1533215679930" src="../../../_images/crypto/1533215679930.png" /></p>
<h4 id="105">10.5  输入表</h4>
<ul>
<li>输入：可执行文件使用来自其他DLL的代码或者数据时，称为输入</li>
<li>作用：定位所有被输入的函数和数据，让正在被装入的文件可以使用这些地址，windows加载器就需要使用输入表（improt table，IT，导入表）</li>
</ul>
<h5 id="1051">10.5.1  输入函数的调用</h5>
<ul>
<li>
<p>调用方式</p>
</li>
<li>
<p>隐式调用</p>
<p>由windows加载器完成</p>
</li>
<li>
<p>显式调用</p>
<p>由程序自己调用LoadLibrary和GetProcessAddress完成</p>
</li>
<li>
<p>输入地址表（IAT）</p>
</li>
<li>
<p>调用一个输入函数的实际过程</p>
<ol>
<li>默认方式</li>
</ol>
<p><code>asm
CALL DWORD PTR [00402010]</code></p>
<p>地址<code>00402010</code>位于IAT中，但实际的调用代码如下：</p>
<p><code>asm
    Call 00401164
...
:00401164
    jmp dword ptr  [00402010]</code></p>
<ul>
<li>问题：代码低效</li>
<li>原因：</li>
<li>编译器无法识别输入函数的调用和普通函数的调用</li>
<li>
<p>编译器生成类似<code>call xxxxxx</code>的指令，而<code>xxxxxx</code>需要由链接器填充，该指令不是从函数指针处得来，而是从代码的实际地址而来，为了因果平衡，简单的方法就是产生上述的<code>jmp stub</code></p>
</li>
<li>
<p>优化：</p>
</li>
</ul>
<p>使用<code>__declspec(dllimport)</code>修饰函数，得到的指令形式如下：</p>
<p><code>asm
   CALL XXXXXXXX</code></p>
</li>
</ul>
<h5 id="1052">10.5.2  输入表结构</h5>
<ul>
<li>头文件定义</li>
</ul>
<p>```asm
  typedef struct _IMAGE_IMPORT_DESCRIPTOR {
      union {
          DWORD   Characteristics;            // 0 for terminating null import descriptor
          DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
      };
      DWORD   TimeDateStamp;                  // 0 if not bound,
                                              // -1 if bound, and real date\time stamp
                                              //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                              // O.W. date/time stamp of DLL bound to (Old BIND)</p>
<pre><code>  DWORD   ForwarderChain;                 // -1 if no forwarders 
  DWORD   Name;
  DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
</code></pre>
<p>} IMAGE_IMPORT_DESCRIPTOR;
  typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</p>
<p>```</p>
<ul>
<li>结构图</li>
</ul>
<p><img alt="1533217349998" src="../../../_images/crypto/1533217349998.png" /></p>
<ul>
<li>IMAGE_THUNK_DATA 的定义如下</li>
</ul>
<p><code>c
  typedef struct _IMAGE_THUNK_DATA32 {
      union {
          DWORD ForwarderString;      // PBYTE 
          DWORD Function;             // PDWORD
          DWORD Ordinal;
          DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME
      } u1;
  } IMAGE_THUNK_DATA32;
  typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</code></p>
<ul>
<li>
<p>ForwarderString：</p>
<p>可以看出，INT和IAT其实都是链表结构，<code>ForwarderString</code>指针指向下一个表项，其结构也是IMAGE_THUNK_DATA </p>
</li>
<li>
<p>AddressOfData：指向函数名，这里包含在数据结构<code>IMAGE_IMPORT_BY_NAME</code>中</p>
</li>
<li>
<p><code>IMAGE_IMPORT_BY_NAME</code>的定义</p>
</li>
</ul>
<p><code>c
  typedef struct _IMAGE_IMPORT_BY_NAME {
      WORD    Hint;
      BYTE    Name[1];
  } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</code></p>
<h5 id="1053-iat">10.5.3  输入地址表（IAT）</h5>
<ul>
<li>IAT和INT结构相同是否是重复？</li>
</ul>
<p>INT表（又称为提示名表Hint-name Table）不可以改写，IAT由PE装载器重写</p>
<ul>
<li>
<p>执行流程</p>
</li>
<li>
<p>PE装载器首先搜索<code>OriginalFirstThunk</code></p>
</li>
<li>
<p>如果找到，加载器迭代搜索数组中的每一个指针（<code>*PIMAGE_IMPORT_BY_NAME</code>），依据其中的函数名<code>Name</code>找到其指向的输入函数的地址</p>
</li>
<li>
<p>找到地址之后，会将IAT表中<code>IMAGE_IMPORT_BY_NAME</code>中的Name字段替换为真实的函数地址，这个时候，IT结构中除了IAT表之外的结构就已经不需要了</p>
</li>
<li>
<p>PE加载器加载完成的图如下所示：</p>
<p><img alt="1533219874880" src="../../../_images/crypto/1533219874880.png" /></p>
</li>
<li>
<p>例外情况</p>
</li>
<li>
<p>函数仅由序号引出</p>
<ul>
<li>不能用函数名调用，只能通过他们的位置调用</li>
<li>将<code>IMAGE_THUNK_DATA</code>的最高二进位设置为1，用低字节指示函数序数 </li>
</ul>
</li>
<li>orignalFirstThunk的值为0<ul>
<li>使用<code>FirstThunk</code>来替代<code>orignalFirstThunk</code>的作用</li>
<li>[ ]   <strong>这里不是很懂，以后再来分析</strong></li>
</ul>
</li>
</ul>
<h5 id="1054">10.5.4  输入表实例分析</h5>
<ul>
<li>
<p>分析pe.exe</p>
</li>
<li>
<p>确定IT表的位置</p>
<p>IT指针RVA : B0h(相对pe头的偏移) + 80h（pe头的RVA） = 130h</p>
</li>
<li>
<p>计算IT表的物理位置（包含多个IDD项）</p>
<p>130h处的四字节为：40 20 00 00</p>
<p>即地址为<code>00002040h</code></p>
<ol>
<li><code>2040h</code>位于.rdata段，虚拟偏移和物理偏移的差值k=2000h-600h=1A00h</li>
<li><code>2040h</code>的物理偏移：2040h - 1A00h = 640h</li>
</ol>
</li>
<li>
<p>读取IT表的内容</p>
<p>定位到640h处，可以看到其IDD内容，每个IDD有五个双字</p>
<p><img alt="1533221141077" src="../../../_images/crypto/1533221141077.png" /></p>
<p>整理后的结果：</p>
<p><img alt="1533221182225" src="../../../_images/crypto/1533221182225.png" /></p>
</li>
<li>
<p>确定Name名称</p>
<p>以第一个为例：</p>
<ol>
<li>
<p>Name字段的值为<code>74210000</code>，转换成RVA：00002174h，转换成物理偏移：774h</p>
</li>
<li>
<p>查看该处地址值，为：USER32.dll</p>
</li>
<li>
<p>查找后的数组如下</p>
<p><img alt="1533221589333" src="../../../_images/crypto/1533221589333.png" /></p>
</li>
</ol>
</li>
<li>
<p>查找USER32.dll中被调用的函数</p>
<ol>
<li>
<p>查看IDD的OriginalFirstThunk字段<code>208ch</code>，计算得到物理偏移<code>208ch-1A00h=68Ch</code></p>
</li>
<li>
<p>在<code>68Ch</code>处找到<code>IMAGE_THUNK_DATA</code> 数组，它存储着指向<code>_IMAGE_IMPORT_BY_NAME</code>结构的指针，结果如下：</p>
<p><img alt="1533221952983" src="../../../_images/crypto/1533221952983.png" /></p>
</li>
<li>
<p>查看同一IDD的<code>FirstThunk</code>，在其偏移处610h（2010h - 1A00h）得到<code>IMAGE_THUNK_DATA</code> ，和上表中的字段 ==<strong>完全一致</strong>==</p>
<p><strong>PS：这是书中的说法，但我实际测试发现，其实610h处是一段字符串，并不一致，如下：</strong></p>
<p><img alt="1533222238201" src="../../../_images/crypto/1533222238201.png" /></p>
<p>pe.exe也是使用书中给出的样本，感觉这里作者可能有错误，如果大家发现了是我的问题，还请不吝赐教:thinking:</p>
</li>
<li>
<p>先看前两个函数调用</p>
<ul>
<li>2100h - 1A00h = 710h，该处地址字符串为：LoadIconA</li>
<li>211Ch - 1A00h = 71Ch，该处地址字符串为：PostQuitMessage</li>
</ul>
</li>
<li>
<p>最后得到所有的函数引用：</p>
<p><img alt="1533222681312" src="../../../_images/crypto/1533222681312.png" /></p>
</li>
<li>
<p>得到第一个IDD在PE加载器运行前的结构</p>
<p><img alt="1533222947543" src="../../../_images/crypto/1533222947543.png" /></p>
</li>
</ol>
</li>
<li>
<p>查看dump.exe，其为抓取的IDD加载完成后的内存印象</p>
<p><img alt="1533223283881" src="../../../_images/crypto/1533223283881.png" /></p>
</li>
<li>
<p>可以发现，其值已经发生了变化，得到下列表格：</p>
<p><img alt="1533223393963" src="../../../_images/crypto/1533223393963.png" /></p>
</li>
<li>
<p>查看<code>77D216DDh</code>地址处的反汇编代码：</p>
<p><img alt="1533223496350" src="../../../_images/crypto/1533223496350.png" /></p>
<p>发现就是LoadIconA处的代码</p>
</li>
<li>
<p>pe.exe装载到内存之后的IDD结构示意图如下：</p>
<p><img alt="1533223581836" src="../../../_images/crypto/1533223581836.png" /></p>
</li>
<li>
<p>调用LoadIconA的代码如下：</p>
<p><img alt="1533223696890" src="../../../_images/crypto/1533223696890.png" /></p>
</li>
</ul>
<h4 id="106">10.6  绑定输入</h4>
<ul>
<li>产生的原因：</li>
</ul>
<p>查找替换函数地址的过程，需要很多的时间</p>
<ul>
<li>解决办法：</li>
</ul>
<p>提前将实际地址加载到IAT表中</p>
<ul>
<li>
<p>前提条件：</p>
</li>
<li>
<p>进程初始化时，需要的DLL实际已经加载到了它们的首选基址</p>
</li>
<li>
<p>绑定之后，DLL输出表中引用符号的位置一致没有改变</p>
</li>
<li>
<p>如果出现地址改变，怎么办</p>
</li>
</ul>
<p>加载器从INT表中找到需要信息，重新读取正确的地址</p>
<ul>
<li>绑定输入位置：</li>
</ul>
<p>DataDirectory的第11个成员指向，以_IMAGE_BOUND_IMPORT_DESCRIPTOR结构的数组开始</p>
<p><code>c
  typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
      DWORD   TimeDateStamp;    被输入DLL的时间，以便加载器快速判断绑定是不是最新的
      WORD    OffsetModuleName; 指向被输入DLL的名称的偏移，与第一个IBID结构之间的偏移
      WORD    NumberOfModuleForwarderRefs; 其后ModuleForwarderRefs的数目
  // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
  } IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</code></p>
<p><strong>PS：该节内容不大理解，以后用到了再研究</strong></p>
<h4 id="107">10.7  输出表</h4>
<h5 id="1071-287">10.7.1  输出表结构 287</h5>
<ul>
<li>IED结构定义</li>
</ul>
<p>```CQL
  typedef struct _IMAGE_EXPORT_DIRECTORY {
      DWORD   Characteristics;
      DWORD   TimeDateStamp;
      WORD    MajorVersion;
      WORD    MinorVersion;
      DWORD   Name; //DLL的名称
      DWORD   Base; //起始序数值，正常为1，查询输出函数时，将该值减去，得到进入EAT的索引
      DWORD   NumberOfFunctions;    //EAT中的条目数量
      DWORD   NumberOfNames;    //ENT表中的条目数量
      DWORD   AddressOfFunctions;     // EAT的RVA
      DWORD   AddressOfNames;         // ENT的RVA
      DWORD   AddressOfNameOrdinals;  // 输出序数表的RVA
  } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</p>
<p>```</p>
<ul>
<li>典型输出表图</li>
</ul>
<p><img alt="1533225246270" src="../../../_images/crypto/1533225246270.png" /></p>
<ul>
<li>输出序数表起到联系名称表和地址表的作用</li>
<li>输出序数表和名称表一一对应，一同使用，加载器取到名称的同时，也取到了索引</li>
<li>取到索引后，就可以访问输出表了</li>
</ul>
<h5 id="1072">10.7.2  输出表结构实例分析</h5>
<p>以<code>DllDemo.dll</code>为例</p>
<ol>
<li>
<p>数据目录表的第一个成员指向输出表，位于pe文件头的78h偏移处</p>
</li>
<li>
<p>pe文件头起始位置为100h，得到输出表位置178h（100h+78h）</p>
</li>
<li>
<p>查看该位置，发现值为<code>0040000</code>，得到内存偏移地址，再转化成物理地址<code>0C00h</code></p>
</li>
<li>
<p>查看该地址处的内容，其结构为<code>_IMAGE_EXPORT_DIRECTORY</code></p>
<p><img alt="1533225914999" src="../../../_images/crypto/1533225914999.png" /></p>
<ol>
<li>整理后如下：</li>
</ol>
<p><img alt="1533226044745" src="../../../_images/crypto/1533226044745.png" /></p>
</li>
<li>
<p>name:指向DLL的名字</p>
</li>
<li>addressOfNames：指向函数名列表</li>
<li>
<p>AddressOfNameOrdinals：序号名列表</p>
</li>
<li>
<p>调用MsgBox工作过程：</p>
</li>
<li>定位<code>_IMAGE_EXPORT_DIRECTORY</code>，找到ENT地址，知道这个数组里只有1个条目</li>
<li>对名字进行二进制查找，直到找到该函数</li>
<li>直到该函数的序号为1，于是在序号表中读取第一个值，即为MsgBox的输出序数</li>
<li>使用输出序数进入EAT索引，得到MsgBox的RVA：1008h</li>
<li>加上DllDemo的装入地址，得到MsgBox的实际地址</li>
</ol>
<h4 id="108">10.8  基址重定位</h4>
<h5 id="1081">10.8.1  基址重定位概念</h5>
<ul>
<li>
<p>重定位方式：把文件中所有可能需要修改的地址放在一个数组里</p>
</li>
<li>
<p>以DllDemo.dll为例</p>
</li>
</ul>
<p><img alt="1533262787595" src="../../../_images/crypto/1533262787595.png" /></p>
<ul>
<li>
<p>dll的基址为400000h，<code>0040100E</code>地址处指令中入栈地址的RVA为2000h</p>
</li>
<li>
<p>如果dll的基址能按照400000h的地址正确加载，则指令形式不变</p>
</li>
<li>
<p>如果windows加载器决定将其映射到870000h处，加载器会比较基址和实际装入的地址，计算处差值：470000h（870000h-400000h）</p>
</li>
<li>
<p>这样，<code>0040100E</code>地址处的指令就会被修正为：<code>push 872000</code></p>
</li>
<li>
<p>示意图如下：</p>
<p><img alt="1533263226484" src="../../../_images/crypto/1533263226484.png" /></p>
</li>
<li>
<p>重定位后的代码如下：</p>
<p><img alt="1533263289751" src="../../../_images/crypto/1533263289751.png" /></p>
</li>
<li>
<p>exe不需要重定位，但dll会使用宿主exe的空间，所以必须包含重定位信息</p>
</li>
</ul>
<h5 id="1082">10.8.2  基址重定位结构定义</h5>
<ul>
<li>区块名：.reloc</li>
<li>查找方式：数据目录表中的<code>BaseRelocationTable</code></li>
<li>组织方式：按页分割，多个重定位块链接而成</li>
<li>块大小：4KB，必须以4字节对齐</li>
<li>头文件定义</li>
</ul>
<pre><code class="c">typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress; //这一组重定位数据的开始RVA，各重定向的地址必须加上这个RVA才是重定向的完整RVA
    DWORD   SizeOfBlock;    //当前重定位结构的大小
    WORD    TypeOffset[1];  //数组，分高4位和低12位，高4位代表重定位类型，低12位代表重定位地址
                            //该地址与VirtualAddress相加，就得到需要修改数据的地址的指针
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;
</code></pre>

<ul>
<li>示意图</li>
</ul>
<p><img alt="1533264190396" src="../../../_images/crypto/1533264190396.png" /></p>
<h5 id="1083">10.8.3  基址重定位结构实例分析</h5>
<p>以DllDemo.dll为例：</p>
<ul>
<li><code>_IMAGE_BASE_RELOCATION</code>的文件地址偏移为0E00h，其结构如下：</li>
</ul>
<p><img alt="1533264451679" src="../../../_images/crypto/1533264451679.png" /> </p>
<ul>
<li>
<p>得到数据</p>
</li>
<li>
<p>virtualAddress：00001000h</p>
</li>
<li>sizeOfBlock：00000010h（4个重定位数据：（10h-8h）/2h=4h）</li>
<li>
<p>重定位数据：</p>
<ol>
<li>300Fh</li>
<li>3023h</li>
<li>0000h(用于对齐)</li>
<li>0000h(用于对齐)</li>
</ol>
</li>
<li>
<p>重定位地址转换</p>
</li>
</ul>
<p><img alt="1533264676895" src="../../../_images/crypto/1533264676895.png" /></p>
<ul>
<li>查看示例文件</li>
</ul>
<p><img alt="1533265029973" src="../../../_images/crypto/1533265029973.png" /></p>
<ul>
<li>当PE加载器需要重定位地址的时候，会使用差值来修正以上地址中的数据</li>
</ul>
<h4 id="109">10.9  资源</h4>
<p>分类：</p>
<ul>
<li>加速键</li>
<li>位图</li>
<li>光标</li>
<li>对话框</li>
<li>图标</li>
<li>菜单</li>
<li>串表（string table）</li>
<li>工具栏</li>
<li>版本信息</li>
<li>等</li>
</ul>
<h5 id="1091">10.9.1  资源结构</h5>
<ul>
<li>
<p>结构：3层目录</p>
</li>
<li>
<p>1层：根目录</p>
</li>
<li>2层：对应于资源类型</li>
<li>
<p>3层</p>
</li>
<li>
<p>目录结构图</p>
</li>
</ul>
<p><img alt="1533265284468" src="../../../_images/crypto/1533265284468.png" /></p>
<ul>
<li>
<p>资源目录结构</p>
</li>
<li>
<p>数据目录表条目：struct IMAGE_DATA_DIRECTORY Resource，包含资源的RVA和大小</p>
</li>
<li>
<p>每一个节点的结构定义</p>
<p><code>c
typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;   //以字符串命名的资源数量
    WORD    NumberOfIdEntries;  //以整形数字命令的资源数量
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;</code></p>
<p>总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries，即<code>_IMAGE_RESOURCE_DIRECTORY_ENTRY</code>的数目</p>
</li>
<li>
<p>资源目录入口结构</p>
</li>
</ul>
<p><code>c
  typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
      union {
          struct {
              DWORD NameOffset:31;
              DWORD NameIsString:1;
          };
          DWORD   Name;
          WORD    Id;
      };
      union {
          DWORD   OffsetToData;
          struct {
              DWORD   OffsetToDirectory:31;
              DWORD   DataIsDirectory:1;
          };
      };
  } IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;</code></p>
<p>字段的含义和层级有关系，层级不同，字段含义也不同</p>
<ol>
<li>
<p>Name字段</p>
<ul>
<li>
<p>第一层：定义资源类型</p>
</li>
<li>
<p>当资源以类似ID定义并且数值在1-16之间，表示系统预定义，如下</p>
<p><img alt="1533267007843" src="../../../_images/crypto/1533267007843.png" /></p>
</li>
<li>
<p>第二层：定义资源名称</p>
</li>
<li>
<p>第三层：定义代码页编号</p>
</li>
<li>
<p>最高位：</p>
</li>
<li>
<p>最高位为0：作为ID使用</p>
</li>
<li>
<p>最高为为1：做指针使用，指向_IMAGE_RESOURCE_DIR_STRING_U结构</p>
<p><code>c
 typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
     WORD    Length;
     WCHAR   NameString[ 1 ];
 } IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;</code></p>
</li>
</ul>
</li>
<li>
<p>OffsetToData字段</p>
<ul>
<li>
<p>类型：指针</p>
</li>
<li>
<p>高位</p>
</li>
<li>
<p>高位为1：低位指向下一层目录块的地址</p>
</li>
<li>
<p>高位为0：指向_IMAGE_RESOURCE_DATA_ENTRY结构</p>
<p>注：当Name和OffsetToData字段做指针使用时：指的是从根目录开始的偏移量，而不是RVA</p>
</li>
</ul>
</li>
<li>
<p>资源数据入口</p>
</li>
</ol>
<p>经过三层<code>_IMAGE_RESOURCE_DIRECTORY_ENTRY</code>之后，offsetToData指向<code>_IMAGE_RESOURCE_DATA_ENTRY</code>，其结构如下：</p>
<p><code>c
  typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
      DWORD   OffsetToData;
      DWORD   Size;
      DWORD   CodePage;
      DWORD   Reserved;
  } IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;</code></p>
<ul>
<li><code>_IMAGE_RESOURCE_DATA_ENTRY</code>为真正的资源</li>
<li><code>OffsetToData</code>指向资源数据指针，为RVA</li>
</ul>
<h5 id="1092">10.9.2  资源结构实例分析</h5>
<p>以<code>pediy.exe</code>为例</p>
<ol>
<li>
<p>得到资源起始位置：查看数据目录表，得到地址4000h</p>
</li>
<li>
<p>根目录</p>
</li>
</ol>
<p><img alt="1533267576672" src="../../../_images/crypto/1533267576672.png" /></p>
<p><code>_IMAGE_RESOURCE_DIRECTORY_ENTRY</code>的结构数据：</p>
<p><img alt="1533267642202" src="../../../_images/crypto/1533267642202.png" /></p>
<p>以第二个<code>_IMAGE_RESOURCE_DIRECTORY_ENTRY</code>为例，进入第二层</p>
<ol>
<li>
<p>第二层目录</p>
</li>
<li>
<p>地址：4040h</p>
</li>
<li>
<p>总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries = 0+ 1 = 1</p>
<p>说明其后有一个<code>_IMAGE_RESOURCE_DIRECTORY_ENTRY</code></p>
</li>
<li>
<p><code>_IMAGE_RESOURCE_DIRECTORY_ENTRY</code>结构数据：</p>
<ul>
<li>Name 800000E8h：</li>
<li>定义资源名称</li>
<li>最高位为1，用作指针，指向<code>_IMAGE_RESOURCE_DIR_STRING_U</code>结构</li>
<li><code>_IMAGE_RESOURCE_DIR_STRING_U</code>的地址 = 资源块首地址 + Name低位地址 = 4000h + E8h = 40E8h</li>
<li><code>_IMAGE_RESOURCE_DIR_STRING_U</code>数据：<ul>
<li>length: 5</li>
<li>NameString: <code>PEDIY</code></li>
</ul>
</li>
<li>OffToData 80000088h：</li>
<li>最高位为1：说明有下一层</li>
<li>低位数据88h: 指向第三层目录块<code>_IMAGE_RESOURCE_DIECTORY</code>，地址 = 4000h+88h = 4088h</li>
</ul>
</li>
<li>
<p>第三层</p>
</li>
<li>
<p><code>_IMAGE_RESOURCE_DIECTORY</code>地址为：4088h</p>
</li>
<li>
<p><code>_IMAGE_RESOURCE_DIECTORY</code>结构：</p>
<p>总资源数（当前目录的总目录项数） =  NumberOfNamedEntries + NumberOfIdEntries = 0+ 1 =1</p>
<p>说明其后紧跟一个<code>_IMAGE_RESOURCE_DIRECTORY_ENTRY</code>，偏移为4098h</p>
</li>
<li>
<p><code>_IMAGE_RESOURCE_DIRECTORY_ENTRY</code>结构：</p>
<ul>
<li>name（表示代码页编号）:00000409h 代码页为英语</li>
<li><code>OffsetToData</code>：</li>
<li>高位为0：表明没有下一层</li>
<li>低位数据：0C8h，指向<code>_IMAGE_RESOURCE_DATA_ENTRY</code>结构，地址为：4000h+08Ch = 408Ch</li>
</ul>
</li>
<li>
<p><code>_IMAGE_RESOURCE_DATA_ENTRY</code>结构：</p>
<p><code>c
 DWORD   OffsetToData;  //00004400h
 DWORD   Size;          // 0000005Ah
 DWORD   CodePage;
 DWORD   Reserved;</code>
 真实资源RVA =  4400h，大小为5A</p>
</li>
</ol>
<h5 id="1093">10.9.3  资源编辑工具</h5>
<ul>
<li>资源类型</li>
<li>VC类标准资源</li>
<li>Delphi类标准资源</li>
<li>非标准的UNICODE资源（主要是一些VB编译程序）</li>
<li>工具</li>
<li>vc++</li>
<li>resource hacker</li>
<li>exescope</li>
</ul>
<h4 id="1010-tls">10.10  TLS初始化</h4>
<ul>
<li>
<p>TLS（线程本地存储器）：将数据和执行的特定线程联系起来</p>
</li>
<li>
<p>声明TLS变量：__declspce(thread)，该变量将存放在.tls中</p>
</li>
<li>
<p>过程：</p>
</li>
<li>
<p>加载器寻找.tls区</p>
</li>
<li>动态分配足够大的内存，用来存储TLS变量</li>
<li>
<p>将指向该内存的指针，放在TLS数组中，该数组通过FS:[2Ch]访问</p>
</li>
<li>
<p>数据目录表项：<code>IMAGE_DIRECTORY_ENTRY_TLS</code></p>
</li>
<li>
<p>文件头定义结构：</p>
</li>
</ul>
<p><code>c
  typedef struct _IMAGE_TLS_DIRECTORY32 {
      DWORD   StartAddressOfRawData;        //内存起始地址
      DWORD   EndAddressOfRawData;      //内存终止地址
      DWORD   AddressOfIndex;             // 运行库使用这个索引来定位线程局部数据
      DWORD   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK函数指针数组的地址
      DWORD   SizeOfZeroFill;
      DWORD   Characteristics;
  } IMAGE_TLS_DIRECTORY32;</code></p>
<ul>
<li>AddressOfCallBacks<ul>
<li>作用：线程建立和退出时的回调函数，列表中的每一个函数都将被执行</li>
<li>包括主线程和其他线程</li>
<li>运行时刻：TLS数据初始化和回调函数都在OEP之前执行，其为程序最开始运行的地方</li>
<li>特殊用途：病毒和外壳程序</li>
</ul>
</li>
<li>结构中地址为虚拟地址，不是RVA</li>
<li>其不位于.tls中，位于.rdata中</li>
</ul>
<h4 id="1011_1">10.11  调试目录</h4>
<ul>
<li>
<p>数据目录表：第七个条目，IMAGE_DIRECTORY_ENTRY_DEBUG</p>
</li>
<li>
<p>结构如下：</p>
</li>
</ul>
<p><code>c
  typedef struct _IMAGE_DEBUG_DIRECTORY {
      DWORD   Characteristics;
      DWORD   TimeDateStamp;
      WORD    MajorVersion;
      WORD    MinorVersion;
      DWORD   Type;
      DWORD   SizeOfData;
      DWORD   AddressOfRawData;
      DWORD   PointerToRawData;
  } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;</code></p>
<ul>
<li>普遍形式：pdb</li>
</ul>
<h4 id="1012_1">10.12  延迟装入数据</h4>
<ul>
<li>
<p>延迟装入DLL：</p>
</li>
<li>
<p>通过LoadLibrary和GetProcessAddress获得延迟函数的地址</p>
</li>
<li>
<p>直接转向对延迟函数的调用</p>
</li>
<li>
<p>特征</p>
</li>
<li>
<p>不是操作系统的特征</p>
</li>
<li>
<p>通过链接器和运行库加入额外的代码来实现</p>
</li>
<li>
<p>数据目录表项： DelayLoadImportDescriptors</p>
</li>
<li>
<p>ImgDelayDescr的结构：</p>
</li>
</ul>
<p>```c
  typedef struct ImgDelayDescr {
      DWORD           grAttrs;        // attributes
      LPCSTR          szName;         // pointer to dll name
      HMODULE *       phmod;          // address of module handle
      PImgThunkData   pIAT;           // address of the IAT
      PCImgThunkData  pINT;           // address of the INT
      PCImgThunkData  pBoundIAT;      // address of the optional bound IAT
      PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT
      DWORD           dwTimeStamp;    // 0 if not bound,
                                      // O.W. date/time stamp of DLL bound to (Old BIND)
      } ImgDelayDescr, * PImgDelayDescr;</p>
<p>typedef const ImgDelayDescr *   PCImgDelayDescr;</p>
<p>//
  // Delay load import hook notifications
  //
  enum {
      dliStartProcessing,             // used to bypass or note helper only
      dliNotePreLoadLibrary,          // called just before LoadLibrary, can
                                      //  override w/ new HMODULE return val
      dliNotePreGetProcAddress,       // called just before GetProcAddress, can
                                      //  override w/ new FARPROC return value
      dliFailLoadLib,                 // failed to load library, fix it by
                                      //  returning a valid HMODULE
      dliFailGetProc,                 // failed to get proc address, fix it by
                                      //  returning a valid FARPROC
      dliNoteEndProcessing,           // called after all processing is done, no
                                      //  no bypass possible at this point except
                                      //  by longjmp()/throw()/RaiseException.
      };
  ```</p>
<ul>
<li>包含对应DLL的IAT和INT</li>
<li>由运行库代码写入和读出</li>
<li>过程：<ol>
<li>第一次调用API函数</li>
<li>运行库调用LoadLibrary</li>
<li>接着调用GetProcessAddress</li>
<li>最后地址装入延迟装入的IAT</li>
<li>以后每次调用直接来到IAT</li>
</ol>
</li>
<li>所有地址都是虚地址</li>
</ul>
<h4 id="1013_1">10.13  程序异常数据</h4>
<ul>
<li>
<p>基于表的异常处理</p>
</li>
<li>
<p>表中包含每一个可能受到异常展开影响的函数信息</p>
</li>
</ul>
<p>包含内容：</p>
<ol>
<li>起始地址</li>
<li>结束地址</li>
<li>异常应该如何处理</li>
<li>
<p>在什么地方被执行</p>
</li>
<li>
<p>异常发生时，遍历这个表，找到合适的入口，并执行</p>
</li>
<li>
<p>数据成员结构：</p>
</li>
</ol>
<p><code>c
  typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
      DWORD BeginAddress;
      DWORD EndAddress;
      DWORD UnwindInfoAddress;
  } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;</code></p>
<h4 id="1014-net">10.14  .Net头部</h4>
<ul>
<li>
<p>.Net环境组成：</p>
</li>
<li>
<p>公共语言运行环境CLR（将其看作虚拟机）</p>
</li>
<li>
<p>.net框架类库</p>
</li>
<li>
<p>.net文件主要目的：</p>
</li>
</ul>
<p>获得.net特定的装入内存的信息：</p>
<ol>
<li>metadata 元数据</li>
<li>
<p>IL（Intermediate Language）中间语言</p>
</li>
<li>
<p>程序执行：</p>
</li>
<li>
<p>跳转到Mscoree.dll中的<code>_coreExeMain</code>或者<code>_coreDllMain</code></p>
</li>
<li>
<p>Mscoree.dll开始使用metadata和IL</p>
</li>
<li>
<p>程序目录表项：struct IMAGE_DATA_DIRECTORY <code>COMRuntimedescriptor</code></p>
</li>
</ol>
<h4 id="1015-pe">10.15  编写PE分析工具</h4>
<p>定义文件结构：</p>
<pre><code class="c">typedef struct _MAP_FILE_STRUCT
{
    HANDLE hFile;
    HANDLE hMapping;
    LPVOID ImageBase;
}  MAP_FILE_STRUCT,* PMAP_FILE_STRUCT;
</code></pre>

<h5 id="10151">10.15.1  文件格式检查</h5>
<pre><code class="c">BOOL IsPEFile(LPVOID ImageBase)
{
    PIMAGE_DOS_HEADER  pDH=NULL;
    PIMAGE_NT_HEADERS  pNtH=NULL;

    if(!ImageBase)      //判断映像基址
      return FALSE;

    pDH=(PIMAGE_DOS_HEADER)ImageBase;
    if(pDH-&gt;e_magic!=IMAGE_DOS_SIGNATURE)   //判断是否为MZ
         return FALSE;

    pNtH=(PIMAGE_NT_HEADERS32)((DWORD)pDH+pDH-&gt;e_lfanew);   //判断是否为PE
    if (pNtH-&gt;Signature != IMAGE_NT_SIGNATURE )
        return FALSE;

    return TRUE;

}
</code></pre>

<h5 id="10152-fileheaderoptionalheader">10.15.2  FileHeader和OptionalHeader内容的读取</h5>
<ol>
<li>GetNtHeaders</li>
</ol>
<p>```c
   PIMAGE_NT_HEADERS  GetNtHeaders(LPVOID ImageBase)
   {</p>
<pre><code>if(!IsPEFile(ImageBase))
    return NULL;
PIMAGE_NT_HEADERS  pNtH;
PIMAGE_DOS_HEADER  pDH;
pDH=(PIMAGE_DOS_HEADER)ImageBase;
pNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH-&gt;e_lfanew);

return pNtH;
</code></pre>
<p>}</p>
<p>```</p>
<ol>
<li>GetFileHeader</li>
</ol>
<p>```c
   PIMAGE_FILE_HEADER   GetFileHeader(LPVOID ImageBase)
   {
       PIMAGE_DOS_HEADER  pDH=NULL;
       PIMAGE_NT_HEADERS  pNtH=NULL;
       PIMAGE_FILE_HEADER pFH=NULL;</p>
<pre><code>   if(!IsPEFile(ImageBase))
    return NULL;
   pDH=(PIMAGE_DOS_HEADER)ImageBase;
   pNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH-&gt;e_lfanew);
   pFH=&amp;pNtH-&gt;FileHeader;
   return pFH;
</code></pre>
<p>}
   ```</p>
<ol>
<li>GetOptionalHeader</li>
</ol>
<p>```c
   PIMAGE_OPTIONAL_HEADER GetOptionalHeader(LPVOID ImageBase)
   {
       PIMAGE_DOS_HEADER  pDH=NULL;
       PIMAGE_NT_HEADERS  pNtH=NULL;
       PIMAGE_OPTIONAL_HEADER pOH=NULL;</p>
<pre><code>    if(!IsPEFile(ImageBase))
    return NULL;
   pDH=(PIMAGE_DOS_HEADER)ImageBase;
   pNtH=(PIMAGE_NT_HEADERS)((DWORD)pDH+pDH-&gt;e_lfanew);
   pOH=&amp;pNtH-&gt;OptionalHeader;
   return pOH;
</code></pre>
<p>}
   ```</p>
<ol>
<li>显示文件头信息</li>
</ol>
<p>```c
   void    ShowFileHeaderInfo(HWND hWnd)
   {  <br />
    char   cBuff[10];
        PIMAGE_FILE_HEADER pFH=NULL;</p>
<pre><code> pFH=GetFileHeader(stMapFile.ImageBase);
    if(!pFH)
 {
     MessageBox(hWnd,"Can't get File Header ! :(","PEInfo_Example",MB_OK);
     return;
 }
 wsprintf(cBuff, "%04lX", pFH-&gt;Machine);
 SetDlgItemText(hWnd,IDC_EDIT_FH_MACHINE,cBuff);

 wsprintf(cBuff, "%04lX", pFH-&gt;NumberOfSections);
 SetDlgItemText(hWnd,IDC_EDIT_FH_NUMOFSECTIONS,cBuff);

 wsprintf(cBuff, "%08lX", pFH-&gt;TimeDateStamp);
 SetDlgItemText(hWnd,IDC_EDIT_FH_TDS,cBuff);

 wsprintf(cBuff, "%08lX", pFH-&gt;PointerToSymbolTable);
 SetDlgItemText(hWnd,IDC_EDIT_FH_PTSYMBOL,cBuff);

 wsprintf(cBuff, "%08lX", pFH-&gt;NumberOfSymbols);
 SetDlgItemText(hWnd,IDC_EDIT_FH_NUMOFSYM,cBuff);

 wsprintf(cBuff, "%04lX", pFH-&gt;SizeOfOptionalHeader);
 SetDlgItemText(hWnd,IDC_EDIT_FH_SIZEOFOH,cBuff);

 wsprintf(cBuff, "%04lX", pFH-&gt;Characteristics);
 SetDlgItemText(hWnd,IDC_EDIT_FH_CHARACTERISTICS,cBuff);
</code></pre>
<p>}
   ```</p>
<h5 id="10153">10.15.3  得到数据目录表信息</h5>
<pre><code class="c">void ShowDataDirInfo(HWND hDlg)
{
    char   cBuff[9];
    PIMAGE_OPTIONAL_HEADER pOH=NULL;
    pOH=GetOptionalHeader(stMapFile.ImageBase);
   if(!pOH)
        return;

    for(int i=0;i&lt;16;i++)
   {
    wsprintf(cBuff, &quot;%08lX&quot;, pOH-&gt;DataDirectory[i].VirtualAddress);
    SetDlgItemText(hDlg,EditID_Array[i].ID_RVA,cBuff);

     wsprintf(cBuff, &quot;%08lX&quot;, pOH-&gt;DataDirectory[i].Size);
     SetDlgItemText(hDlg,EditID_Array[i].ID_SIZE,cBuff);
    }

}
</code></pre>

<h5 id="10154">10.15.4  得到区块表信息</h5>
<pre><code class="c">void ShowSectionHeaderInfo(HWND hDlg)
{
    LVITEM                  lvItem;
    char                    cBuff[9],cName[9]; 
    WORD                    i;
    PIMAGE_FILE_HEADER       pFH=NULL;
    PIMAGE_SECTION_HEADER   pSH=NULL;


    pFH=GetFileHeader(stMapFile.ImageBase);
    if(!pFH)
        return;

    pSH=GetFirstSectionHeader(stMapFile.ImageBase);

    for( i=0;i&lt;pFH-&gt;NumberOfSections;i++)
    {
        memset(&amp;lvItem, 0, sizeof(lvItem));
        lvItem.mask    = LVIF_TEXT;
        lvItem.iItem   = i;

        memset(cName,0,sizeof(cName));
        memcpy(cName, pSH-&gt;Name, 8);

        lvItem.pszText = cName;
        SendDlgItemMessage(hDlg,IDC_SECTIONLIST,LVM_INSERTITEM,0,(LPARAM)&amp;lvItem);

        lvItem.pszText  = cBuff;
        wsprintf(cBuff, &quot;%08lX&quot;, pSH-&gt;VirtualAddress);
        lvItem.iSubItem = 1;
        SendDlgItemMessage(hDlg,IDC_SECTIONLIST, LVM_SETITEM, 0, (LPARAM)&amp;lvItem);
        ...

        ++pSH;
    }


</code></pre>

<h5 id="10155">10.15.5  得到输出表信息</h5>
<pre><code class="c">void   ShowExportFuncsInfo(HWND hDlg)
{
    HWND         hList;
    LVITEM       lvItem;
    char         cBuff[10], *szFuncName; 

    UINT                    iNumOfName=0;
    PDWORD                  pdwRvas, pdwNames;
    PWORD                   pwOrds;
    UINT                    i=0,j=0,k=0; 
    BOOL                    bIsByName=FALSE;;


    PIMAGE_NT_HEADERS       pNtH=NULL;
    PIMAGE_EXPORT_DIRECTORY pExportDir=NULL;

    pNtH=GetNtHeaders(stMapFile.ImageBase);
    if(!pNtH)
        return ;
    pExportDir= (PIMAGE_EXPORT_DIRECTORY)GetExportDirectory(stMapFile.ImageBase);
    if (!pExportDir)
            return ; 


    pwOrds    = (PWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir-&gt;AddressOfNameOrdinals);
    pdwRvas   = (PDWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir-&gt;AddressOfFunctions);
    pdwNames  = (PDWORD)RvaToPtr(pNtH, stMapFile.ImageBase,pExportDir-&gt;AddressOfNames);

    if(!pdwRvas)
        return;

    hList=GetDlgItem(hDlg,IDC_EXPORT_LIST);
    SendMessage(hList,LVM_SETEXTENDEDLISTVIEWSTYLE,0,(LPARAM)LVS_EX_FULLROWSELECT);


    iNumOfName=pExportDir-&gt;NumberOfNames;

    for( i=0;i&lt;pExportDir-&gt;NumberOfFunctions;i++)
    {
        if(*pdwRvas)
        {    
            for( j=0;j&lt;iNumOfName;j++)
            {
                if(i==pwOrds[j])
                {  
                    bIsByName=TRUE;
                    szFuncName=(char*)RvaToPtr(pNtH,stMapFile.ImageBase,pdwNames[j]);
                    break;
                }

                bIsByName=FALSE;
            }

            //show funcs to listctrl

        memset(&amp;lvItem, 0, sizeof(lvItem));
        lvItem.mask    = LVIF_TEXT;
        lvItem.iItem   = k;

        lvItem.pszText = cBuff;
        wsprintf(cBuff, &quot;%04lX&quot;, (UINT)(pExportDir-&gt;Base+i));
        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST,LVM_INSERTITEM,0,(LPARAM)&amp;lvItem);

        lvItem.pszText  = cBuff;
        wsprintf(cBuff, &quot;%08lX&quot;, (*pdwRvas));
        lvItem.iSubItem = 1;
        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST, LVM_SETITEM, 0, (LPARAM)&amp;lvItem);

        if(bIsByName)           
            lvItem.pszText=szFuncName;
        else
            lvItem.pszText  = &quot;-&quot;;

        lvItem.iSubItem = 2;
        SendDlgItemMessage(hDlg,IDC_EXPORT_LIST, LVM_SETITEM, 0, (LPARAM)&amp;lvItem);


           //
        ++k;

        }

            ++pdwRvas;

 }

</code></pre>

<h5 id="10156">10.15.6  得到输入表信息</h5>
<ol>
<li>找到输入表的位置</li>
</ol>
<pre><code class="c">PIMAGE_IMPORT_DESCRIPTOR  GetFirstImportDesc(LPVOID ImageBase)
{
    PIMAGE_IMPORT_DESCRIPTOR pImportDesc;
    pImportDesc=(PIMAGE_IMPORT_DESCRIPTOR)GetDirectoryEntryToData(ImageBase,IMAGE_DIRECTORY_ENTRY_IMPORT);
    if(!pImportDesc)
        return NULL;     
    return  pImportDesc;
}
</code></pre>

<ol>
<li>循环输出整个表</li>
</ol>
<pre><code class="c">void  ShowImportDescInfo(HWND hDlg)
{
    HWND         hList;
    LVITEM       lvItem;
    char         cBuff[10], * szDllName; 

    PIMAGE_NT_HEADERS       pNtH=NULL;
    PIMAGE_IMPORT_DESCRIPTOR  pImportDesc=NULL;

    memset(&amp;lvItem, 0, sizeof(lvItem));

    hList=GetDlgItem(hDlg,IDC_IMPORT_LIST);
    SendMessage(hList,LVM_SETEXTENDEDLISTVIEWSTYLE,0,(LPARAM)LVS_EX_FULLROWSELECT);

    pNtH=GetNtHeaders(stMapFile.ImageBase);
    pImportDesc=GetFirstImportDesc(stMapFile.ImageBase);
    if(!pImportDesc)
    {
        MessageBox(hDlg,&quot;Can't get ImportDesc:(&quot;,&quot;PEInfo_Example&quot;,MB_OK);
        return;
    }

    int i=0;
    while(pImportDesc-&gt;FirstThunk)
    {

        memset(&amp;lvItem, 0, sizeof(lvItem));
        lvItem.mask    = LVIF_TEXT;
        lvItem.iItem   = i;

        szDllName=(char*)RvaToPtr(pNtH,stMapFile.ImageBase,pImportDesc-&gt;Name);

...
       ++i;
       ++pImportDesc;
    }

}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%20%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" class="btn btn-neutral float-right" title="加密与解密 第四章 逆向分析技术">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/" class="btn btn-neutral" title="加密与解密 第二章 动态调试技术"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>0Xor</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%20%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%20%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/require.js"></script>
      <script src="../../../search/search.js"></script>

</body>
</html>
